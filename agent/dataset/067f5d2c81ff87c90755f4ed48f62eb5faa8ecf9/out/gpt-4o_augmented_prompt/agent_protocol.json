{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -213,7 +213,7 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n          } catch (TException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n@@ -214,7 +214,7 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n          } catch (TException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n@@ -214,7 +214,7 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n          } catch (TException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "unreported exception org.apache.thrift.transport.TTransportException; must be caught or declared to be thrown\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\nrecord = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n          } catch (TException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "121": {
                            "lines": [
                                {
                                    "line_no": 120,
                                    "content": "   */"
                                },
                                {
                                    "line_no": 121,
                                    "content": "  private TSerializer serializer = new TSerializer();"
                                },
                                {
                                    "line_no": 122,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[121,36] unreported exception org.apache.thrift.transport.TTransportException; must be caught or declared to be thrown\n"
                            ]
                        }
                    }
                }
            },
            "error": "unreported exception org.apache.thrift.transport.TTransportException; must be caught or declared to be thrown\n",
            "span_id": 10065223900333602059
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -213,13 +213,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n} catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "270": {
                            "lines": [
                                {
                                    "line_no": 269,
                                    "content": "            value = serializer.serialize(event);"
                                },
                                {
                                    "line_no": 270,
                                    "content": "-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);"
                                },
                                {
                                    "line_no": 271,
                                    "content": "+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);"
                                }
                            ],
                            "error_texts": [
                                "[270,1] bad operand type org.apache.kafka.clients.producer.ProducerRecord<byte[],byte[]> for unary operator '-'\n"
                            ]
                        },
                        "271": {
                            "lines": [
                                {
                                    "line_no": 270,
                                    "content": "-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);"
                                },
                                {
                                    "line_no": 271,
                                    "content": "+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);"
                                },
                                {
                                    "line_no": 272,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                }
                            ],
                            "error_texts": [
                                "[271,1] bad operand type org.apache.kafka.clients.producer.ProducerRecord<byte[],byte[]> for unary operator '+'\n"
                            ]
                        },
                        "273": {
                            "lines": [
                                {
                                    "line_no": 272,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 273,
                                    "content": "} catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 274,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[273,23] cannot find symbol\nsymbol: class TTransportException\nlocation: class com.pinterest.singer.loggingaudit.client.AuditEventKafkaSender\n",
                                "[273,23] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 15294341719019210251
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "274": {
                            "lines": [
                                {
                                    "line_no": 273,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 274,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 275,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[274,12] illegal start of expression\n",
                                "[274,1] not a statement\n"
                            ]
                        },
                        "275": {
                            "lines": [
                                {
                                    "line_no": 274,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 275,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 276,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[275,1] not a statement\n",
                                "[275,12] illegal start of expression\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 1541572658538752661
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "275": {
                            "lines": [
                                {
                                    "line_no": 274,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 275,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 276,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[275,1] not a statement\n",
                                "[275,12] illegal start of expression\n"
                            ]
                        },
                        "276": {
                            "lines": [
                                {
                                    "line_no": 275,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 276,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 277,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[276,12] illegal start of expression\n",
                                "[276,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 2996102086769321774
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "276": {
                            "lines": [
                                {
                                    "line_no": 275,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 276,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 277,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[276,12] illegal start of expression\n",
                                "[276,1] not a statement\n"
                            ]
                        },
                        "277": {
                            "lines": [
                                {
                                    "line_no": 276,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 277,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 278,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[277,12] illegal start of expression\n",
                                "[277,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 3011445438480280302
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "277": {
                            "lines": [
                                {
                                    "line_no": 276,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 277,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 278,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[277,12] illegal start of expression\n",
                                "[277,1] not a statement\n"
                            ]
                        },
                        "278": {
                            "lines": [
                                {
                                    "line_no": 277,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 278,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 279,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[278,12] illegal start of expression\n",
                                "[278,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 320832808314781157
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "278": {
                            "lines": [
                                {
                                    "line_no": 277,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 278,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 279,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[278,12] illegal start of expression\n",
                                "[278,1] not a statement\n"
                            ]
                        },
                        "279": {
                            "lines": [
                                {
                                    "line_no": 278,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 279,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 280,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[279,1] not a statement\n",
                                "[279,12] illegal start of expression\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 13616418699560143439
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "279": {
                            "lines": [
                                {
                                    "line_no": 278,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 279,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 280,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[279,1] not a statement\n",
                                "[279,12] illegal start of expression\n"
                            ]
                        },
                        "280": {
                            "lines": [
                                {
                                    "line_no": 279,
                                    "content": "-          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 280,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 281,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[280,12] illegal start of expression\n",
                                "[280,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 11373736887816724680
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "280": {
                            "lines": [
                                {
                                    "line_no": 279,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 280,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 281,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[280,12] illegal start of expression\n",
                                "[280,1] not a statement\n"
                            ]
                        },
                        "281": {
                            "lines": [
                                {
                                    "line_no": 280,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 281,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 282,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[281,12] illegal start of expression\n",
                                "[281,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 4282138263420656754
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | TTransportException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "281": {
                            "lines": [
                                {
                                    "line_no": 280,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 281,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 282,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[281,12] illegal start of expression\n",
                                "[281,1] not a statement\n"
                            ]
                        },
                        "282": {
                            "lines": [
                                {
                                    "line_no": 281,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 282,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 283,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[282,1] not a statement\n",
                                "[282,12] illegal start of expression\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 11136288097824449044
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "282": {
                            "lines": [
                                {
                                    "line_no": 281,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 282,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 283,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[282,1] not a statement\n",
                                "[282,12] illegal start of expression\n"
                            ]
                        },
                        "283": {
                            "lines": [
                                {
                                    "line_no": 282,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 283,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 284,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[283,1] not a statement\n",
                                "[283,12] illegal start of expression\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 16525711507777193752
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | TTransportException e) {\n+          } catch (TException | org.apache.thrift.transport.TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "283": {
                            "lines": [
                                {
                                    "line_no": 282,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 283,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 284,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[283,1] not a statement\n",
                                "[283,12] illegal start of expression\n"
                            ]
                        },
                        "284": {
                            "lines": [
                                {
                                    "line_no": 283,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 284,
                                    "content": "+          } catch (TException | org.apache.thrift.transport.TTransportException e) {"
                                },
                                {
                                    "line_no": 285,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[284,12] illegal start of expression\n",
                                "[284,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 343807136554016481
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "284": {
                            "lines": [
                                {
                                    "line_no": 283,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 284,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 285,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[284,12] illegal start of expression\n",
                                "[284,1] not a statement\n"
                            ]
                        },
                        "285": {
                            "lines": [
                                {
                                    "line_no": 284,
                                    "content": "-          } catch (TException e) {"
                                },
                                {
                                    "line_no": 285,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 286,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[285,12] illegal start of expression\n",
                                "[285,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 8787048579481709703
        },
        {
            "input": "```diff\nsinger-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java\n@@ -19,6 +19,7 @@\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.PartitionInfo;\n import org.apache.thrift.TException;\n+import org.apache.thrift.transport.TTransportException;\n import org.apache.thrift.TSerializer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -213,13 +214,13 @@\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n        OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n-            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n+            record = new ProducerRecord<>(this.topic, currentPartitionId, null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n-          } catch (TException | TTransportException e) {\n+          } catch (TException | TTransportException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n                Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n            OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n            OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n        insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n            OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n            OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n      } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}"
                },
                "compile_error_details": {
                    "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java": {
                        "285": {
                            "lines": [
                                {
                                    "line_no": 284,
                                    "content": "            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));"
                                },
                                {
                                    "line_no": 285,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 286,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                }
                            ],
                            "error_texts": [
                                "[285,12] illegal start of expression\n",
                                "[285,1] not a statement\n"
                            ]
                        },
                        "286": {
                            "lines": [
                                {
                                    "line_no": 285,
                                    "content": "-          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 286,
                                    "content": "+          } catch (TException | TTransportException e) {"
                                },
                                {
                                    "line_no": 287,
                                    "content": "            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\","
                                }
                            ],
                            "error_texts": [
                                "[286,12] illegal start of expression\n",
                                "[286,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 5317572808393128274
        }
    ],
    "read_file": [
        {
            "input": "singer-commons/src/main/java/com/pinterest/singer/loggingaudit/client/AuditEventKafkaSender.java",
            "output": "/**\n * Copyright 2019 Pinterest, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.pinterest.singer.loggingaudit.client;\n\nimport com.pinterest.singer.loggingaudit.client.common.LoggingAuditClientMetrics;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditHeaders;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditEvent;\nimport com.pinterest.singer.loggingaudit.thrift.LoggingAuditStage;\nimport com.pinterest.singer.loggingaudit.thrift.configuration.KafkaSenderConfig;\nimport com.pinterest.singer.metrics.OpenTsdbMetricConverter;\nimport com.pinterest.singer.utils.CommonUtils;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.TSerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n *  LoggingAuditEventSender implementations that dequeue LoggingAuditEvent and send it to Kafka.\n *\n *  Each instance of this class should be executed in its own thread.\n */\npublic class AuditEventKafkaSender implements LoggingAuditEventSender {\n\n  private static final Logger LOG = LoggerFactory.getLogger(AuditEventKafkaSender.class);\n\n  private static final int MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION = 10;\n\n  private static final int PARTITIONS_REFRESH_INTERVAL_IN_SECONDS = 30;\n\n  /**\n   *  When sender send audit events to Kafka,  it chooses a random partition and if it fails, it\n   *  will choose another GOOD partition, this retry will happen at most numOfPartitionsToTrySending\n   *  times before dropping the event. Note that, this is different from the retry handled by\n   *  kafka client\n   *  library when sending an event to a certain partition.\n   */\n  private static final int NUM_OF_PARTITIONS_TO_TRY_SENDING = 3;\n\n  /**\n   *  maximum time to wait when sender tries to dequeue events before returning null.\n   */\n  private static final int DEQUEUE_WAIT_IN_SECONDS = 30;\n\n\n  /**\n   *   when gracefully shutting down the Sender, the calling thread sleeps for some time and let\n   *   the sender to send out audit events left in the queue if there are any.\n   *   stopGracePeriodInSeconds is the maximum time reserved and\n   *   stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS is the total rounds the calling thread\n   *   will sleep.\n   */\n  private static final int THREAD_SLEEP_IN_SECONDS = 10;\n\n  /**\n   *  when gracefully shutting down the Sender, this field specifies maximum time for main thread\n   *  to wait, in order to let the sender send out audit events left in the queue if there are any.\n   */\n  private int stopGracePeriodInSeconds = 300;\n\n\n  /**\n   * Logging audit stage, can be THRIFTLOGGER, SINGER, MERCED and so on\n   */\n  private final LoggingAuditStage stage;\n\n  /**\n   * host name\n   */\n  private final String host;\n\n  /**\n   *  LinkedBlockingDequeue to store the LoggingAuditEvents.  The max capacity is specified when\n   *  creating this deque in the LoggingAuditClient.java\n   *\n   *  The AuditEventKafkaSender dequeue from the beginning of the deque, if does not send out event\n   *  successfully, it will enqueue this event to the beginning of the queue.  Note that, if enqueue\n   *  the failed event at the end of the queue, this event could be processed with quite some delay\n   *  and this is not the behavior we want.  That's we use LinkedBlockingDequeue,\n   *  not ArrayBlockingQueue.\n   */\n  private final LinkedBlockingDeque<LoggingAuditEvent> queue;\n\n  /**\n   * KafkaProducer instance to send audit events\n   */\n  private KafkaProducer<byte[], byte[]> kafkaProducer;\n\n  /**\n   * Serialize key and value to byte[]\n   */\n  private TSerializer serializer = new TSerializer();\n\n  /**\n   *  flag to control the start and stop of the executing thread.\n   */\n  private AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  /**\n   *  topic to store the audit events\n   */\n  private String topic;\n\n  /**\n   *  name of this sender instance\n   */\n  private String name;\n\n  /**\n   *  executing thread\n   */\n  private Thread thread;\n\n  /**\n   *  List of PartitionInfo\n   */\n  private List<PartitionInfo> partitionInfoList = new ArrayList<>();\n\n  /**\n   *  last time when partition list was refreshed. we want to refresh partition list every 5 mins.\n   */\n  private long lastTimeUpdate = -1;\n\n  /**\n   *  If sending out to one partition fails, this partition is added to set;\n   *  If sending out to one partition succeeds, this partition is removed if it was added before.\n   */\n  private Set<Integer> badPartitions = ConcurrentHashMap.newKeySet();\n\n  /**\n   * For each event (identified by LoggingAuditHeaders, key of the map), track the number of tries\n   * for sending to Kafka. Each try will choose a different and partition that is not in the\n   * badPartitions.  When event is send out successfully or dropped, the corresponding entry in\n   * this map is removed.\n   */\n\n  private Map<LoggingAuditHeaders, Integer> eventTriedCount = new ConcurrentHashMap<>();\n\n  /**\n   *  currentPartitionId specifies the partition of audit_event topic used to receive audit events.\n   *  The currentPartitionId will be reset in resetCurrentPartitionIdIfNeeded() method. This reduces\n   *  the number of TCP connections from audit client to the Kafka Cluster hosting the audit_event\n   *  topic.\n   */\n  private int currentPartitionId = -1;\n\n  public AuditEventKafkaSender(KafkaSenderConfig config,\n                               LinkedBlockingDeque<LoggingAuditEvent> queue,\n                               LoggingAuditStage stage, String host, String name) {\n    this.topic = config.getTopic();\n    this.queue = queue;\n    this.stage = stage;\n    this.host = host;\n    this.name = name;\n    this.stopGracePeriodInSeconds = config.getStopGracePeriodInSeconds();\n    this.badPartitions.add(-1);\n  }\n\n\n  public KafkaProducer<byte[], byte[]> getKafkaProducer() {\n    return kafkaProducer;\n  }\n\n  public void setKafkaProducer(KafkaProducer<byte[], byte[]> kafkaProducer) {\n    this.kafkaProducer = kafkaProducer;\n  }\n\n  private void refreshPartitionIfNeeded() {\n    // refresh every 30 seconds\n    if (System.currentTimeMillis() - lastTimeUpdate > 1000 * PARTITIONS_REFRESH_INTERVAL_IN_SECONDS) {\n      try {\n        badPartitions.clear();\n        badPartitions.add(-1);\n        partitionInfoList = this.kafkaProducer.partitionsFor(topic);\n        lastTimeUpdate = System.currentTimeMillis();\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_COUNT, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      } catch (Exception e) {\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITIONS_REFRESH_ERROR, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n      }\n    }\n    resetCurrentPartitionIdIfNeeded();\n  }\n\n  private void resetCurrentPartitionIdIfNeeded() {\n    if (partitionInfoList.size() == 0) {\n      currentPartitionId = -1;\n      return;\n    }\n    if (badPartitions.contains(currentPartitionId)){\n      int trial = 0;\n      while (trial < MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION) {\n        trial += 1;\n        int index = ThreadLocalRandom.current().nextInt(partitionInfoList.size());\n        int randomPartition = partitionInfoList.get(index).partition();\n        if (!badPartitions.contains(randomPartition)) {\n          LOG.warn(\"Change current partition of audit event topic from {} to {}\", currentPartitionId,\n              randomPartition);\n          currentPartitionId = randomPartition;\n          OpenTsdbMetricConverter.incr(\n              LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CURRENT_PARTITION_RESET, 1,\n              \"host=\" + host, \"stage=\" + stage.toString());\n          return;\n        }\n      }\n      currentPartitionId =  partitionInfoList.get(ThreadLocalRandom.current().nextInt(\n          partitionInfoList.size())).partition();\n      LOG.warn(\"After {} trials, set current partition to {}\",\n          MAX_RETRIES_FOR_SELECTION_RANDOM_PARTITION, currentPartitionId);\n\n    }\n  }\n\n  /**\n   *  Sender dequeues LoggingAuditEvents and sends them to Kafka cluster. If send to one partition\n   *  fails, it will choose another partition. For each event, it will try at most\n   *  NUM_OF_PARTITIONS_TO_TRY_SENDING times (3 times) before dropping this event. Metrics are\n   *  used to track the queue size and usuage, number of events sent out to Kafka successfully, and\n   *  the number of events dropped.\n   */\n  @Override\n  public void run() {\n    LoggingAuditEvent event = null;\n    ProducerRecord<byte[], byte[]> record;\n    byte[] value = null;\n\n    while (!cancelled.get()) {\n      try {\n        refreshPartitionIfNeeded();\n        if (currentPartitionId == -1){\n          Thread.sleep(100);\n          continue;\n        }\n        event = queue.poll(DEQUEUE_WAIT_IN_SECONDS, TimeUnit.SECONDS);\n        if (event != null) {\n          try {\n            value = serializer.serialize(event);\n            record = new ProducerRecord<>(this.topic, currentPartitionId , null, value);\n            kafkaProducer.send(record, new KafkaProducerCallback(event, currentPartitionId));\n          } catch (TException e) {\n            LOG.debug(\"[{}] failed to construct ProducerRecord because of serialization exception.\",\n                Thread.currentThread().getName(), e);\n            OpenTsdbMetricConverter\n                .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_SERIALIZATION_EXCEPTION, 1,\n                    \"host=\" + host, \"stage=\" + stage.toString(),\n                    \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n            eventTriedCount.remove(event.getLoggingAuditHeaders());\n          }\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted when polling the queue and while loop is ended!\",\n            Thread.currentThread().getName(), e);\n        OpenTsdbMetricConverter.incr(\n            LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_DEQUEUE_INTERRUPTED_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      } catch (Exception e) {\n        LOG.warn(\"Exit the while loop and finish the thread execution due to exception: \", e);\n        OpenTsdbMetricConverter.incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_EXCEPTION, 1,\n            \"host=\" + host, \"stage=\" + stage.toString());\n        break;\n      }\n    }\n  }\n\n\n  public class KafkaProducerCallback implements Callback {\n\n    private LoggingAuditEvent event;\n    private int partition;\n\n    public KafkaProducerCallback(LoggingAuditEvent event, int partition) {\n      this.event = event;\n      this.partition = partition;\n    }\n\n    public void checkAndEnqueueWhenSendFailed() {\n      // if exception thrown (i.e. the send failed), the partition is added to badPartitions.\n      badPartitions.add(this.partition);\n      OpenTsdbMetricConverter\n          .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_PARTITION_ERROR, 1,\n              \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic,\n              \"partition=\" + this.partition);\n\n      // retry the failed event by inserting it at the beginning of the deque.\n      // If number of tries reaches 3, meaning that 3 partitions have been tried sending to but\n      // still failed, this event is dropped.\n      Integer count = eventTriedCount.get(event.getLoggingAuditHeaders());\n      if (count == null){\n        eventTriedCount.put(event.getLoggingAuditHeaders(), 1);\n        insertEvent(event);\n        OpenTsdbMetricConverter\n            .gauge(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_RETRIED,\n                eventTriedCount.size(), \"host=\" + host, \"stage=\" + stage.toString(),\n                \"topic=\" + topic);\n      } else if (count >= NUM_OF_PARTITIONS_TO_TRY_SENDING) {\n          LOG.debug(\"Failed to send audit event after trying {} partitions. Drop event.\", count);\n          OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_DROPPED, 1,\n                  \"host=\" + host, \"stage=\" + stage.toString(),\n                  \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n          eventTriedCount.remove(event.getLoggingAuditHeaders());\n      } else {\n          eventTriedCount.put(event.getLoggingAuditHeaders(), count + 1);\n          insertEvent(event);\n      }\n    }\n\n    public void insertEvent(LoggingAuditEvent event){\n      try {\n        boolean success = queue.offerFirst(event, 3, TimeUnit.SECONDS);\n        if (!success) {\n          LOG.debug(\"Failed to enqueue LoggingAuditEvent at head of the queue when executing \"\n              + \"producer send callback. Drop this event.\");\n          eventTriedCount.remove(event.getLoggingAuditHeaders());\n        }\n      } catch (InterruptedException ex) {\n        LOG.debug(\n            \"Enqueuing LoggingAuditEvent at head of the queue was interrupted in callback. \"\n                + \"Drop this event\");\n        eventTriedCount.remove(event.getLoggingAuditHeaders());\n      }\n    }\n\n    @Override\n    public void onCompletion(RecordMetadata recordMetadata, Exception e) {\n      try {\n        if (e == null) {\n          OpenTsdbMetricConverter\n              .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_EVENTS_ACKED, 1,\n                  \"host=\" + host, \"stage=\" + stage.toString(),\n                  \"logName=\" + event.getLoggingAuditHeaders().getLogName());\n\n          // if send is successful, remove the event from the map eventTriedCount if it was added\n          // LoggingAuditHeaders can uniquely identify an event.\n          eventTriedCount.remove(event.getLoggingAuditHeaders());\n          // if send out successfully, remove the partition from the badPartitions if it was added.\n          badPartitions.remove(recordMetadata.partition());\n        } else {\n          checkAndEnqueueWhenSendFailed();\n        }\n      } catch (Throwable t) {\n        LOG.warn(\"Exception throws in the callback. Drop this event {}\", event, t);\n        OpenTsdbMetricConverter\n            .incr(LoggingAuditClientMetrics.AUDIT_CLIENT_SENDER_KAFKA_CALLBACK_EXCEPTION, 1,\n                \"host=\" + host, \"stage=\" + stage.toString(), \"topic=\" + topic);\n      }\n    }\n  }\n\n  /**\n   *  start the executing thread and let the Sender run.\n   */\n  public synchronized void start() {\n    if (this.thread == null) {\n      thread = new Thread(this);\n      thread.setDaemon(true);\n      thread.setName(name);\n      thread.start();\n      LOG.warn(\n          \"[{}] created and started [{}] to let it dequeue LoggingAuditEvents and send to Kafka.\",\n          Thread.currentThread().getName(), name);\n    }\n  }\n\n  /**\n   *  reserve some time (by default 30 seconds at most)to let AuditEventKafkaSender to send out\n   *  LoggingAuditEvent in the queue and gracefully stop AuditEventKafkaSender.\n   */\n  public synchronized void stop() {\n    LOG.warn(\n        \"[{}] waits up to {} seconds to let [{}] send out LoggingAuditEvents left in the queue if\"\n            + \" any.\",\n        Thread.currentThread().getName(), stopGracePeriodInSeconds, name);\n    int i = 0;\n    int numOfRounds = stopGracePeriodInSeconds / THREAD_SLEEP_IN_SECONDS;\n    while (queue.size() > 0 && this.thread != null && thread.isAlive() && i < numOfRounds) {\n      i += 1;\n      try {\n        Thread.sleep(THREAD_SLEEP_IN_SECONDS * 1000);\n        CommonUtils.reportQueueUsage(queue.size(), queue.remainingCapacity(), host, stage.toString());\n        LOG.info(\"In {} round, [{}] waited {} seconds and the current queue size is {}\", i,\n            Thread.currentThread().getName(), THREAD_SLEEP_IN_SECONDS, queue.size());\n      } catch (InterruptedException e) {\n        LOG.warn(\"[{}] got interrupted while waiting for [{}] to send out LoggingAuditEvents left \"\n            + \"in the queue.\", Thread.currentThread().getName(), name, e);\n      }\n    }\n    cancelled.set(true);\n    if (this.thread != null && thread.isAlive()) {\n      thread.interrupt();\n    }\n    try {\n      this.kafkaProducer.close();\n    } catch (Throwable t) {\n      LOG.warn(\"Exception is thrown while stopping {}.\", name, t);\n    }\n    LOG.warn(\"[{}] is stopped and the number of LoggingAuditEvents left in the queue is {}.\", name,\n        queue.size());\n  }\n\n}\n",
            "error": "",
            "span_id": 11011158229497394536
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}