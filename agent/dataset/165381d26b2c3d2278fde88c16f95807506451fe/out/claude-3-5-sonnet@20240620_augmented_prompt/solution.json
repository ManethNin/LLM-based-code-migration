{"compilation_has_succeeded": true, "test_has_succeeded": true, "error_text": "", "updated_files": {"safeplace/src/test/java/org/btrplace/safeplace/DSN.java": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false).setIndentSize(4);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n"}, "compile_error_details": {}}