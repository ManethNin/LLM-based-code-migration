{
    "validate_diffs": [
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+\n+import com.github.javaparser.printer.configuration.DefaultPrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final DefaultPrettyPrinterConfiguration noComments = new DefaultPrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": "{'safeplace/src/test/java/org/btrplace/safeplace/DSN.java': '/*\\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\\n * Use of this source code is governed by a LGPL-style\\n * license that can be found in the LICENSE.txt file.\\n */\\n\\npackage org.btrplace.safeplace;\\n\\nimport com.github.javaparser.JavaParser;\\nimport com.github.javaparser.ParseResult;\\nimport com.github.javaparser.ast.CompilationUnit;\\nimport com.github.javaparser.ast.body.MethodDeclaration;\\nimport com.github.javaparser.ast.expr.AnnotationExpr;\\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\\n\\nimport com.github.javaparser.printer.configuration.DefaultPrettyPrinterConfiguration;\\nimport org.btrplace.safeplace.spec.Constraint;\\nimport org.btrplace.safeplace.spec.SpecScanner;\\nimport org.btrplace.safeplace.testing.Bench;\\nimport org.btrplace.safeplace.testing.Result;\\nimport org.btrplace.safeplace.testing.TestCampaign;\\nimport org.btrplace.safeplace.testing.TestScanner;\\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\\nimport org.btrplace.safeplace.testing.verification.Verifier;\\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\\nimport org.testng.Assert;\\n\\nimport java.io.InputStream;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.util.ArrayList;\\nimport java.util.EnumSet;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @author Fabien Hermenier\\n */\\npublic class DSN {\\n\\n    public static String root = \"xp-dsn\";\\n\\n    public TestScanner newScanner() throws Exception {\\n        SpecScanner specScanner = new SpecScanner();\\n        List<Constraint> l = specScanner.scan();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        return new TestScanner(l);\\n    }\\n\\n    ////@Test\\n    public void fuzzingSizing() throws Exception {\\n        TestScanner sc = newScanner();\\n        Path path = Paths.get(root,\"fuzz.csv\");\\n        Files.deleteIfExists(path);\\n\\n        for (int p = 100; p <= 1000; p+=100) {\\n            for (int s = 2; s <= 20; s+=2) {\\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\\n                Bench.report = new CSVReport(path, Integer.toString(p));\\n                Bench.population = p;\\n                Bench.scale = s;\\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\\n                if (campaigns.isEmpty()) {\\n                    Assert.fail(\"Nothing to test\");\\n                }\\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\\n            }\\n        }\\n    }\\n\\n    //@Test\\n    public void fuzzingScalability() throws Exception {\\n        TestScanner sc = newScanner();\\n\\n        //Warm-up\\n        Bench.transitions = true;\\n\\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n\\n     /*   for (int i = 10; i <= 30; i+=2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.report = new CSVReport(p,\"\");\\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\\n        }*/\\n\\n\\n        //GOGO\\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.mode = Bench.Mode.DEFAULT;\\n        for (int i = 1; i <= 30; i += 2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n\\n        p = Paths.get(root, \"testing-speed-trans.csv\");\\n        Files.deleteIfExists(p);\\n\\n        for (int i = 1; i <= 30; i+=2) {\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.transitions = true;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n    }\\n\\n    //@Test\\n    public void specLength() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\\\n\")));\\n\\n        Path path = Paths.get(root, \"inv.csv\");\\n        String out = l.stream()\\n                .map(c -> Integer.toString(c.proposition().toString().length()))\\n                .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n\\n        List<Integer> funcs = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\\n                .filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)) {\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\\n            }\\n        }\\n        path = Paths.get(root, \"func.csv\");\\n        out = funcs.stream()\\n                        .map(c -> Integer.toString(c))\\n                        .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n    }\\n\\n    //@Test\\n    public void funcFrequency() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\\\\\()+\");\\n        Map<String, Integer> map = new HashMap<>();\\n        for (Constraint c : l) {\\n            String prop = c.proposition().toString();\\n            Matcher m = p.matcher(prop);\\n            System.out.println(prop);\\n            int start = 0;\\n            while (m.find(start)) {\\n                String name = prop.substring(m.start(), m.end() - 1);\\n                if (Character.isLowerCase(name.charAt(0))) {\\n                    if (!map.containsKey(name)) {\\n                        map.put(name, 1);\\n                    } else {\\n                        map.put(name, map.get(name) + 1);\\n                    }\\n                }\\n                System.out.println(\"\\\\t\" + prop.substring(m.start(), m.end() - 1));\\n                start = m.end();\\n            }\\n        }\\n        System.out.println(map);\\n        Path out = Paths.get(root, \"func-freq.csv\");\\n        Files.deleteIfExists(out);\\n        String cnt = \"name;freq\\\\n\" +\\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\\\n\").collect(Collectors.joining());\\n        Files.write(out, cnt.getBytes());\\n\\n    }\\n\\n    //@Test\\n    public void specVsCheckers() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path p = Paths.get(root, \"verifier_stable.csv\");\\n        Files.deleteIfExists(p);\\n        boolean first = true;\\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\\n            Bench.report = new CSVReport(p, v.id());\\n            sc.test(Bench.class).forEach(c -> {\\n                c.verifyWith(v);\\n                System.out.println(c.go().toString());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void discreteVsContinuous() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"restriction_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, r.toString());\\n            sc.testGroups(\"bi\").forEach(x -> {\\n                Bench.restrictions = EnumSet.of(r);\\n                System.out.println(x.go());\\n            });\\n        }\\n        //restore\\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\\n    }\\n\\n    //@Test\\n    public void repairVsRebuild() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"mode_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (boolean repair : new boolean[]{false, true}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\\n            sc.test(Bench.class).forEach(x -> {\\n                x.schedulerParams().doRepair(true);\\n                System.out.println(x.go());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void errors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.source = \"xp-dsn\";\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n        Path p = Paths.get(root, \"errors.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.report = new CSVReport(p, \"\");\\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\\n    }\\n\\n    //@Test\\n    public void prettyErrors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n\\n        sc.test(Bench.class).forEach(x -> {\\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\\n            System.out.println(x.go());\\n        });\\n    }\\n\\n\\n    //@Test\\n    //Extract the number of line of codes of tests\\n    public void testSloc() throws Exception {\\n        //Parse the legacy unit tests\\n        List<Integer> unitTests = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)){\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\\n            }\\n        }\\n\\n        //Parse the new unit tests\\n        List<Integer> safeTests = new ArrayList<>();\\n\\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\\n        }\\n\\n        String sb = \"testing;sloc\\\\n\" +\\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\")) +\\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\"));\\n        Path path = Paths.get(root, \"sloc.csv\");\\n        Files.write(path, sb.getBytes());\\n    }\\n\\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        FunctionVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            if (n.getNameAsString().equals(\"eval\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n      private final DefaultPrettyPrinterConfiguration noComments = new DefaultPrettyPrinterConfiguration().setPrintComments(false);\\n\\n        UnitTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            System.out.println(n.getNameAsString());\\n            if (n.toString(noComments).contains(\"solve\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        SafeplaceTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            for (AnnotationExpr a : n.getAnnotations()) {\\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\\n                    return;\\n                }\\n            }\\n            System.out.println(n.getName());\\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            super.visit(n, arg);\\n        }\\n    }\\n}\\n'}",
            "error": "",
            "span_id": 4462654040442608103
        },
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+\n+import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": "{'safeplace/src/test/java/org/btrplace/safeplace/DSN.java': '/*\\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\\n * Use of this source code is governed by a LGPL-style\\n * license that can be found in the LICENSE.txt file.\\n */\\n\\npackage org.btrplace.safeplace;\\n\\nimport com.github.javaparser.JavaParser;\\nimport com.github.javaparser.ParseResult;\\nimport com.github.javaparser.ast.CompilationUnit;\\nimport com.github.javaparser.ast.body.MethodDeclaration;\\nimport com.github.javaparser.ast.expr.AnnotationExpr;\\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\\n\\nimport com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\\nimport org.btrplace.safeplace.spec.Constraint;\\nimport org.btrplace.safeplace.spec.SpecScanner;\\nimport org.btrplace.safeplace.testing.Bench;\\nimport org.btrplace.safeplace.testing.Result;\\nimport org.btrplace.safeplace.testing.TestCampaign;\\nimport org.btrplace.safeplace.testing.TestScanner;\\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\\nimport org.btrplace.safeplace.testing.verification.Verifier;\\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\\nimport org.testng.Assert;\\n\\nimport java.io.InputStream;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.util.ArrayList;\\nimport java.util.EnumSet;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @author Fabien Hermenier\\n */\\npublic class DSN {\\n\\n    public static String root = \"xp-dsn\";\\n\\n    public TestScanner newScanner() throws Exception {\\n        SpecScanner specScanner = new SpecScanner();\\n        List<Constraint> l = specScanner.scan();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        return new TestScanner(l);\\n    }\\n\\n    ////@Test\\n    public void fuzzingSizing() throws Exception {\\n        TestScanner sc = newScanner();\\n        Path path = Paths.get(root,\"fuzz.csv\");\\n        Files.deleteIfExists(path);\\n\\n        for (int p = 100; p <= 1000; p+=100) {\\n            for (int s = 2; s <= 20; s+=2) {\\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\\n                Bench.report = new CSVReport(path, Integer.toString(p));\\n                Bench.population = p;\\n                Bench.scale = s;\\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\\n                if (campaigns.isEmpty()) {\\n                    Assert.fail(\"Nothing to test\");\\n                }\\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\\n            }\\n        }\\n    }\\n\\n    //@Test\\n    public void fuzzingScalability() throws Exception {\\n        TestScanner sc = newScanner();\\n\\n        //Warm-up\\n        Bench.transitions = true;\\n\\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n\\n     /*   for (int i = 10; i <= 30; i+=2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.report = new CSVReport(p,\"\");\\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\\n        }*/\\n\\n\\n        //GOGO\\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.mode = Bench.Mode.DEFAULT;\\n        for (int i = 1; i <= 30; i += 2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n\\n        p = Paths.get(root, \"testing-speed-trans.csv\");\\n        Files.deleteIfExists(p);\\n\\n        for (int i = 1; i <= 30; i+=2) {\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.transitions = true;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n    }\\n\\n    //@Test\\n    public void specLength() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\\\n\")));\\n\\n        Path path = Paths.get(root, \"inv.csv\");\\n        String out = l.stream()\\n                .map(c -> Integer.toString(c.proposition().toString().length()))\\n                .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n\\n        List<Integer> funcs = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\\n                .filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)) {\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\\n            }\\n        }\\n        path = Paths.get(root, \"func.csv\");\\n        out = funcs.stream()\\n                        .map(c -> Integer.toString(c))\\n                        .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n    }\\n\\n    //@Test\\n    public void funcFrequency() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\\\\\()+\");\\n        Map<String, Integer> map = new HashMap<>();\\n        for (Constraint c : l) {\\n            String prop = c.proposition().toString();\\n            Matcher m = p.matcher(prop);\\n            System.out.println(prop);\\n            int start = 0;\\n            while (m.find(start)) {\\n                String name = prop.substring(m.start(), m.end() - 1);\\n                if (Character.isLowerCase(name.charAt(0))) {\\n                    if (!map.containsKey(name)) {\\n                        map.put(name, 1);\\n                    } else {\\n                        map.put(name, map.get(name) + 1);\\n                    }\\n                }\\n                System.out.println(\"\\\\t\" + prop.substring(m.start(), m.end() - 1));\\n                start = m.end();\\n            }\\n        }\\n        System.out.println(map);\\n        Path out = Paths.get(root, \"func-freq.csv\");\\n        Files.deleteIfExists(out);\\n        String cnt = \"name;freq\\\\n\" +\\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\\\n\").collect(Collectors.joining());\\n        Files.write(out, cnt.getBytes());\\n\\n    }\\n\\n    //@Test\\n    public void specVsCheckers() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path p = Paths.get(root, \"verifier_stable.csv\");\\n        Files.deleteIfExists(p);\\n        boolean first = true;\\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\\n            Bench.report = new CSVReport(p, v.id());\\n            sc.test(Bench.class).forEach(c -> {\\n                c.verifyWith(v);\\n                System.out.println(c.go().toString());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void discreteVsContinuous() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"restriction_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, r.toString());\\n            sc.testGroups(\"bi\").forEach(x -> {\\n                Bench.restrictions = EnumSet.of(r);\\n                System.out.println(x.go());\\n            });\\n        }\\n        //restore\\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\\n    }\\n\\n    //@Test\\n    public void repairVsRebuild() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"mode_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (boolean repair : new boolean[]{false, true}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\\n            sc.test(Bench.class).forEach(x -> {\\n                x.schedulerParams().doRepair(true);\\n                System.out.println(x.go());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void errors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.source = \"xp-dsn\";\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n        Path p = Paths.get(root, \"errors.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.report = new CSVReport(p, \"\");\\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\\n    }\\n\\n    //@Test\\n    public void prettyErrors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n\\n        sc.test(Bench.class).forEach(x -> {\\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\\n            System.out.println(x.go());\\n        });\\n    }\\n\\n\\n    //@Test\\n    //Extract the number of line of codes of tests\\n    public void testSloc() throws Exception {\\n        //Parse the legacy unit tests\\n        List<Integer> unitTests = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)){\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\\n            }\\n        }\\n\\n        //Parse the new unit tests\\n        List<Integer> safeTests = new ArrayList<>();\\n\\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\\n        }\\n\\n        String sb = \"testing;sloc\\\\n\" +\\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\")) +\\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\"));\\n        Path path = Paths.get(root, \"sloc.csv\");\\n        Files.write(path, sb.getBytes());\\n    }\\n\\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        FunctionVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            if (n.getNameAsString().equals(\"eval\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\\n\\n        UnitTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            System.out.println(n.getNameAsString());\\n            if (n.toString(noComments).contains(\"solve\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        SafeplaceTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            for (AnnotationExpr a : n.getAnnotations()) {\\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\\n                    return;\\n                }\\n            }\\n            System.out.println(n.getName());\\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            super.visit(n, arg);\\n        }\\n    }\\n}\\n'}",
            "error": "",
            "span_id": 4208881784440621228
        },
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n-\n-import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": "{'safeplace/src/test/java/org/btrplace/safeplace/DSN.java': '/*\\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\\n * Use of this source code is governed by a LGPL-style\\n * license that can be found in the LICENSE.txt file.\\n */\\n\\npackage org.btrplace.safeplace;\\n\\nimport com.github.javaparser.JavaParser;\\nimport com.github.javaparser.ParseResult;\\nimport com.github.javaparser.ast.CompilationUnit;\\nimport com.github.javaparser.ast.body.MethodDeclaration;\\nimport com.github.javaparser.ast.expr.AnnotationExpr;\\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\\nimport org.btrplace.safeplace.spec.Constraint;\\nimport org.btrplace.safeplace.spec.SpecScanner;\\nimport org.btrplace.safeplace.testing.Bench;\\nimport org.btrplace.safeplace.testing.Result;\\nimport org.btrplace.safeplace.testing.TestCampaign;\\nimport org.btrplace.safeplace.testing.TestScanner;\\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\\nimport org.btrplace.safeplace.testing.verification.Verifier;\\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\\nimport org.testng.Assert;\\n\\nimport java.io.InputStream;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.util.ArrayList;\\nimport java.util.EnumSet;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @author Fabien Hermenier\\n */\\npublic class DSN {\\n\\n    public static String root = \"xp-dsn\";\\n\\n    public TestScanner newScanner() throws Exception {\\n        SpecScanner specScanner = new SpecScanner();\\n        List<Constraint> l = specScanner.scan();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        return new TestScanner(l);\\n    }\\n\\n    ////@Test\\n    public void fuzzingSizing() throws Exception {\\n        TestScanner sc = newScanner();\\n        Path path = Paths.get(root,\"fuzz.csv\");\\n        Files.deleteIfExists(path);\\n\\n        for (int p = 100; p <= 1000; p+=100) {\\n            for (int s = 2; s <= 20; s+=2) {\\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\\n                Bench.report = new CSVReport(path, Integer.toString(p));\\n                Bench.population = p;\\n                Bench.scale = s;\\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\\n                if (campaigns.isEmpty()) {\\n                    Assert.fail(\"Nothing to test\");\\n                }\\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\\n            }\\n        }\\n    }\\n\\n    //@Test\\n    public void fuzzingScalability() throws Exception {\\n        TestScanner sc = newScanner();\\n\\n        //Warm-up\\n        Bench.transitions = true;\\n\\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n\\n     /*   for (int i = 10; i <= 30; i+=2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.report = new CSVReport(p,\"\");\\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\\n        }*/\\n\\n\\n        //GOGO\\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.mode = Bench.Mode.DEFAULT;\\n        for (int i = 1; i <= 30; i += 2) {\\n            Bench.transitions = false;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n\\n        p = Paths.get(root, \"testing-speed-trans.csv\");\\n        Files.deleteIfExists(p);\\n\\n        for (int i = 1; i <= 30; i+=2) {\\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\\n            Bench.transitions = true;\\n            Bench.population = 100;\\n            Bench.scale = i;\\n            Bench.report = new CSVReport(p, \"\");\\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\\n        }\\n    }\\n\\n    //@Test\\n    public void specLength() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\\\n\")));\\n\\n        Path path = Paths.get(root, \"inv.csv\");\\n        String out = l.stream()\\n                .map(c -> Integer.toString(c.proposition().toString().length()))\\n                .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n\\n        List<Integer> funcs = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\\n                .filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)) {\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\\n            }\\n        }\\n        path = Paths.get(root, \"func.csv\");\\n        out = funcs.stream()\\n                        .map(c -> Integer.toString(c))\\n                        .collect(Collectors.joining(\"\\\\n\"));\\n        Files.write(path, out.getBytes());\\n    }\\n\\n    //@Test\\n    public void funcFrequency() throws Exception {\\n        SpecScanner sc = new SpecScanner();\\n        List<Constraint> l = sc.scan();\\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\\\\\()+\");\\n        Map<String, Integer> map = new HashMap<>();\\n        for (Constraint c : l) {\\n            String prop = c.proposition().toString();\\n            Matcher m = p.matcher(prop);\\n            System.out.println(prop);\\n            int start = 0;\\n            while (m.find(start)) {\\n                String name = prop.substring(m.start(), m.end() - 1);\\n                if (Character.isLowerCase(name.charAt(0))) {\\n                    if (!map.containsKey(name)) {\\n                        map.put(name, 1);\\n                    } else {\\n                        map.put(name, map.get(name) + 1);\\n                    }\\n                }\\n                System.out.println(\"\\\\t\" + prop.substring(m.start(), m.end() - 1));\\n                start = m.end();\\n            }\\n        }\\n        System.out.println(map);\\n        Path out = Paths.get(root, \"func-freq.csv\");\\n        Files.deleteIfExists(out);\\n        String cnt = \"name;freq\\\\n\" +\\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\\\n\").collect(Collectors.joining());\\n        Files.write(out, cnt.getBytes());\\n\\n    }\\n\\n    //@Test\\n    public void specVsCheckers() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path p = Paths.get(root, \"verifier_stable.csv\");\\n        Files.deleteIfExists(p);\\n        boolean first = true;\\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\\n            Bench.report = new CSVReport(p, v.id());\\n            sc.test(Bench.class).forEach(c -> {\\n                c.verifyWith(v);\\n                System.out.println(c.go().toString());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void discreteVsContinuous() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"restriction_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, r.toString());\\n            sc.testGroups(\"bi\").forEach(x -> {\\n                Bench.restrictions = EnumSet.of(r);\\n                System.out.println(x.go());\\n            });\\n        }\\n        //restore\\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\\n    }\\n\\n    //@Test\\n    public void repairVsRebuild() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.population = 500;\\n        Bench.scale = 10;\\n        Path path = Paths.get(root, \"mode_stable.csv\");\\n        Files.deleteIfExists(path);\\n        boolean first = true;\\n        for (boolean repair : new boolean[]{false, true}) {\\n            if (first) {\\n                Bench.mode = Bench.Mode.SAVE;\\n                first = !first;\\n            } else {\\n                Bench.mode = Bench.Mode.REPLAY;\\n            }\\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\\n            sc.test(Bench.class).forEach(x -> {\\n                x.schedulerParams().doRepair(true);\\n                System.out.println(x.go());\\n            });\\n        }\\n    }\\n\\n    //@Test\\n    public void errors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.source = \"xp-dsn\";\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n        Path p = Paths.get(root, \"errors.csv\");\\n        Files.deleteIfExists(p);\\n        Bench.report = new CSVReport(p, \"\");\\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\\n    }\\n\\n    //@Test\\n    public void prettyErrors() throws Exception {\\n        TestScanner sc = newScanner();\\n        Bench.mode = Bench.Mode.REPLAY;\\n        Bench.population = 1000;\\n        Bench.scale = 5;\\n\\n        sc.test(Bench.class).forEach(x -> {\\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\\n            System.out.println(x.go());\\n        });\\n    }\\n\\n\\n    //@Test\\n    //Extract the number of line of codes of tests\\n    public void testSloc() throws Exception {\\n        //Parse the legacy unit tests\\n        List<Integer> unitTests = new ArrayList<>();\\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\\n        for (Path p : paths) {\\n            try (InputStream in = Files.newInputStream(p)){\\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\\n            }\\n        }\\n\\n        //Parse the new unit tests\\n        List<Integer> safeTests = new ArrayList<>();\\n\\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\\n        }\\n\\n        String sb = \"testing;sloc\\\\n\" +\\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\")) +\\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\\\n\", \"\", \"\\\\n\"));\\n        Path path = Paths.get(root, \"sloc.csv\");\\n        Files.write(path, sb.getBytes());\\n    }\\n\\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        FunctionVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            if (n.getNameAsString().equals(\"eval\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\\n\\n        UnitTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            System.out.println(n.getNameAsString());\\n            if (n.toString(noComments).contains(\"solve\")) {\\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            }\\n            super.visit(n, arg);\\n        }\\n    }\\n\\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\\n\\n      private final List<Integer> l;\\n\\n        SafeplaceTestsVisitor(List<Integer> numbers) {\\n            this.l = numbers;\\n        }\\n\\n        @Override\\n        public void visit(MethodDeclaration n, Void arg) {\\n            for (AnnotationExpr a : n.getAnnotations()) {\\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\\n                    return;\\n                }\\n            }\\n            System.out.println(n.getName());\\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\\n            super.visit(n, arg);\\n        }\\n    }\\n}\\n'}",
            "error": "",
            "span_id": 11931805023960997613
        }
    ],
    "compile_maven": [
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+\n+import com.github.javaparser.printer.configuration.DefaultPrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final DefaultPrettyPrinterConfiguration noComments = new DefaultPrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\n\nimport com.github.javaparser.printer.configuration.DefaultPrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final DefaultPrettyPrinterConfiguration noComments = new DefaultPrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n"
                },
                "compile_error_details": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": {
                        "15": {
                            "lines": [
                                {
                                    "line_no": 14,
                                    "content": "import com.github.javaparser.ast.visitor.VoidVisitorAdapter;"
                                },
                                {
                                    "line_no": 15,
                                    "content": "import com.github.javaparser.printer.PrettyPrinterConfiguration;"
                                },
                                {
                                    "line_no": 16,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[15,37] cannot find symbol\nsymbol: class PrettyPrinterConfiguration\nlocation: package com.github.javaparser.printer\n",
                                "[15,37] cannot find symbol\n"
                            ]
                        },
                        "17": {
                            "lines": [
                                {
                                    "line_no": 16,
                                    "content": ""
                                },
                                {
                                    "line_no": 17,
                                    "content": "import com.github.javaparser.printer.configuration.DefaultPrettyPrinterConfiguration;"
                                },
                                {
                                    "line_no": 18,
                                    "content": "import org.btrplace.safeplace.spec.Constraint;"
                                }
                            ],
                            "error_texts": [
                                "[17,51] cannot find symbol\n",
                                "[17,51] cannot find symbol\nsymbol: class DefaultPrettyPrinterConfiguration\nlocation: package com.github.javaparser.printer.configuration\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": ""
                                },
                                {
                                    "line_no": 337,
                                    "content": "      private final DefaultPrettyPrinterConfiguration noComments = new DefaultPrettyPrinterConfiguration().setPrintComments(false);"
                                },
                                {
                                    "line_no": 338,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[337,21] cannot find symbol\nsymbol: class DefaultPrettyPrinterConfiguration\nlocation: class org.btrplace.safeplace.DSN.UnitTestsVisitor\n",
                                "[337,21] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 4410390374418386305
        },
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+\n+import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\n\nimport com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n"
                },
                "compile_error_details": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": {
                        "15": {
                            "lines": [
                                {
                                    "line_no": 14,
                                    "content": "import com.github.javaparser.ast.visitor.VoidVisitorAdapter;"
                                },
                                {
                                    "line_no": 15,
                                    "content": "import com.github.javaparser.printer.PrettyPrinterConfiguration;"
                                },
                                {
                                    "line_no": 16,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[15,37] cannot find symbol\nsymbol: class PrettyPrinterConfiguration\nlocation: package com.github.javaparser.printer\n",
                                "[15,37] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 17853636544773760619
        },
        {
            "input": "```diff\nsafeplace/src/test/java/org/btrplace/safeplace/DSN.java\n@@\n import com.github.javaparser.printer.PrettyPrinterConfiguration;\n-\n-import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\n@@\n private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n-      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n+      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n"
                },
                "compile_error_details": {
                    "safeplace/src/test/java/org/btrplace/safeplace/DSN.java": {
                        "15": {
                            "lines": [
                                {
                                    "line_no": 14,
                                    "content": "import com.github.javaparser.ast.visitor.VoidVisitorAdapter;"
                                },
                                {
                                    "line_no": 15,
                                    "content": "import com.github.javaparser.printer.PrettyPrinterConfiguration;"
                                },
                                {
                                    "line_no": 16,
                                    "content": "import org.btrplace.safeplace.spec.Constraint;"
                                }
                            ],
                            "error_texts": [
                                "[15,37] cannot find symbol\nsymbol: class PrettyPrinterConfiguration\nlocation: package com.github.javaparser.printer\n",
                                "[15,37] cannot find symbol\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": ""
                                },
                                {
                                    "line_no": 335,
                                    "content": "      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);"
                                },
                                {
                                    "line_no": 336,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[335,21] cannot find symbol\n",
                                "[335,21] cannot find symbol\nsymbol: class PrettyPrinterConfiguration\nlocation: class org.btrplace.safeplace.DSN.UnitTestsVisitor\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 4704323550048216672
        }
    ],
    "read_file": [
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace/DSN.java",
            "output": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n",
            "error": "",
            "span_id": 12377279814200674916
        },
        {
            "input": "safeplace/pom.xml",
            "output": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n  ~ Copyright  2020 The BtrPlace Authors. All rights reserved.\n  ~ Use of this source code is governed by a LGPL-style\n  ~ license that can be found in the LICENSE.txt file.\n  -->\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <name>safeplace</name>\n    <artifactId>safeplace</artifactId>\n\n    <parent>\n        <groupId>org.btrplace</groupId>\n        <artifactId>scheduler</artifactId>\n        <version>1.12.1-SNAPSHOT</version>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>io.github.lukehutch</groupId>\n            <artifactId>fast-classpath-scanner</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.antlr</groupId>\n            <artifactId>antlr4-maven-plugin</artifactId>\n            <version>4.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.antlr</groupId>\n            <artifactId>antlr4-runtime</artifactId>\n            <version>4.9.3</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.btrplace</groupId>\n            <artifactId>scheduler-api</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.btrplace</groupId>\n            <artifactId>scheduler-json</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.btrplace</groupId>\n            <artifactId>scheduler-choco</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.testng</groupId>\n            <artifactId>testng</artifactId>\n            <version>${testng.version}</version>\n            <type>jar</type>\n            <optional>false</optional>\n        </dependency>\n        <dependency>\n            <groupId>com.github.javaparser</groupId>\n            <artifactId>javaparser-core</artifactId>\n            <version>3.24.0</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.antlr</groupId>\n                <artifactId>antlr4-maven-plugin</artifactId>\n                <version>4.9.3</version>\n                <configuration>\n                    <sourceDirectory>src/main/antlr</sourceDirectory>\n                    <visitor>true</visitor>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>antlr4</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Automatic-Module-Name>org.btrplace.scheduler.safeplace</Automatic-Module-Name>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n",
            "error": "",
            "span_id": 8667832317911091635
        },
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java",
            "output": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace.testing;\n\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.fuzzer.decorators.ShareableResourceFuzzer;\nimport org.testng.Assert;\n\nimport java.util.EnumSet;\nimport java.util.List;\n\n/**\n * @author Fabien Hermenier\n */\npublic class TestSafePlace {\n\n  //Core constraints\n  @CstrTest(groups = {\"core_\"})\n  public void testNoVmsOnOfflineNodes(TestCampaign c) {\n    c.check(\"noVMsOnOfflineNodes\")\n            .vms(1)\n            .nodes(1)\n            .srcOffNodes(0.1)\n            .srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"core_\", \"toRunning\"})\n  public void testToRunning(TestCampaign c) {\n    c.check(\"toRunning\").vms(1).nodes(1).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"core_\"})\n  public void testToSleeping(TestCampaign c) {\n    c.check(\"toSleeping\").vms(1).nodes(1).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"core_\"})\n  public void testToReady(TestCampaign c) {\n    c.check(\"toReady\").vms(1).nodes(1).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n\n  @CstrTest(groups = {\"spread\"})\n  public void testSpread(TestCampaign c) {\n    c.check(\"spread\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testLonely(TestCampaign c) {\n    c.check(\"lonely\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"gather\"})\n  public void testGather(TestCampaign c) {\n    c.check(\"gather\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"ban\"})\n  public void testBan(TestCampaign c) {\n    c.check(\"ban\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"fence\",})\n  public void testFence(TestCampaign c) {\n    c.check(\"fence\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"among\"})\n  public void testAmong(TestCampaign c) {\n    c.check(\"among\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testRoot(TestCampaign c) {\n    c.check(\"root\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n    c.limits().tests(100).failures(1);\n    //c.onDefect(DefectHooks.testNgFailure);\n  }\n\n  @CstrTest()\n  public void testSplit(TestCampaign c) {\n    c.check(\"split\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testQuarantine(TestCampaign c) {\n    c.check(\"quarantine\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"maxOnline\"})\n  public void testMaxOnline(TestCampaign c) {\n    c.check(\"maxOnline\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0)\n            .with(\"nb\", 0, 5);\n  }\n\n  @CstrTest(groups = {\"runningCapacity\"})\n  public void testRunningCapacity(TestCampaign c) {\n    c.check(\"runningCapacity\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0)\n            .with(\"nb\", 0, 12);\n  }\n\n  @CstrTest()\n  public void testRunning(TestCampaign c) {\n    c.check(\"running\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testSleeping(TestCampaign c) {\n    c.check(\"sleeping\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testReady(TestCampaign c) {\n    c.check(\"ready\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testOnline(TestCampaign c) {\n    c.check(\"online\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest()\n  public void testOffline(TestCampaign c) {\n    c.check(\"offline\").vms(10).nodes(3).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n\n  @CstrTest(groups = {})\n  public void testResource(TestCampaign c) {\n    c.check(\"shareableResource\")\n            .with(\"id\", \"cpu\")\n            .with(new ShareableResourceFuzzer(\"cpu\", 1, 5, 10, 20).variability(0.5))\n            .vms(5).nodes(1).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  @CstrTest(groups = {\"_resourceCapacity\"})\n  public void testResourceCapacity(TestCampaign c) {\n    c.check(\"resourceCapacity\")\n            .restriction(EnumSet.of(Restriction.CONTINUOUS, Restriction.DISCRETE))\n            .with(\"id\", \"cpu\")\n            .with(\"qty\", 1, 50)\n            .with(new ShareableResourceFuzzer(\"cpu\", 1, 5, 10, 20).variability(0.5))\n            .vms(5).nodes(2).srcOffNodes(0.1).srcVMs(1, 9, 0);\n  }\n\n  //@Test\n  public void launcher() throws Exception {\n    SpecScanner specScanner = new SpecScanner();\n    List<Constraint> l = specScanner.scan();\n    TestScanner sc = new TestScanner(l);\n    List<TestCampaign> campaigns = sc.test(TestSafePlace.class);\n    //List<TestCampaign> campaigns = sc.testGroups(\"_resourceCapacity\");\n    if (campaigns.isEmpty()) {\n      Assert.fail(\"Nothing to test\");\n    }\n\n    campaigns.forEach(tc -> {\n      tc.schedulerParams().doRepair(false);//.setVerbosity(1);\n      tc.onDefect(DefectHooks.ignore);\n      tc.limits().clear().tests(1000);\n      System.out.println(tc.go());\n    });\n  }\n}\n",
            "error": "",
            "span_id": 302503533028710288
        },
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace/DSN.java",
            "output": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\n\nimport com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n",
            "error": "",
            "span_id": 8469628398897790968
        },
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace/DSN.java",
            "output": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\n\nimport com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n",
            "error": "",
            "span_id": 6844411707502633699
        },
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace/DSN.java",
            "output": "/*\n * Copyright  2020 The BtrPlace Authors. All rights reserved.\n * Use of this source code is governed by a LGPL-style\n * license that can be found in the LICENSE.txt file.\n */\n\npackage org.btrplace.safeplace;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration;\nimport org.btrplace.safeplace.spec.Constraint;\nimport org.btrplace.safeplace.spec.SpecScanner;\nimport org.btrplace.safeplace.testing.Bench;\nimport org.btrplace.safeplace.testing.Result;\nimport org.btrplace.safeplace.testing.TestCampaign;\nimport org.btrplace.safeplace.testing.TestScanner;\nimport org.btrplace.safeplace.testing.fuzzer.Restriction;\nimport org.btrplace.safeplace.testing.reporting.CSVReport;\nimport org.btrplace.safeplace.testing.reporting.StoredReport;\nimport org.btrplace.safeplace.testing.verification.Verifier;\nimport org.btrplace.safeplace.testing.verification.btrplace.CheckerVerifier;\nimport org.btrplace.safeplace.testing.verification.spec.SpecVerifier;\nimport org.testng.Assert;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * @author Fabien Hermenier\n */\npublic class DSN {\n\n    public static String root = \"xp-dsn\";\n\n    public TestScanner newScanner() throws Exception {\n        SpecScanner specScanner = new SpecScanner();\n        List<Constraint> l = specScanner.scan();\n        Bench.mode = Bench.Mode.REPLAY;\n        return new TestScanner(l);\n    }\n\n    ////@Test\n    public void fuzzingSizing() throws Exception {\n        TestScanner sc = newScanner();\n        Path path = Paths.get(root,\"fuzz.csv\");\n        Files.deleteIfExists(path);\n\n        for (int p = 100; p <= 1000; p+=100) {\n            for (int s = 2; s <= 20; s+=2) {\n                System.out.println(\"--- Population: \" + p + \" scale: \" + s + \" ---\");\n                Bench.report = new CSVReport(path, Integer.toString(p));\n                Bench.population = p;\n                Bench.scale = s;\n                List<TestCampaign> campaigns = sc.testGroups(\"sides\");\n                if (campaigns.isEmpty()) {\n                    Assert.fail(\"Nothing to test\");\n                }\n                campaigns.stream().forEach(c -> System.out.println(c.go().toString()));\n            }\n        }\n    }\n\n    //@Test\n    public void fuzzingScalability() throws Exception {\n        TestScanner sc = newScanner();\n\n        //Warm-up\n        Bench.transitions = true;\n\n        Path p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n\n     /*   for (int i = 10; i <= 30; i+=2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.report = new CSVReport(p,\"\");\n            System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());\n        }*/\n\n\n        //GOGO\n        p = Paths.get(root, \"testing-speed-notrans.csv\");\n        Files.deleteIfExists(p);\n        Bench.mode = Bench.Mode.DEFAULT;\n        for (int i = 1; i <= 30; i += 2) {\n            Bench.transitions = false;\n            Bench.population = 100;\n            Bench.scale = i;\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions + \" ---\");\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n\n        p = Paths.get(root, \"testing-speed-trans.csv\");\n        Files.deleteIfExists(p);\n\n        for (int i = 1; i <= 30; i+=2) {\n            System.out.println(\"--- scaling factor \" + i + \"; transitions= \" + Bench.transitions +\" ---\");\n            Bench.transitions = true;\n            Bench.population = 100;\n            Bench.scale = i;\n            Bench.report = new CSVReport(p, \"\");\n            sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));\n        }\n    }\n\n    //@Test\n    public void specLength() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining(\"\\n\")));\n\n        Path path = Paths.get(root, \"inv.csv\");\n        String out = l.stream()\n                .map(c -> Integer.toString(c.proposition().toString().length()))\n                .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n\n        List<Integer> funcs = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"safeplace/src/main/java/org/btrplace/safeplace/spec/term/func\"))\n                .filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)) {\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new FunctionVisitor(funcs).visit(cu.getResult().get(), null);\n            }\n        }\n        path = Paths.get(root, \"func.csv\");\n        out = funcs.stream()\n                        .map(c -> Integer.toString(c))\n                        .collect(Collectors.joining(\"\\n\"));\n        Files.write(path, out.getBytes());\n    }\n\n    //@Test\n    public void funcFrequency() throws Exception {\n        SpecScanner sc = new SpecScanner();\n        List<Constraint> l = sc.scan();\n        Pattern p = Pattern.compile(\"([a-zA-Z]+\\\\()+\");\n        Map<String, Integer> map = new HashMap<>();\n        for (Constraint c : l) {\n            String prop = c.proposition().toString();\n            Matcher m = p.matcher(prop);\n            System.out.println(prop);\n            int start = 0;\n            while (m.find(start)) {\n                String name = prop.substring(m.start(), m.end() - 1);\n                if (Character.isLowerCase(name.charAt(0))) {\n                    if (!map.containsKey(name)) {\n                        map.put(name, 1);\n                    } else {\n                        map.put(name, map.get(name) + 1);\n                    }\n                }\n                System.out.println(\"\\t\" + prop.substring(m.start(), m.end() - 1));\n                start = m.end();\n            }\n        }\n        System.out.println(map);\n        Path out = Paths.get(root, \"func-freq.csv\");\n        Files.deleteIfExists(out);\n        String cnt = \"name;freq\\n\" +\n                    map.entrySet().stream().map(e -> e.getKey()+\";\" + e.getValue() + \"\\n\").collect(Collectors.joining());\n        Files.write(out, cnt.getBytes());\n\n    }\n\n    //@Test\n    public void specVsCheckers() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path p = Paths.get(root, \"verifier_stable.csv\");\n        Files.deleteIfExists(p);\n        boolean first = true;\n        for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Verifier: \" + v.getClass() + \" ---\");\n            Bench.report = new CSVReport(p, v.id());\n            sc.test(Bench.class).forEach(c -> {\n                c.verifyWith(v);\n                System.out.println(c.go().toString());\n            });\n        }\n    }\n\n    //@Test\n    public void discreteVsContinuous() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"restriction_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (Restriction r : EnumSet.allOf(Restriction.class)) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Restriction: \" + r + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, r.toString());\n            sc.testGroups(\"bi\").forEach(x -> {\n                Bench.restrictions = EnumSet.of(r);\n                System.out.println(x.go());\n            });\n        }\n        //restore\n        Bench.restrictions = EnumSet.allOf(Restriction.class);\n    }\n\n    //@Test\n    public void repairVsRebuild() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.population = 500;\n        Bench.scale = 10;\n        Path path = Paths.get(root, \"mode_stable.csv\");\n        Files.deleteIfExists(path);\n        boolean first = true;\n        for (boolean repair : new boolean[]{false, true}) {\n            if (first) {\n                Bench.mode = Bench.Mode.SAVE;\n                first = !first;\n            } else {\n                Bench.mode = Bench.Mode.REPLAY;\n            }\n            System.out.println(\"--- Repair: \" + repair + \"; replay= \" + first + \" ---\");\n            Bench.report = new CSVReport(path, repair ? \"enabled\" : \"disabled\");\n            sc.test(Bench.class).forEach(x -> {\n                x.schedulerParams().doRepair(true);\n                System.out.println(x.go());\n            });\n        }\n    }\n\n    //@Test\n    public void errors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.source = \"xp-dsn\";\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n        Path p = Paths.get(root, \"errors.csv\");\n        Files.deleteIfExists(p);\n        Bench.report = new CSVReport(p, \"\");\n        sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));\n    }\n\n    //@Test\n    public void prettyErrors() throws Exception {\n        TestScanner sc = newScanner();\n        Bench.mode = Bench.Mode.REPLAY;\n        Bench.population = 1000;\n        Bench.scale = 5;\n\n        sc.test(Bench.class).forEach(x -> {\n            x.reportTo(new StoredReport(Paths.get(\"xp-dsn\", \"errors.txt\"), r -> !r.result().equals(Result.SUCCESS)));\n            System.out.println(x.go());\n        });\n    }\n\n\n    //@Test\n    //Extract the number of line of codes of tests\n    public void testSloc() throws Exception {\n        //Parse the legacy unit tests\n        List<Integer> unitTests = new ArrayList<>();\n        List<Path> paths = Files.list(Paths.get(\"choco/src/test/java/org/btrplace/scheduler/choco/constraint/\")).filter(Files::isRegularFile).collect(Collectors.toList());\n        for (Path p : paths) {\n            try (InputStream in = Files.newInputStream(p)){\n                ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n                new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);\n            }\n        }\n\n        //Parse the new unit tests\n        List<Integer> safeTests = new ArrayList<>();\n\n        try (InputStream in = Files.newInputStream(Paths.get(\"safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java\"))){\n            ParseResult<CompilationUnit> cu = new JavaParser().parse(in);\n            new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);\n        }\n\n        String sb = \"testing;sloc\\n\" +\n                unitTests.stream().map(i -> \"btrPlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\")) +\n                safeTests.stream().map(i -> \"safePlace;\" + i).collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n        Path path = Paths.get(root, \"sloc.csv\");\n        Files.write(path, sb.getBytes());\n    }\n\n    private static class FunctionVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        FunctionVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            if (n.getNameAsString().equals(\"eval\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class UnitTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n      private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);\n\n        UnitTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            System.out.println(n.getNameAsString());\n            if (n.toString(noComments).contains(\"solve\")) {\n                n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            }\n            super.visit(n, arg);\n        }\n    }\n\n    private static class SafeplaceTestsVisitor extends VoidVisitorAdapter<Void> {\n\n      private final List<Integer> l;\n\n        SafeplaceTestsVisitor(List<Integer> numbers) {\n            this.l = numbers;\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            for (AnnotationExpr a : n.getAnnotations()) {\n                if (!a.getNameAsString().equals(\"CstrTest\")) {\n                    return;\n                }\n            }\n            System.out.println(n.getName());\n            n.getRange().ifPresent(r -> l.add(r.end.line - r.begin.line));\n            super.visit(n, arg);\n        }\n    }\n}\n",
            "error": "",
            "span_id": 15166898611545883523
        }
    ],
    "get_directory_tree": [
        {
            "input": "safeplace/src/test/java/org/btrplace/safeplace",
            "output": "[\n    {\n        \"name\": \"DSN.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"testing\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"TestScannerTest.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"limit\",\n                \"type\": \"directory\",\n                \"contents\": [\n                    {\n                        \"name\": \"MaxDefectsTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"MaxTestsTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"LimitsTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"MaxSuccessTest.java\",\n                        \"type\": \"file\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"Bench.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TestSafePlace.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"util\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"AllTuplesGeneratorTest.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"spec\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"prop\",\n                \"type\": \"directory\",\n                \"contents\": [\n                    {\n                        \"name\": \"IffTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"PropositionTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"OrTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"ImpliesTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"MinusTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"PlusTest.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"AndTest.java\",\n                        \"type\": \"file\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"type\",\n                \"type\": \"directory\",\n                \"contents\": [\n                    {\n                        \"name\": \"SetTypeTest.java\",\n                        \"type\": \"file\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"SpecScannerTest.java\",\n                \"type\": \"file\"\n            }\n        ]\n    }\n]",
            "error": "",
            "span_id": 7589599439434588222
        }
    ],
    "get_language_server_suggestions": [],
    "reset_repo": [
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 1976555872174225637
        },
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 9867921993185787103
        }
    ]
}