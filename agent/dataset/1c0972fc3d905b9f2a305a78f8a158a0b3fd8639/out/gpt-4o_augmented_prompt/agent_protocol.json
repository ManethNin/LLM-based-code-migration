{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -22,1 +22,0 @@\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -178,1 +177,1 @@\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot access org.apache.maven.plugin.AbstractMojo\n",
                "updated_files": {
                    "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java": "/*\n * Copyright (C) 2008-2022 Mycila (mathieu.carbou@gmail.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.mycila.maven.plugin.license.dependencies;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.CumulativeScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.License;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.DefaultProjectBuilder;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Helper class for building Artifact/License mappings from a maven project\n * (multi module or single).\n *\n * @author Royce Remer\n */\npublic class MavenProjectLicenses implements LicenseMap, LicenseMessage {\n\n  private Set<MavenProject> projects;\n  private DependencyGraphBuilder graph;\n  private ProjectBuilder projectBuilder;\n  private ProjectBuildingRequest buildingRequest;\n  private ArtifactFilter filter;\n  private Log log;\n\n  /**\n   * @param projects       the Set of {@link MavenProject} to scan\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   * @param log            the log to sync to\n   */\n  public MavenProjectLicenses(final Set<MavenProject> projects, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final ProjectBuildingRequest buildingRequest,\n                              final ArtifactFilter filter, final Log log) {\n    this.setProjects(projects);\n    this.setBuildingRequest(buildingRequest);\n    this.setGraph(graph);\n    this.setFilter(filter);\n    this.setProjectBuilder(projectBuilder);\n    this.setLog(log);\n\n    log.info(String.format(\"%s %s\", INFO_LICENSE_IMPL, this.getClass()));\n  }\n\n  /**\n   * @param session        the current {@link MavenSession}\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   */\n  public MavenProjectLicenses(final MavenSession session, MavenProject project, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final List<String> scopes, final Log log) {\n    this(Collections.singleton(project), graph, projectBuilder, getBuildingRequestWithDefaults(session),\n        new CumulativeScopeArtifactFilter(scopes), log);\n  }\n\n  private static ProjectBuildingRequest getBuildingRequestWithDefaults(final MavenSession session) {\n    ProjectBuildingRequest request;\n    if (session == null) {\n      request = new DefaultProjectBuildingRequest();\n    } else {\n      request = session.getProjectBuildingRequest();\n    }\n    return request;\n  }\n\n  /**\n   * Return a set of licenses attributed to a single artifact.\n   */\n  protected Set<License> getLicensesFromArtifact(final Artifact artifact) {\n    Set<License> licenses = new HashSet<>();\n    try {\n      MavenProject project = getProjectBuilder().build(artifact, getBuildingRequest()).getProject();\n      licenses.addAll(project.getLicenses());\n    } catch (ProjectBuildingException ex) {\n      getLog().warn(String.format(\"Could not get project from dependency's artifact: %s\", artifact.getFile()));\n    }\n\n    return licenses;\n  }\n\n  /**\n   * Get mapping of Licenses to a set of artifacts presenting that license.\n   *\n   * @param dependencies Set to collate License entries from\n   * @return the same artifacts passed in, keyed by license\n   */\n  protected Map<License, Set<Artifact>> getLicenseMapFromArtifacts(final Set<Artifact> dependencies) {\n    final ConcurrentMap<License, Set<Artifact>> map = new ConcurrentHashMap<>();\n\n    // license:artifact is a many-to-many relationship.\n    // Each artifact may have several licenses.\n    // Each artifact may appear multiple times in the map.\n    dependencies.parallelStream().forEach(artifact -> getLicensesFromArtifact(artifact).forEach(license -> {\n      map.putIfAbsent(license, new HashSet<>());\n      Set<Artifact> artifacts = map.get(license);\n      artifacts.add(artifact);\n      map.put(license, artifacts);\n    }));\n\n    return map;\n  }\n\n  @Override\n  public Map<License, Set<Artifact>> getLicenseMap() {\n    return getLicenseMapFromArtifacts(getDependencies());\n  }\n\n  /**\n   * Return the Set of all direct and transitive Artifact dependencies.\n   */\n  private Set<Artifact> getDependencies() {\n    final Set<Artifact> artifacts = new HashSet<>();\n    final Set<DependencyNode> dependencies = new HashSet<>();\n\n    // build the set of maven dependencies for each module in the reactor (might\n    // only be the single one) and all its transitives\n    getLog().debug(String.format(\"Building dependency graphs for %d projects\", getProjects().size()));\n    getProjects().parallelStream().forEach(project -> {\n      try {\n        dependencies.addAll(getGraph().buildDependencyGraph(buildingRequest, getFilter()).getChildren());\n      } catch (DependencyGraphBuilderException ex) {\n        getLog().warn(\n            String.format(\"Could not get children from project %s, it's dependencies will not be checked!\",\n                project.getId()));\n      }\n    });\n\n    // build the complete set of direct+transitive dependent artifacts in all\n    // modules in the reactor\n    dependencies.parallelStream().forEach(d -> artifacts.add(d.getArtifact()));\n    getLog().info(String.format(\"%s: %d\", INFO_DEPS_DISCOVERED, dependencies.size()));\n\n    return artifacts;\n\n    // tempting, but does not resolve dependencies after the scope in which this\n    // plugin is invoked\n    // return project.getArtifacts();\n  }\n\n  protected Set<MavenProject> getProjects() {\n    return projects;\n  }\n\n  protected void setProjects(final Set<MavenProject> projects) {\n    this.projects = Optional.ofNullable(projects).orElse(new HashSet<>());\n  }\n\n  private DependencyGraphBuilder getGraph() {\n    return graph;\n  }\n\n  private void setGraph(DependencyGraphBuilder graph) {\n    this.graph = graph;\n  }\n\n  private ProjectBuilder getProjectBuilder() {\n    return projectBuilder;\n  }\n\n  private void setProjectBuilder(ProjectBuilder projectBuilder) {\n    this.projectBuilder = Optional.ofNullable(projectBuilder).orElse(new DefaultProjectBuilder());\n  }\n\n  private ArtifactFilter getFilter() {\n    return filter;\n  }\n\n  private void setFilter(ArtifactFilter filter) {\n    this.filter = filter;\n  }\n\n  private Log getLog() {\n    return log;\n  }\n\n  private void setLog(Log log) {\n    this.log = log;\n  }\n\n  private ProjectBuildingRequest getBuildingRequest() {\n    return buildingRequest;\n  }\n\n  protected void setBuildingRequest(final ProjectBuildingRequest buildingRequest) {\n    this.buildingRequest = Optional.ofNullable(buildingRequest).orElse(new DefaultProjectBuildingRequest());\n  }\n}\n"
                },
                "compile_error_details": {
                    "license-maven-plugin-git/src/main/java/com/mycila/maven/plugin/license/git/CopyrightAuthorProvider.java": {
                        "48": {
                            "lines": [
                                {
                                    "line_no": 47,
                                    "content": "    if (mojo.warnIfShallow && gitLookup.isShallowRepository()) {"
                                },
                                {
                                    "line_no": 48,
                                    "content": "      mojo.warn(\"Shallow git repository detected. Author property values may not be accurate.\");"
                                },
                                {
                                    "line_no": 49,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[48,11] cannot access org.apache.maven.plugin.AbstractMojo\n",
                                "[48,11] cannot access org.apache.maven.plugin.AbstractMojo\nclass file for org.apache.maven.plugin.AbstractMojo not found\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot access org.apache.maven.plugin.AbstractMojo\n",
            "span_id": 2488338377837323739
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -22,1 +22,0 @@\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -178,1 +177,1 @@\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n```",
            "span_id": 1836594668580650279
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -21,2 +21,1 @@\n import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -176,3 +175,3 @@\n   private void setGraph(DependencyGraphBuilder graph) {\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
            "span_id": 1791193376760650257
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -20,2 +20,1 @@\n import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -175,3 +174,3 @@\n   private void setGraph(DependencyGraphBuilder graph) {\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
            "span_id": 10316771626063895721
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -19,2 +19,1 @@\n import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -174,3 +173,3 @@\n   private void setGraph(DependencyGraphBuilder graph) {\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 3 exact lines in a row:\n```\nprivate void setGraph(DependencyGraphBuilder graph) {\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n}\n```",
            "span_id": 12844580636141079308
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -21,2 +21,1 @@\n import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -178,1 +177,1 @@\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot access org.apache.maven.plugin.AbstractMojo\n",
                "updated_files": {
                    "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java": "/*\n * Copyright (C) 2008-2022 Mycila (mathieu.carbou@gmail.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.mycila.maven.plugin.license.dependencies;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.CumulativeScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.License;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.DefaultProjectBuilder;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Helper class for building Artifact/License mappings from a maven project\n * (multi module or single).\n *\n * @author Royce Remer\n */\npublic class MavenProjectLicenses implements LicenseMap, LicenseMessage {\n\n  private Set<MavenProject> projects;\n  private DependencyGraphBuilder graph;\n  private ProjectBuilder projectBuilder;\n  private ProjectBuildingRequest buildingRequest;\n  private ArtifactFilter filter;\n  private Log log;\n\n  /**\n   * @param projects       the Set of {@link MavenProject} to scan\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   * @param log            the log to sync to\n   */\n  public MavenProjectLicenses(final Set<MavenProject> projects, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final ProjectBuildingRequest buildingRequest,\n                              final ArtifactFilter filter, final Log log) {\n    this.setProjects(projects);\n    this.setBuildingRequest(buildingRequest);\n    this.setGraph(graph);\n    this.setFilter(filter);\n    this.setProjectBuilder(projectBuilder);\n    this.setLog(log);\n\n    log.info(String.format(\"%s %s\", INFO_LICENSE_IMPL, this.getClass()));\n  }\n\n  /**\n   * @param session        the current {@link MavenSession}\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   */\n  public MavenProjectLicenses(final MavenSession session, MavenProject project, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final List<String> scopes, final Log log) {\n    this(Collections.singleton(project), graph, projectBuilder, getBuildingRequestWithDefaults(session),\n        new CumulativeScopeArtifactFilter(scopes), log);\n  }\n\n  private static ProjectBuildingRequest getBuildingRequestWithDefaults(final MavenSession session) {\n    ProjectBuildingRequest request;\n    if (session == null) {\n      request = new DefaultProjectBuildingRequest();\n    } else {\n      request = session.getProjectBuildingRequest();\n    }\n    return request;\n  }\n\n  /**\n   * Return a set of licenses attributed to a single artifact.\n   */\n  protected Set<License> getLicensesFromArtifact(final Artifact artifact) {\n    Set<License> licenses = new HashSet<>();\n    try {\n      MavenProject project = getProjectBuilder().build(artifact, getBuildingRequest()).getProject();\n      licenses.addAll(project.getLicenses());\n    } catch (ProjectBuildingException ex) {\n      getLog().warn(String.format(\"Could not get project from dependency's artifact: %s\", artifact.getFile()));\n    }\n\n    return licenses;\n  }\n\n  /**\n   * Get mapping of Licenses to a set of artifacts presenting that license.\n   *\n   * @param dependencies Set to collate License entries from\n   * @return the same artifacts passed in, keyed by license\n   */\n  protected Map<License, Set<Artifact>> getLicenseMapFromArtifacts(final Set<Artifact> dependencies) {\n    final ConcurrentMap<License, Set<Artifact>> map = new ConcurrentHashMap<>();\n\n    // license:artifact is a many-to-many relationship.\n    // Each artifact may have several licenses.\n    // Each artifact may appear multiple times in the map.\n    dependencies.parallelStream().forEach(artifact -> getLicensesFromArtifact(artifact).forEach(license -> {\n      map.putIfAbsent(license, new HashSet<>());\n      Set<Artifact> artifacts = map.get(license);\n      artifacts.add(artifact);\n      map.put(license, artifacts);\n    }));\n\n    return map;\n  }\n\n  @Override\n  public Map<License, Set<Artifact>> getLicenseMap() {\n    return getLicenseMapFromArtifacts(getDependencies());\n  }\n\n  /**\n   * Return the Set of all direct and transitive Artifact dependencies.\n   */\n  private Set<Artifact> getDependencies() {\n    final Set<Artifact> artifacts = new HashSet<>();\n    final Set<DependencyNode> dependencies = new HashSet<>();\n\n    // build the set of maven dependencies for each module in the reactor (might\n    // only be the single one) and all its transitives\n    getLog().debug(String.format(\"Building dependency graphs for %d projects\", getProjects().size()));\n    getProjects().parallelStream().forEach(project -> {\n      try {\n        dependencies.addAll(getGraph().buildDependencyGraph(buildingRequest, getFilter()).getChildren());\n      } catch (DependencyGraphBuilderException ex) {\n        getLog().warn(\n            String.format(\"Could not get children from project %s, it's dependencies will not be checked!\",\n                project.getId()));\n      }\n    });\n\n    // build the complete set of direct+transitive dependent artifacts in all\n    // modules in the reactor\n    dependencies.parallelStream().forEach(d -> artifacts.add(d.getArtifact()));\n    getLog().info(String.format(\"%s: %d\", INFO_DEPS_DISCOVERED, dependencies.size()));\n\n    return artifacts;\n\n    // tempting, but does not resolve dependencies after the scope in which this\n    // plugin is invoked\n    // return project.getArtifacts();\n  }\n\n  protected Set<MavenProject> getProjects() {\n    return projects;\n  }\n\n  protected void setProjects(final Set<MavenProject> projects) {\n    this.projects = Optional.ofNullable(projects).orElse(new HashSet<>());\n  }\n\n  private DependencyGraphBuilder getGraph() {\n    return graph;\n  }\n\n  private void setGraph(DependencyGraphBuilder graph) {\n    this.graph = graph;\n  }\n\n  private ProjectBuilder getProjectBuilder() {\n    return projectBuilder;\n  }\n\n  private void setProjectBuilder(ProjectBuilder projectBuilder) {\n    this.projectBuilder = Optional.ofNullable(projectBuilder).orElse(new DefaultProjectBuilder());\n  }\n\n  private ArtifactFilter getFilter() {\n    return filter;\n  }\n\n  private void setFilter(ArtifactFilter filter) {\n    this.filter = filter;\n  }\n\n  private Log getLog() {\n    return log;\n  }\n\n  private void setLog(Log log) {\n    this.log = log;\n  }\n\n  private ProjectBuildingRequest getBuildingRequest() {\n    return buildingRequest;\n  }\n\n  protected void setBuildingRequest(final ProjectBuildingRequest buildingRequest) {\n    this.buildingRequest = Optional.ofNullable(buildingRequest).orElse(new DefaultProjectBuildingRequest());\n  }\n}\n"
                },
                "compile_error_details": {
                    "license-maven-plugin-git/src/main/java/com/mycila/maven/plugin/license/git/CopyrightAuthorProvider.java": {
                        "48": {
                            "lines": [
                                {
                                    "line_no": 47,
                                    "content": "    if (mojo.warnIfShallow && gitLookup.isShallowRepository()) {"
                                },
                                {
                                    "line_no": 48,
                                    "content": "      mojo.warn(\"Shallow git repository detected. Author property values may not be accurate.\");"
                                },
                                {
                                    "line_no": 49,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[48,11] cannot access org.apache.maven.plugin.AbstractMojo\n",
                                "[48,11] cannot access org.apache.maven.plugin.AbstractMojo\nclass file for org.apache.maven.plugin.AbstractMojo not found\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot access org.apache.maven.plugin.AbstractMojo\n",
            "span_id": 7969986077663416773
        },
        {
            "input": "",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, No diff fences found in content. Make sure that the diff is fenced with ```diff on its own line. and is closed with ```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, No diff fences found in content. Make sure that the diff is fenced with ```diff on its own line. and is closed with ```",
            "span_id": 9227662261376729836
        },
        {
            "input": "```diff\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java\n@@ -22,1 +22,0 @@\n-import org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n@@ -178,1 +177,1 @@\n-    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n+    this.graph = graph;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java!\nMake extra sure the indentation is correct.\nlicense-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java does not contain these 1 exact lines in a row:\n```\nthis.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n```",
            "span_id": 1768989203528781210
        }
    ],
    "read_file": [
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java",
            "output": "/*\n * Copyright (C) 2008-2022 Mycila (mathieu.carbou@gmail.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.mycila.maven.plugin.license.dependencies;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.CumulativeScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.License;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.DefaultProjectBuilder;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Helper class for building Artifact/License mappings from a maven project\n * (multi module or single).\n *\n * @author Royce Remer\n */\npublic class MavenProjectLicenses implements LicenseMap, LicenseMessage {\n\n  private Set<MavenProject> projects;\n  private DependencyGraphBuilder graph;\n  private ProjectBuilder projectBuilder;\n  private ProjectBuildingRequest buildingRequest;\n  private ArtifactFilter filter;\n  private Log log;\n\n  /**\n   * @param projects       the Set of {@link MavenProject} to scan\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   * @param log            the log to sync to\n   */\n  public MavenProjectLicenses(final Set<MavenProject> projects, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final ProjectBuildingRequest buildingRequest,\n                              final ArtifactFilter filter, final Log log) {\n    this.setProjects(projects);\n    this.setBuildingRequest(buildingRequest);\n    this.setGraph(graph);\n    this.setFilter(filter);\n    this.setProjectBuilder(projectBuilder);\n    this.setLog(log);\n\n    log.info(String.format(\"%s %s\", INFO_LICENSE_IMPL, this.getClass()));\n  }\n\n  /**\n   * @param session        the current {@link MavenSession}\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   */\n  public MavenProjectLicenses(final MavenSession session, MavenProject project, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final List<String> scopes, final Log log) {\n    this(Collections.singleton(project), graph, projectBuilder, getBuildingRequestWithDefaults(session),\n        new CumulativeScopeArtifactFilter(scopes), log);\n  }\n\n  private static ProjectBuildingRequest getBuildingRequestWithDefaults(final MavenSession session) {\n    ProjectBuildingRequest request;\n    if (session == null) {\n      request = new DefaultProjectBuildingRequest();\n    } else {\n      request = session.getProjectBuildingRequest();\n    }\n    return request;\n  }\n\n  /**\n   * Return a set of licenses attributed to a single artifact.\n   */\n  protected Set<License> getLicensesFromArtifact(final Artifact artifact) {\n    Set<License> licenses = new HashSet<>();\n    try {\n      MavenProject project = getProjectBuilder().build(artifact, getBuildingRequest()).getProject();\n      licenses.addAll(project.getLicenses());\n    } catch (ProjectBuildingException ex) {\n      getLog().warn(String.format(\"Could not get project from dependency's artifact: %s\", artifact.getFile()));\n    }\n\n    return licenses;\n  }\n\n  /**\n   * Get mapping of Licenses to a set of artifacts presenting that license.\n   *\n   * @param dependencies Set to collate License entries from\n   * @return the same artifacts passed in, keyed by license\n   */\n  protected Map<License, Set<Artifact>> getLicenseMapFromArtifacts(final Set<Artifact> dependencies) {\n    final ConcurrentMap<License, Set<Artifact>> map = new ConcurrentHashMap<>();\n\n    // license:artifact is a many-to-many relationship.\n    // Each artifact may have several licenses.\n    // Each artifact may appear multiple times in the map.\n    dependencies.parallelStream().forEach(artifact -> getLicensesFromArtifact(artifact).forEach(license -> {\n      map.putIfAbsent(license, new HashSet<>());\n      Set<Artifact> artifacts = map.get(license);\n      artifacts.add(artifact);\n      map.put(license, artifacts);\n    }));\n\n    return map;\n  }\n\n  @Override\n  public Map<License, Set<Artifact>> getLicenseMap() {\n    return getLicenseMapFromArtifacts(getDependencies());\n  }\n\n  /**\n   * Return the Set of all direct and transitive Artifact dependencies.\n   */\n  private Set<Artifact> getDependencies() {\n    final Set<Artifact> artifacts = new HashSet<>();\n    final Set<DependencyNode> dependencies = new HashSet<>();\n\n    // build the set of maven dependencies for each module in the reactor (might\n    // only be the single one) and all its transitives\n    getLog().debug(String.format(\"Building dependency graphs for %d projects\", getProjects().size()));\n    getProjects().parallelStream().forEach(project -> {\n      try {\n        dependencies.addAll(getGraph().buildDependencyGraph(buildingRequest, getFilter()).getChildren());\n      } catch (DependencyGraphBuilderException ex) {\n        getLog().warn(\n            String.format(\"Could not get children from project %s, it's dependencies will not be checked!\",\n                project.getId()));\n      }\n    });\n\n    // build the complete set of direct+transitive dependent artifacts in all\n    // modules in the reactor\n    dependencies.parallelStream().forEach(d -> artifacts.add(d.getArtifact()));\n    getLog().info(String.format(\"%s: %d\", INFO_DEPS_DISCOVERED, dependencies.size()));\n\n    return artifacts;\n\n    // tempting, but does not resolve dependencies after the scope in which this\n    // plugin is invoked\n    // return project.getArtifacts();\n  }\n\n  protected Set<MavenProject> getProjects() {\n    return projects;\n  }\n\n  protected void setProjects(final Set<MavenProject> projects) {\n    this.projects = Optional.ofNullable(projects).orElse(new HashSet<>());\n  }\n\n  private DependencyGraphBuilder getGraph() {\n    return graph;\n  }\n\n  private void setGraph(DependencyGraphBuilder graph) {\n    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n  }\n\n  private ProjectBuilder getProjectBuilder() {\n    return projectBuilder;\n  }\n\n  private void setProjectBuilder(ProjectBuilder projectBuilder) {\n    this.projectBuilder = Optional.ofNullable(projectBuilder).orElse(new DefaultProjectBuilder());\n  }\n\n  private ArtifactFilter getFilter() {\n    return filter;\n  }\n\n  private void setFilter(ArtifactFilter filter) {\n    this.filter = filter;\n  }\n\n  private Log getLog() {\n    return log;\n  }\n\n  private void setLog(Log log) {\n    this.log = log;\n  }\n\n  private ProjectBuildingRequest getBuildingRequest() {\n    return buildingRequest;\n  }\n\n  protected void setBuildingRequest(final ProjectBuildingRequest buildingRequest) {\n    this.buildingRequest = Optional.ofNullable(buildingRequest).orElse(new DefaultProjectBuildingRequest());\n  }\n}\n",
            "error": "",
            "span_id": 4861788691636325400
        },
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/git/CopyrightAuthorProvider.java",
            "output": "Error: RetryError[<Future at 0x7df358b7c9e0 state=finished raised FileNotFoundError>]",
            "error": "RetryError[<Future at 0x7df358b7c9e0 state=finished raised FileNotFoundError>]",
            "span_id": 13297833869066227720
        },
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/AbstractLicenseMojo.java",
            "output": "/*\n * Copyright (C) 2008-2022 Mycila (mathieu.carbou@gmail.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.mycila.maven.plugin.license;\n\nimport com.mycila.maven.plugin.license.dependencies.LicenseMessage;\nimport com.mycila.maven.plugin.license.dependencies.LicensePolicy;\nimport com.mycila.maven.plugin.license.document.Document;\nimport com.mycila.maven.plugin.license.document.DocumentFactory;\nimport com.mycila.maven.plugin.license.document.DocumentPropertiesLoader;\nimport com.mycila.maven.plugin.license.document.DocumentType;\nimport com.mycila.maven.plugin.license.header.AdditionalHeaderDefinition;\nimport com.mycila.maven.plugin.license.header.Header;\nimport com.mycila.maven.plugin.license.header.HeaderDefinition;\nimport com.mycila.maven.plugin.license.header.HeaderSource;\nimport com.mycila.maven.plugin.license.header.HeaderType;\nimport com.mycila.maven.plugin.license.util.Selection;\nimport com.mycila.maven.plugin.license.util.resource.ResourceFinder;\nimport com.mycila.xmltool.XMLDoc;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Organization;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuilder;\nimport org.apache.maven.settings.Server;\nimport org.apache.maven.settings.Settings;\nimport org.apache.maven.settings.crypto.DefaultSettingsDecryptionRequest;\nimport org.apache.maven.settings.crypto.SettingsDecrypter;\nimport org.apache.maven.settings.crypto.SettingsDecryptionRequest;\nimport org.apache.maven.settings.crypto.SettingsDecryptionResult;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.xml.sax.InputSource;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.time.Clock;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.concurrent.CompletionService;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.stream.Collectors;\n\nimport static com.mycila.maven.plugin.license.document.DocumentType.defaultMapping;\nimport static com.mycila.maven.plugin.license.util.FileUtils.asPath;\nimport static java.lang.String.format;\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.deepToString;\n\n/**\n * <b>Date:</b> 18-Feb-2008<br> <b>Author:</b> Mathieu Carbou\n * (mathieu.carbou@gmail.com)\n */\npublic abstract class AbstractLicenseMojo extends AbstractMojo {\n\n  @Parameter\n  public LicenseSet[] licenseSets;\n\n  /**\n   * The base directory, in which to search for project files.\n   * <p>\n   * This is named `defaultBaseDirectory` as it will be used as the default\n   * value for the base directory. This default value can be overridden\n   * in each LicenseSet by setting {@link LicenseSet#basedir}.\n   */\n  @Parameter(property = \"license.basedir\", defaultValue = \"${project.basedir}\", alias = \"basedir\", required = true)\n  public File defaultBasedir;\n\n  /**\n   * Location of the header. It can be a relative path, absolute path,\n   * classpath resource, any URL. The plugin first check if the name specified\n   * is a relative file, then an absolute file, then in the classpath. If not\n   * found, it tries to construct a URL from the location.\n   *\n   * @deprecated use {@link LicenseSet#header}\n   */\n  @Deprecated\n  @Parameter(property = \"license.header\", alias = \"header\")\n  public String legacyConfigHeader;\n\n  /**\n   * Header, as text, directly in pom file. Using a CDATA section is strongly recommended.\n   *\n   * @deprecated use {@link LicenseSet#inlineHeader}\n   */\n  @Deprecated\n  @Parameter(property = \"license.inlineHeader\", alias = \"inlineHeader\")\n  public String legacyConfigInlineHeader;\n\n  /**\n   * Specifies additional header files to use when checking for the presence\n   * of a valid header in your sources.\n   * <br>\n   * When using format goal, this property will be used to detect all valid\n   * headers that don't need formatting.\n   * <br>\n   * When using remove goal, this property will be used to detect all valid\n   * headers that also must be removed.\n   *\n   * @deprecated use {@link LicenseSet#validHeaders}\n   */\n  @Deprecated\n  @Parameter(alias = \"validHeaders\")\n  public String[] legacyConfigValidHeaders = new String[0];\n\n  /**\n   * Alternative to `header`, `inlineHeader`, or `validHeaders`\n   * for use when code is multi-licensed.\n   * Whilst you could create a concatenated header yourself,\n   * a cleaner approach may be to specify more than one header\n   * and have them concatenated together by the plugin. This\n   * allows you to maintain each distinct license header in\n   * its own file and combined them in different ways.\n   *\n   * @deprecated use {@link LicenseSet#multi}\n   */\n  @Deprecated\n  @Parameter\n  public Multi legacyConfigMulti;\n\n  /**\n   * Allows the use of external header definitions files. These files are\n   * properties like files.\n   * <p>\n   * This is named `defaultHeaderDefinitions` as it will be used as the default\n   * value for the header definitions. This default value can be overridden\n   * in each LicenseSet by setting {@link LicenseSet#headerDefinitions}  or\n   * {@link LicenseSet#inlineHeaderStyles} and is overridden by {@link #defaultInlineHeaderStyles}.\n   */\n  @Parameter(alias = \"headerDefinitions\")\n  public String[] defaultHeaderDefinitions = new String[0];\n\n  /**\n   * Allows the use of inline header definitions.\n   * <p>\n   * This is named `defaultInlineHeaderStyles` as it will be used as the default\n   * value for the header definitions.\n   * <p>\n   * This default value can be overridden\n   * in each LicenseSet by setting {@link LicenseSet#headerDefinitions} or {@link LicenseSet#inlineHeaderStyles}.\n   * <p>\n   * Inline styles overrides those read from file\n   */\n  @Parameter\n  public HeaderStyle[] defaultInlineHeaderStyles = new HeaderStyle[0];\n\n  /**\n   * HeadSections define special regions of a header that allow for dynamic\n   * substitution and validation\n   *\n   * @deprecated use {@link LicenseSet#headerSections}\n   */\n  @Deprecated\n  @Parameter(alias = \"headerSections\")\n  public HeaderSection[] legacyConfigHeaderSections = new HeaderSection[0];\n\n  /**\n   * You can set here some properties that you want to use when reading the\n   * header file. You can use in your header file some properties like\n   * ${year}, ${owner} or whatever you want for the name. They will be\n   * replaced when the header file is read by those you specified in the\n   * command line, in the POM and in system environment.\n   * <p>\n   * This is named `defaultProperties` as it will be used as the default\n   * value for the properties. This default value can be overridden\n   * in each LicenseSet by setting {@link LicenseSet#properties}.\n   */\n  @Parameter(alias = \"properties\")\n  public Map<String, String> defaultProperties = new HashMap<String, String>();\n\n  /**\n   * Specifies files, which are included in the check. By default, all files\n   * are included.\n   *\n   * @deprecated use {@link LicenseSet#includes}\n   */\n  @Deprecated\n  @Parameter(alias = \"includes\", property = \"license.includes\")\n  public String[] legacyConfigIncludes = new String[0];\n\n  /**\n   * Specifies files, which are excluded in the check. By default, only the\n   * files matching the default exclude patterns are excluded.\n   *\n   * @deprecated use {@link LicenseSet#excludes}\n   */\n  @Deprecated\n  @Parameter(alias = \"excludes\", property = \"license.excludes\")\n  public String[] legacyConfigExcludes = new String[0];\n\n  /**\n   * Specify the list of keywords to use to detect a header. A header must\n   * include all keywords to be valid. By default, the word 'copyright' is\n   * used. Detection is done case insensitive.\n   *\n   * @deprecated use {@link LicenseSet#keywords}\n   */\n  @Deprecated\n  @Parameter(alias = \"keywords\")\n  public String[] legacyConfigKeywords = new String[]{\"copyright\"};\n\n  /**\n   * Specify if you want to use default exclusions besides the files you have\n   * excluded. Default exclusions exclude CVS and SVN folders, IDE descriptors\n   * and so on.\n   * <p>\n   * This is named `defaultUseDefaultExcludes` as it will be used as the default\n   * value for whether to use default excludes. This default value can be overridden\n   * in each LicenseSet by setting {@link LicenseSet#useDefaultExcludes}.\n   */\n  @Parameter(property = \"license.useDefaultExcludes\", defaultValue = \"true\", alias = \"useDefaultExcludes\")\n  public boolean defaultUseDefaultExcludes = true;\n\n  /**\n   * You can set this flag to true if you want to check the headers for all\n   * modules of your project. Only used for multi-modules projects, to check\n   * for example the header licenses from the parent module for all sub\n   * modules.\n   */\n  @Parameter(property = \"license.aggregate\", defaultValue = \"false\")\n  public boolean aggregate = false;\n\n  /**\n   * Set mapping between document mapping and a supported type to use. This\n   * section is very useful when you want to customize the supported\n   * extensions. If your project is using file extensions not supported by\n   * default by this plugin, you can add a mapping to attach the extension to\n   * an existing type of comment. The tag name is the new extension name to\n   * support, and the value is the name of the comment type to use.\n   */\n  @Parameter\n  public Map<String, String> mapping = new LinkedHashMap<String, String>();\n\n  /**\n   * Whether to use the default mapping between file extensions and comment\n   * types, or only the one your provide.\n   */\n  @Parameter(property = \"license.useDefaultMapping\", defaultValue = \"true\")\n  public boolean useDefaultMapping = true;\n\n  /**\n   * Maven license plugin uses concurrency to check license headers. This\n   * factor is used to control the number of threads used to check. The rule\n   * is:\n   * <br> {@code <nThreads> = <number of cores> *  concurrencyFactor}\n   * <br>\n   * The default is 1.5.\n   */\n  @Parameter(property = \"license.concurrencyFactor\", defaultValue = \"1.5\")\n  public float concurrencyFactor = 1.5f;\n\n\n  /**\n   * Maven license plugin uses concurrency to check license headers. With this\n   * option the number of threads used to check can be specified. If given\n   * it take precedence over <code>concurrencyFactor</code>\n   * <p>\n   * The default is 0 which implies that the default for <code>concurrencyFactor</code>\n   * is used.\n   */\n  @Parameter(property = \"license.nThreads\", defaultValue = \"0\")\n  public int nThreads;\n\n  /**\n   * Whether to skip the plugin execution\n   */\n  @Parameter(property = \"license.skip\", defaultValue = \"false\")\n  public boolean skip = false;\n\n  /**\n   * Determination of the year and author of the first commit and last change year\n   * of a file requires a full git or svn history. By default the plugin will log\n   * warning when using these properties on a shallow or sparse repository. If you\n   * are certain the repository depth will permit accurate determination of these\n   * values, you can disable this check.\n   */\n  @Parameter(property = \"license.warnIfShallow\", defaultValue = \"true\")\n  public boolean warnIfShallow = true;\n\n  /**\n   * If you do not want to see the list of file having a missing header, you\n   * can add the quiet flag that will shorten the output\n   */\n  @Parameter(property = \"license.quiet\", defaultValue = \"false\")\n  public boolean quiet = false;\n\n  /**\n   * Set to true if you need a strict check against the headers. By default,\n   * the existence of a header is verified by taking the top portion of a file\n   * and checking if it contains the headers text, not considering special\n   * characters (spaces, tabs, ...).\n   * <br>\n   * We highly recommend to keep this option set to {@code true}.\n   */\n  @Parameter(property = \"license.strictCheck\", defaultValue = \"true\")\n  public boolean strictCheck = true;\n\n  /**\n   * Specify the encoding of your files. Default to the project source\n   * encoding property (project.build.sourceEncoding).\n   */\n  @Parameter(property = \"license.encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n  public String encoding = \"UTF-8\";\n\n  /**\n   * You can set this flag to false if you do not want the build to fail when\n   * some headers are missing.\n   */\n  @Parameter(property = \"license.failIfMissing\", defaultValue = \"true\")\n  public boolean failIfMissing = true;\n\n  /**\n   * You can leave this flag on {@code false} if you do not want the build to\n   * fail for files that do not have an implicit or explicit comment style\n   * definition. Setting this explicitly to {@code true} is a safe way to make\n   * sure that the effective file type mappings cover all files included from\n   * your project.\n   * <p>\n   * Default is {@code false} for backwards compatibility reasons.\n   *\n   * @since 2.8\n   */\n  @Parameter(property = \"license.failIfUnknown\", defaultValue = \"false\")\n  public boolean failIfUnknown = false;\n\n  /**\n   * If dryRun is enabled, calls to license:format and license:remove will not\n   * overwrite the existing file but instead write the result to a new file\n   * with the same name but ending with `.licensed`.\n   */\n  @Parameter(property = \"license.dryRun\", defaultValue = \"false\")\n  public boolean dryRun = false;\n\n  /**\n   * Skip the formatting of files which already contain a detected header.\n   */\n  @Parameter(property = \"license.skipExistingHeaders\", defaultValue = \"false\")\n  public boolean skipExistingHeaders = false;\n\n  /**\n   * When enforcing licenses on dependencies, exclude all but these scopes.\n   */\n  @Parameter(property = \"license.dependencies.scope\", required = true, defaultValue = \"runtime\")\n  protected List<String> dependencyScopes;\n\n  /**\n   * Whether to enforce license.dependencies.allow list.\n   */\n  @Parameter(property = \"license.dependencies.enforce\", required = true, defaultValue = \"false\")\n  protected boolean dependencyEnforce;\n\n  /**\n   * Block of {@link LicensePolicy} configuration for enforcing license adherence in dependencies.\n   */\n  @Parameter(property = \"license.dependencies.policies\")\n  protected Set<LicensePolicy> dependencyPolicies;\n\n  /**\n   * Exception message prefix to display when an artifact is denied by one of the license policies.\n   */\n  @Parameter(property = \"license.dependencies.exceptionMessage\", required = true, defaultValue = LicenseMessage.WARN_POLICY_DENIED)\n  protected String dependencyExceptionMessage;\n\n\n  @Parameter(defaultValue = \"${project}\", required = true)\n  protected MavenProject project;\n\n  /**\n   * Maven settings.\n   */\n  @Parameter(defaultValue = \"${settings}\", readonly = true)\n  private Settings settings;\n  /**\n   * The decrypter for passwords.\n   */\n  @Component\n  private SettingsDecrypter settingsDecrypter;\n\n  @Component(hint = \"default\")\n  protected DependencyGraphBuilder dependencyGraphBuilder;\n\n  @Component\n  protected ProjectBuilder projectBuilder;\n\n  @Parameter(defaultValue = \"${session}\")\n  public MavenSession session;\n\n  /**\n   * The location where to write the report of the plugin execution (file processed, action taken, etc).\n   * <p>\n   * \"PRESENT\" means the file has a header (check goal)\n   * <p>\n   * \"MISSING\" means the header is missing (check goal)\n   * <p>\n   * \"NOOP\" means no action were performed (remove or format goal)\n   * <p>\n   * \"ADDED\" means a header was added (format goal)\n   * <p>\n   * \"REPLACED\" means a header was replaced (format goal)\n   * <p>\n   * \"REMOVED\" means a header was removed (format goal)\n   * <p>\n   * \"UNKNOWN\" means that the file extension is unknown\n   * <p>\n   * Activated by default.\n   */\n  @Parameter(property = \"license.report.location\", defaultValue = \"${project.reporting.outputDirectory}/license-plugin-report.xml\")\n  public File reportLocation;\n\n  /**\n   * Format of the report.\n   * <p>\n   * Can be (case-insensitive): 'xml', 'json'.\n   * <p>\n   * Default is XML.\n   */\n  @Parameter(property = \"license.report.format\")\n  public String reportFormat;\n\n  /**\n   * Skip the report generation. Default: false\n   */\n  @Parameter(property = \"license.report.skip\", defaultValue = \"false\")\n  public boolean reportSkipped = false;\n\n  protected Clock clock = Clock.systemUTC();\n  protected Report report;\n\n  protected abstract class AbstractCallback implements Callback {\n\n    /**\n     * Related to {@link #failIfUnknown}.\n     */\n    private final Collection<File> unknownFiles = new ConcurrentLinkedQueue<>();\n\n    @Override\n    public void onUnknownFile(Document document, Header header) {\n      warn(\"Unknown file extension: %s\", document.getFilePath());\n      unknownFiles.add(document.getFile());\n      report.add(document.getFile(), Report.Result.UNKNOWN);\n    }\n\n    public void checkUnknown() throws MojoExecutionException {\n      if (!unknownFiles.isEmpty()) {\n        String msg = \"Unable to find a comment style definition for some \"\n            + \"files. You may want to add a custom mapping for the relevant file extensions.\";\n        if (failIfUnknown) {\n          throw new MojoExecutionException(msg);\n        }\n        getLog().warn(msg);\n      }\n    }\n\n  }\n\n  @SuppressWarnings({\"unchecked\"})\n  protected final void execute(final Callback callback) throws MojoExecutionException, MojoFailureException {\n    if (!skip) {\n\n      // make default base dir canonical\n      this.defaultBasedir = this.getCanonicalFile(this.defaultBasedir, \"license.basedir\");\n\n      // collect all the license sets together\n      final LicenseSet[] allLicenseSets;\n\n      // if we abandon the legacy config this contiguous block can be removed\n      final LicenseSet legacyLicenseSet = convertLegacyConfigToLicenseSet();\n      if (legacyLicenseSet != null) {\n        if (licenseSets == null) {\n          allLicenseSets = new LicenseSet[]{legacyLicenseSet};\n        } else {\n          allLicenseSets = Arrays.copyOf(licenseSets, licenseSets.length + 1);\n          allLicenseSets[licenseSets.length] = legacyLicenseSet;\n        }\n      } else {\n        allLicenseSets = licenseSets;\n      }\n\n      // execute\n      executeForLicenseSets(allLicenseSets, callback);\n\n      report.exportTo(reportLocation);\n    }\n  }\n\n  private File getCanonicalFile(final File file, final String description) throws MojoFailureException {\n    if (file == null) {\n      return null;\n    }\n    try {\n      return file.getCanonicalFile();\n    } catch (final IOException e) {\n      throw new MojoFailureException(\"Could not get canonical path of \" + description, e);\n    }\n  }\n\n  private void executeForLicenseSets(final LicenseSet[] licenseSets, final Callback callback) throws MojoFailureException, MojoExecutionException {\n    if (licenseSets == null || licenseSets.length == 0) {\n      warn(\"At least one licenseSet must be specified\");\n      return;\n    }\n\n    // need to perform validation first\n    for (int i = 0; i < licenseSets.length; i++) {\n      final LicenseSet licenseSet = licenseSets[i];\n      if (!hasHeader(licenseSet)) {\n        warn(\"No header file specified to check for license in licenseSet: \" + i);\n        return;\n      }\n      // make licenseSet baseDir canonical\n      licenseSet.basedir = this.getCanonicalFile(licenseSet.basedir, \"licenseSet[\" + i + \"].basedir\");\n    }\n    if (!strictCheck) {\n      warn(\"Property 'strictCheck' is not enabled. Please consider adding <strictCheck>true</strictCheck> in your pom.xml file.\");\n      warn(\"See https://mycila.carbou.me/license-maven-plugin for more information.\");\n    }\n\n    // then execute each license set\n    for (final LicenseSet licenseSet : licenseSets) {\n      executeForLicenseSet(licenseSet, callback);\n    }\n  }\n\n  private LicenseSet convertLegacyConfigToLicenseSet() {\n    if (legacyConfigHeader == null && (this.legacyConfigInlineHeader == null || this.legacyConfigInlineHeader.isEmpty())) {\n      return null;\n    }\n\n    final LicenseSet legacyLicenseSet = new LicenseSet();\n    legacyLicenseSet.header = legacyConfigHeader;\n    legacyLicenseSet.inlineHeader = legacyConfigInlineHeader;\n    legacyLicenseSet.validHeaders = legacyConfigValidHeaders;\n    legacyLicenseSet.multi = legacyConfigMulti;\n    legacyLicenseSet.headerSections = legacyConfigHeaderSections;\n    legacyLicenseSet.includes = legacyConfigIncludes;\n    legacyLicenseSet.excludes = legacyConfigExcludes;\n    legacyLicenseSet.keywords = legacyConfigKeywords;\n    return legacyLicenseSet;\n  }\n\n  private void executeForLicenseSet(final LicenseSet licenseSet, final Callback callback) throws MojoExecutionException, MojoFailureException {\n    final ResourceFinder finder = new ResourceFinder(firstNonNull(asPath(licenseSet.basedir), asPath(defaultBasedir)));\n    try {\n      finder.setCompileClassPath(project.getCompileClasspathElements());\n    } catch (DependencyResolutionRequiredException e) {\n      throw new MojoExecutionException(e.getMessage(), e);\n    }\n    finder.setPluginClassPath(getClass().getClassLoader());\n\n    final HeaderSource headerSource = HeaderSource.of(licenseSet.multi, licenseSet.inlineHeader, licenseSet.header, this.encoding, finder);\n    final Header h = new Header(headerSource, licenseSet.headerSections);\n    debug(\"Header: %s\", h.getLocation());\n\n    if (licenseSet.validHeaders == null) {\n      licenseSet.validHeaders = new String[0];\n    }\n    final List<Header> validHeaders = new ArrayList<Header>(licenseSet.validHeaders.length);\n    for (final String validHeader : licenseSet.validHeaders) {\n      final HeaderSource validHeaderSource = HeaderSource.of(null, null, validHeader, this.encoding,\n          finder);\n      validHeaders.add(new Header(validHeaderSource, licenseSet.headerSections));\n    }\n\n    Map<String, String> globalProperties = getDefaultProperties();\n\n    // we override by properties in the licenseSet\n    if (licenseSet.properties != null) {\n      for (Map.Entry<String, String> entry : licenseSet.properties.entrySet()) {\n        if (!System.getProperties().contains(entry.getKey())) {\n          globalProperties.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n\n    if (getLog().isDebugEnabled()) {\n      getLog().debug(\n          \"global properties:\\n - \" + globalProperties.entrySet().stream().map(Objects::toString)\n              .collect(Collectors.joining(\"\\n - \")));\n    }\n\n    final List<PropertiesProvider> propertiesProviders = new LinkedList<>();\n    int nThreads = getNumberOfExecutorThreads();\n    ExecutorService executorService = Executors.newFixedThreadPool(nThreads);\n\n    try {\n\n      for (final PropertiesProvider provider : ServiceLoader.load(PropertiesProvider.class,\n          Thread.currentThread().getContextClassLoader())) {\n        provider.init(this, globalProperties);\n        propertiesProviders.add(provider);\n      }\n\n      final DocumentPropertiesLoader perDocumentProperties = new DocumentPropertiesLoader() {\n        @Override\n        public Map<String, String> load(final Document document) {\n          // then add per document properties\n          Map<String, String> perDoc = new LinkedHashMap<>(globalProperties);\n          perDoc.put(\"file.name\", document.getFile().getName());\n\n          Map<String, String> readOnly = Collections.unmodifiableMap(perDoc);\n\n          for (final PropertiesProvider provider : propertiesProviders) {\n            try {\n              final Map<String, String> adjustments = provider.adjustProperties(\n                  AbstractLicenseMojo.this, readOnly, document);\n              if (getLog().isDebugEnabled()) {\n                getLog().debug(\"provider: \" + provider.getClass() + \" adjusted these properties:\\n\"\n                    + adjustments);\n              }\n              for (Map.Entry<String, String> entry : adjustments.entrySet()) {\n                if (entry.getValue() != null) {\n                  perDoc.put(entry.getKey(), entry.getValue());\n                } else {\n                  perDoc.remove(entry.getKey());\n                }\n              }\n            } catch (Exception e) {\n              getLog().warn(\"failure occurred while calling \" + provider.getClass(), e);\n            }\n          }\n\n          if (getLog().isDebugEnabled()) {\n            getLog().debug(\"properties for \" + document + \":\\n - \" + perDoc.entrySet().stream()\n                .map(Objects::toString).collect(Collectors.joining(\"\\n - \")));\n          }\n\n          return perDoc;\n        }\n      };\n\n      final DocumentFactory documentFactory = new DocumentFactory(\n          firstNonNull(licenseSet.basedir, defaultBasedir), buildMapping(),\n          buildHeaderDefinitions(licenseSet, finder), encoding, licenseSet.keywords,\n          perDocumentProperties);\n\n      CompletionService<?> completionService = new ExecutorCompletionService<>(executorService);\n      int count = 0;\n      debug(\"Number of execution threads: %s\", nThreads);\n\n      for (final String file : listSelectedFiles(licenseSet)) {\n        completionService.submit(() -> {\n          Document document = documentFactory.createDocuments(file);\n          debug(\"Selected file: %s [header style: %s]\", document.getFilePath(),\n              document.getHeaderDefinition());\n          if (document.isNotSupported()) {\n            callback.onUnknownFile(document, h);\n          } else if (document.is(h)) {\n            debug(\"Skipping header file: %s\", document.getFilePath());\n          } else if (document.hasHeader(h, strictCheck)) {\n            callback.onExistingHeader(document, h);\n          } else {\n            boolean headerFound = false;\n            for (final Header validHeader : validHeaders) {\n              headerFound = document.hasHeader(validHeader, strictCheck);\n              if (headerFound) {\n                callback.onExistingHeader(document, h);\n                break;\n              }\n            }\n            if (!headerFound) {\n              callback.onHeaderNotFound(document, h);\n            }\n          }\n        }, null);\n        count++;\n      }\n\n      while (count-- > 0) {\n        try {\n          completionService.take().get();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        } catch (ExecutionException e) {\n          Throwable cause = e.getCause();\n          if (cause instanceof Error) {\n            throw (Error) cause;\n          }\n          if (cause instanceof MojoExecutionException) {\n            throw (MojoExecutionException) cause;\n          }\n          if (cause instanceof MojoFailureException) {\n            throw (MojoFailureException) cause;\n          }\n          if (cause instanceof RuntimeException) {\n            throw (RuntimeException) cause;\n          }\n          throw new RuntimeException(cause.getMessage(), cause);\n        }\n      }\n\n    } finally {\n      executorService.shutdownNow();\n      propertiesProviders.forEach(PropertiesProvider::close);\n    }\n  }\n\n  private boolean hasHeader(final LicenseSet licenseSet) {\n    return\n        (licenseSet.multi != null\n            && ((licenseSet.multi.headers != null && licenseSet.multi.headers.length > 0)\n            || (licenseSet.multi.inlineHeaders != null && licenseSet.multi.inlineHeaders.length > 0 && !licenseSet.multi.inlineHeaders[0].isEmpty()))\n        ) || (licenseSet.header != null || (licenseSet.inlineHeader != null && !licenseSet.inlineHeader.isEmpty()));\n  }\n\n  private int getNumberOfExecutorThreads() {\n    return nThreads > 0 ?\n        nThreads :\n        Math.max(1, (int) (Runtime.getRuntime().availableProcessors() * concurrencyFactor));\n  }\n\n  private Map<String, String> getDefaultProperties() {\n    // first put system environment\n    Map<String, String> props = new TreeMap<>(\n        System.getenv()); // treemap just to have nice debug logs\n    // then add ${project.XYZ} properties\n    props.put(\"project.groupId\", project.getGroupId());\n    props.put(\"project.artifactId\", project.getArtifactId());\n    props.put(\"project.version\", project.getVersion());\n    props.put(\"project.name\", project.getName());\n    props.put(\"project.description\", project.getDescription());\n    props.put(\"project.inceptionYear\", project.getInceptionYear());\n    props.put(\"year\", project.getInceptionYear()); // maintains backward compatibility\n    props.put(\"project.url\", project.getUrl());\n    Organization org = project.getOrganization();\n    if (org != null) {\n      props.put(\"owner\", org.getName()); // maintains backward compatibility\n      props.put(\"project.organization.name\", org.getName());\n      props.put(\"project.organization.url\", org.getUrl());\n    }\n\n    // we override by properties in the POM\n    if (this.defaultProperties != null) {\n      props.putAll(this.defaultProperties);\n    }\n\n    // then we override by java system properties (command-line -D...)\n    for (String key : System.getProperties().stringPropertyNames()) {\n      props.put(key, System.getProperty(key));\n    }\n\n    return props;\n  }\n\n  private String[] listSelectedFiles(final LicenseSet licenseSet) {\n    final boolean useDefaultExcludes = (licenseSet.useDefaultExcludes != null ? licenseSet.useDefaultExcludes : defaultUseDefaultExcludes);\n    final Selection selection = new Selection(\n        firstNonNull(licenseSet.basedir, defaultBasedir), licenseSet.includes, buildExcludes(licenseSet), useDefaultExcludes,\n        getLog());\n    debug(\"From: %s\", firstNonNull(licenseSet.basedir, defaultBasedir));\n    debug(\"Including: %s\", deepToString(selection.getIncluded()));\n    debug(\"Excluding: %s\", deepToString(selection.getExcluded()));\n    return selection.getSelectedFiles();\n  }\n\n  private String[] buildExcludes(final LicenseSet licenseSet) {\n    List<String> ex = new ArrayList<>();\n    ex.addAll(asList(licenseSet.excludes));\n    if (project != null && project.getModules() != null && !aggregate) {\n      for (String module : project.getModules()) {\n        ex.add(module + \"/**\");\n      }\n    }\n    return ex.toArray(new String[ex.size()]);\n  }\n\n  public final void info(String format, Object... params) {\n    if (!quiet) {\n      getLog().info(format(format, params));\n    }\n  }\n\n  public final void debug(String format, Object... params) {\n    if (!quiet) {\n      getLog().debug(format(format, params));\n    }\n  }\n\n  public final void warn(String format, Object... params) {\n    if (!quiet) {\n      getLog().warn(format(format, params));\n    }\n  }\n\n  private Map<String, String> buildMapping() {\n    Map<String, String> extensionMapping = new LinkedHashMap<>();\n    // force inclusion of unknown item to manage unknown files\n    extensionMapping.put(DocumentType.UNKNOWN.getExtension(), DocumentType.UNKNOWN.getDefaultHeaderTypeName());\n    for (Map.Entry<String, String> entry : mapping.entrySet()) {\n      extensionMapping.put(entry.getKey().toLowerCase(), entry.getValue().toLowerCase());\n    }\n    if (useDefaultMapping) {\n      for (Map.Entry<String, String> entry : defaultMapping().entrySet()) {\n        if (!extensionMapping.containsKey(entry.getKey())) {\n          extensionMapping.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    return extensionMapping;\n  }\n\n  private Map<String, HeaderDefinition> buildHeaderDefinitions(final LicenseSet licenseSet, final ResourceFinder finder) throws MojoFailureException {\n    // like mappings, first get default definitions\n    final Map<String, HeaderDefinition> headers = new HashMap<>(HeaderType.defaultDefinitions());\n\n    // and then override them with those provided in base config\n    for (final String headerDefiniton : defaultHeaderDefinitions) {\n      headers.putAll(loadHeaderDefinition(headerDefiniton, finder));\n    }\n\n    // then override by inline default styles\n    for (HeaderStyle defaultInlineHeaderStyle : defaultInlineHeaderStyles) {\n      headers.put(defaultInlineHeaderStyle.name, defaultInlineHeaderStyle.toHeaderDefinition());\n    }\n\n    // and then override them with those provided in licenseSet config\n    for (final String headerDefiniton : licenseSet.headerDefinitions) {\n      headers.putAll(loadHeaderDefinition(headerDefiniton, finder));\n    }\n\n    for (HeaderStyle inlineHeaderStyle : licenseSet.inlineHeaderStyles) {\n      headers.put(inlineHeaderStyle.name, inlineHeaderStyle.toHeaderDefinition());\n    }\n\n    // force inclusion of unknown item to manage unknown files\n    headers.put(HeaderType.UNKNOWN.getDefinition().getType(), HeaderType.UNKNOWN.getDefinition());\n    return headers;\n  }\n\n  private Map<String, HeaderDefinition> loadHeaderDefinition(final String headerDefinition, final ResourceFinder finder) throws MojoFailureException {\n    try {\n      final InputSource source = new InputSource(finder.findResource(headerDefinition).openStream());\n      source.setEncoding(encoding);\n      final AdditionalHeaderDefinition fileDefinitions = new AdditionalHeaderDefinition(XMLDoc.from(source, true));\n      final Map<String, HeaderDefinition> map = fileDefinitions.getDefinitions();\n      debug(\"%d header definitions loaded from '%s'\", map.size(), headerDefinition);\n      return map;\n    } catch (final IOException ex) {\n      throw new MojoFailureException(\"Error reading header definition: \" + headerDefinition, ex);\n    }\n  }\n\n  /**\n   * Returns the list of servers with decrypted passwords.\n   *\n   * @return list of servers with decrypted passwords.\n   */\n  List<Server> getDecryptedServers() {\n    final SettingsDecryptionRequest settingsDecryptionRequest = new DefaultSettingsDecryptionRequest();\n    settingsDecryptionRequest.setServers(settings.getServers());\n    final SettingsDecryptionResult decrypt = settingsDecrypter.decrypt(settingsDecryptionRequest);\n    return decrypt.getServers();\n  }\n\n  /**\n   * Retrieves the credentials for the given server or null if none could be\n   * found\n   *\n   * @param serverID\n   * @return\n   */\n  public Credentials findCredentials(String serverID) {\n    if (serverID == null) {\n      return null;\n    }\n\n    List<Server> decryptedServers = getDecryptedServers();\n\n    for (Server ds : decryptedServers) {\n      if (ds.getId().equals(serverID)) {\n        getLog().debug(\n            \"credentials have been found for server: \" + serverID + \", login:\" + ds.getUsername()\n                + \", password:\" + starEncrypt(ds.getPassword()));\n        return new Credentials(ds.getUsername(), ds.getPassword());\n      }\n    }\n\n    getLog().debug(\"no credentials found for server: \" + serverID);\n    return null;\n  }\n\n  static String starEncrypt(String str) {\n    if (str == null) {\n      return null;\n    }\n    return str.replaceAll(\".\", \"*\");\n  }\n\n  private static <T> T firstNonNull(final T t1, final T t2) {\n    if (t1 != null) {\n      return t1;\n    }\n    return t2;\n  }\n}\n",
            "error": "",
            "span_id": 18244390546318621055
        },
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license/dependencies/MavenProjectLicenses.java",
            "output": "/*\n * Copyright (C) 2008-2022 Mycila (mathieu.carbou@gmail.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.mycila.maven.plugin.license.dependencies;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.CumulativeScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.License;\nimport org.apache.maven.plugin.logging.Log;\nimport org.apache.maven.project.DefaultProjectBuilder;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.internal.Maven31DependencyGraphBuilder;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Helper class for building Artifact/License mappings from a maven project\n * (multi module or single).\n *\n * @author Royce Remer\n */\npublic class MavenProjectLicenses implements LicenseMap, LicenseMessage {\n\n  private Set<MavenProject> projects;\n  private DependencyGraphBuilder graph;\n  private ProjectBuilder projectBuilder;\n  private ProjectBuildingRequest buildingRequest;\n  private ArtifactFilter filter;\n  private Log log;\n\n  /**\n   * @param projects       the Set of {@link MavenProject} to scan\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   * @param log            the log to sync to\n   */\n  public MavenProjectLicenses(final Set<MavenProject> projects, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final ProjectBuildingRequest buildingRequest,\n                              final ArtifactFilter filter, final Log log) {\n    this.setProjects(projects);\n    this.setBuildingRequest(buildingRequest);\n    this.setGraph(graph);\n    this.setFilter(filter);\n    this.setProjectBuilder(projectBuilder);\n    this.setLog(log);\n\n    log.info(String.format(\"%s %s\", INFO_LICENSE_IMPL, this.getClass()));\n  }\n\n  /**\n   * @param session        the current {@link MavenSession}\n   * @param graph          the {@link DependencyGraphBuilder} implementation\n   * @param projectBuilder the maven {@link ProjectBuilder} implementation\n   */\n  public MavenProjectLicenses(final MavenSession session, MavenProject project, final DependencyGraphBuilder graph,\n                              final ProjectBuilder projectBuilder, final List<String> scopes, final Log log) {\n    this(Collections.singleton(project), graph, projectBuilder, getBuildingRequestWithDefaults(session),\n        new CumulativeScopeArtifactFilter(scopes), log);\n  }\n\n  private static ProjectBuildingRequest getBuildingRequestWithDefaults(final MavenSession session) {\n    ProjectBuildingRequest request;\n    if (session == null) {\n      request = new DefaultProjectBuildingRequest();\n    } else {\n      request = session.getProjectBuildingRequest();\n    }\n    return request;\n  }\n\n  /**\n   * Return a set of licenses attributed to a single artifact.\n   */\n  protected Set<License> getLicensesFromArtifact(final Artifact artifact) {\n    Set<License> licenses = new HashSet<>();\n    try {\n      MavenProject project = getProjectBuilder().build(artifact, getBuildingRequest()).getProject();\n      licenses.addAll(project.getLicenses());\n    } catch (ProjectBuildingException ex) {\n      getLog().warn(String.format(\"Could not get project from dependency's artifact: %s\", artifact.getFile()));\n    }\n\n    return licenses;\n  }\n\n  /**\n   * Get mapping of Licenses to a set of artifacts presenting that license.\n   *\n   * @param dependencies Set to collate License entries from\n   * @return the same artifacts passed in, keyed by license\n   */\n  protected Map<License, Set<Artifact>> getLicenseMapFromArtifacts(final Set<Artifact> dependencies) {\n    final ConcurrentMap<License, Set<Artifact>> map = new ConcurrentHashMap<>();\n\n    // license:artifact is a many-to-many relationship.\n    // Each artifact may have several licenses.\n    // Each artifact may appear multiple times in the map.\n    dependencies.parallelStream().forEach(artifact -> getLicensesFromArtifact(artifact).forEach(license -> {\n      map.putIfAbsent(license, new HashSet<>());\n      Set<Artifact> artifacts = map.get(license);\n      artifacts.add(artifact);\n      map.put(license, artifacts);\n    }));\n\n    return map;\n  }\n\n  @Override\n  public Map<License, Set<Artifact>> getLicenseMap() {\n    return getLicenseMapFromArtifacts(getDependencies());\n  }\n\n  /**\n   * Return the Set of all direct and transitive Artifact dependencies.\n   */\n  private Set<Artifact> getDependencies() {\n    final Set<Artifact> artifacts = new HashSet<>();\n    final Set<DependencyNode> dependencies = new HashSet<>();\n\n    // build the set of maven dependencies for each module in the reactor (might\n    // only be the single one) and all its transitives\n    getLog().debug(String.format(\"Building dependency graphs for %d projects\", getProjects().size()));\n    getProjects().parallelStream().forEach(project -> {\n      try {\n        dependencies.addAll(getGraph().buildDependencyGraph(buildingRequest, getFilter()).getChildren());\n      } catch (DependencyGraphBuilderException ex) {\n        getLog().warn(\n            String.format(\"Could not get children from project %s, it's dependencies will not be checked!\",\n                project.getId()));\n      }\n    });\n\n    // build the complete set of direct+transitive dependent artifacts in all\n    // modules in the reactor\n    dependencies.parallelStream().forEach(d -> artifacts.add(d.getArtifact()));\n    getLog().info(String.format(\"%s: %d\", INFO_DEPS_DISCOVERED, dependencies.size()));\n\n    return artifacts;\n\n    // tempting, but does not resolve dependencies after the scope in which this\n    // plugin is invoked\n    // return project.getArtifacts();\n  }\n\n  protected Set<MavenProject> getProjects() {\n    return projects;\n  }\n\n  protected void setProjects(final Set<MavenProject> projects) {\n    this.projects = Optional.ofNullable(projects).orElse(new HashSet<>());\n  }\n\n  private DependencyGraphBuilder getGraph() {\n    return graph;\n  }\n\n  private void setGraph(DependencyGraphBuilder graph) {\n    this.graph = Optional.ofNullable(graph).orElse(new Maven31DependencyGraphBuilder());\n  }\n\n  private ProjectBuilder getProjectBuilder() {\n    return projectBuilder;\n  }\n\n  private void setProjectBuilder(ProjectBuilder projectBuilder) {\n    this.projectBuilder = Optional.ofNullable(projectBuilder).orElse(new DefaultProjectBuilder());\n  }\n\n  private ArtifactFilter getFilter() {\n    return filter;\n  }\n\n  private void setFilter(ArtifactFilter filter) {\n    this.filter = filter;\n  }\n\n  private Log getLog() {\n    return log;\n  }\n\n  private void setLog(Log log) {\n    this.log = log;\n  }\n\n  private ProjectBuildingRequest getBuildingRequest() {\n    return buildingRequest;\n  }\n\n  protected void setBuildingRequest(final ProjectBuildingRequest buildingRequest) {\n    this.buildingRequest = Optional.ofNullable(buildingRequest).orElse(new DefaultProjectBuildingRequest());\n  }\n}\n",
            "error": "",
            "span_id": 5307314182788566798
        }
    ],
    "get_directory_tree": [
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license",
            "output": "[\n    {\n        \"name\": \"LicenseFormatMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseRemoveMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseCheckMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Callback.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseSet.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"AbstractLicenseMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Report.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Credentials.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Default.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"HeaderSection.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"dependencies\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"LicenseMessage.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DefaultLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"MavenProjectLicenses.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicyEnforcerResult.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ArtifactLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AggregateLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseNameLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicy.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AbstractLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseMap.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseURLLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"HeaderStyle.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Multi.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"header\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"HeaderSource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Header.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderType.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AdditionalHeaderDefinition.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderDefinition.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderParser.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"util\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"FileUtils.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"resource\",\n                \"type\": \"directory\",\n                \"contents\": [\n                    {\n                        \"name\": \"ResourceFinder.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"CustomClassLoader.java\",\n                        \"type\": \"file\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"Selection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"FileContent.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"StringUtils.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"PropertiesProvider.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"document\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"DocumentFactory.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DocumentPropertiesLoader.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Document.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PropertyPlaceholderResolver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DocumentType.java\",\n                \"type\": \"file\"\n            }\n        ]\n    }\n]",
            "error": "",
            "span_id": 9904918295328044221
        },
        {
            "input": "license-maven-plugin/src/main/java/com/mycila/maven/plugin/license",
            "output": "[\n    {\n        \"name\": \"LicenseFormatMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseRemoveMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseCheckMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Callback.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"LicenseSet.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"AbstractLicenseMojo.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Report.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Credentials.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Default.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"HeaderSection.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"dependencies\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"LicenseMessage.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DefaultLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"MavenProjectLicenses.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicyEnforcerResult.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ArtifactLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AggregateLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseNameLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicensePolicy.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AbstractLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseMap.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"LicenseURLLicensePolicyEnforcer.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"HeaderStyle.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"Multi.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"header\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"HeaderSource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Header.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderType.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AdditionalHeaderDefinition.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderDefinition.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"HeaderParser.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"util\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"FileUtils.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"resource\",\n                \"type\": \"directory\",\n                \"contents\": [\n                    {\n                        \"name\": \"ResourceFinder.java\",\n                        \"type\": \"file\"\n                    },\n                    {\n                        \"name\": \"CustomClassLoader.java\",\n                        \"type\": \"file\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"Selection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"FileContent.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"StringUtils.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"PropertiesProvider.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"document\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"DocumentFactory.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DocumentPropertiesLoader.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Document.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PropertyPlaceholderResolver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DocumentType.java\",\n                \"type\": \"file\"\n            }\n        ]\n    }\n]",
            "error": "",
            "span_id": 9179113608294159152
        }
    ],
    "get_language_server_suggestions": [],
    "reset_repo": [
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 1983704942041526779
        }
    ]
}