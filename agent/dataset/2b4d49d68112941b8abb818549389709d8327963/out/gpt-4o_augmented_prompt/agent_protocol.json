{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java\n+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java\n@@ -22,7 +22,6 @@\n import com.hazelcast.config.MapConfig;\n-import com.hazelcast.config.MaxSizeConfig;\n import com.hazelcast.config.MemberAttributeConfig;\n import com.hazelcast.config.MemcacheProtocolConfig;\n import com.hazelcast.config.NetworkConfig;\n@@ -27,7 +26,6 @@\n import com.hazelcast.config.RestApiConfig;\n-import com.hazelcast.core.Cluster;\n import com.hazelcast.core.Hazelcast;\n import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.core.Member;\n@@ -149,7 +147,6 @@\n     private static HazelcastInstance hazelcast = null;\n-    private static Cluster cluster = null;\n     private ClusterListener clusterListener;\n     private String lifecycleListener;\n     private String membershipListener;\n@@ -201,7 +198,7 @@\n                 }\n                 hazelcast = Hazelcast.newHazelcastInstance(config);\n-                cluster = hazelcast.getCluster();\n+                Cluster cluster = hazelcast.getCluster();\n                 state = State.started;\n                 // CacheFactory is now using clustered caches. We can add our listeners.\n                 clusterListener = new ClusterListener(cluster);\n@@ -501,7 +498,7 @@\n     public byte[] getSeniorClusterMemberID() {\n-        if (cluster != null && !cluster.getMembers().isEmpty()) {\n-            final Member oldest = cluster.getMembers().iterator().next();\n+        Cluster cluster = hazelcast.getCluster();\n+        if (cluster != null && !cluster.getMembers().isEmpty()) {\n+            final com.hazelcast.cluster.Member oldest = cluster.getMembers().iterator().next();\n             return getNodeID(oldest).toByteArray();\n         } else {\n             return null;\n@@ -655,7 +652,7 @@\n     public byte[] getClusterMemberID() {\n-        if (cluster != null) {\n+        Cluster cluster = hazelcast.getCluster();\n+        if (cluster != null) {\n             return getNodeID(cluster.getLocalMember()).toByteArray();\n         } else {\n             return null;\n@@ -688,7 +685,7 @@\n     @Override\n     public long getClusterTime() {\n-        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n+        Cluster cluster = hazelcast.getCluster();\n+        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n     }\n \n@@ -727,7 +724,7 @@\n         if (cluster == null) {\n             return;\n         }\n-        final Set<Member> members = new HashSet<>();\n-        final Member current = cluster.getLocalMember();\n-        for (final Member member : cluster.getMembers()) {\n+        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();\n+        final com.hazelcast.cluster.Member current = cluster.getLocalMember();\n+        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n             if (!member.getUuid().equals(current.getUuid())) {\n                 members.add(member);\n             }\n@@ -754,7 +751,7 @@\n         if (cluster == null) {\n             return;\n         }\n-        final Member member = getMember(nodeID);\n+        final com.hazelcast.cluster.Member member = getMember(nodeID);\n         // Check that the requested member was found\n         if (member != null) {\n             // Asynchronously execute the task on the target member\n@@ -783,7 +780,7 @@\n         if (cluster == null) {\n             return Collections.emptyList();\n         }\n-        final Set<Member> members = new HashSet<>();\n-        final Member current = cluster.getLocalMember();\n-        for (final Member member : cluster.getMembers()) {\n+        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();\n+        final com.hazelcast.cluster.Member current = cluster.getLocalMember();\n+        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n             if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                 members.add(member);\n             }\n@@ -819,7 +816,7 @@\n         if (cluster == null) {\n             return null;\n         }\n-        final Member member = getMember(nodeID);\n+        final com.hazelcast.cluster.Member member = getMember(nodeID);\n         T result = null;\n         // Check that the requested member was found\n         if (member != null) {\n@@ -841,7 +838,7 @@\n         if (cluster == null) {\n             return null;\n         }\n-        final Member member = getMember(nodeID);\n+        final com.hazelcast.cluster.Member member = getMember(nodeID);\n         if (member != null) {\n             result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n         }\n@@ -850,7 +847,7 @@\n     }\n \n     private Member getMember(final byte[] nodeID) {\n         final NodeID memberToFind = NodeID.getInstance(nodeID);\n-        for (final Member member : cluster.getMembers()) {\n+        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n             if (memberToFind.equals(getNodeID(member))) {\n                 return member;\n             }\n@@ -1007,7 +1004,7 @@\n     }\n \n     public static NodeID getNodeID(final Member member) {\n-        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n+        return NodeID.getInstance(member.getAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n     }\n \n     static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java\n+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java\n@@ -18,7 +18,7 @@\n import com.hazelcast.core.Cluster;\n import com.hazelcast.core.EntryListener;\n import com.hazelcast.core.LifecycleEvent;\n import com.hazelcast.core.LifecycleEvent.LifecycleState;\n import com.hazelcast.core.LifecycleListener;\n-import com.hazelcast.core.Member;\n-import com.hazelcast.core.MemberAttributeEvent;\n-import com.hazelcast.core.MembershipEvent;\n-import com.hazelcast.core.MembershipListener;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.cluster.MemberAttributeEvent;\n+import com.hazelcast.cluster.MembershipEvent;\n+import com.hazelcast.cluster.MembershipListener;\n import org.jivesoftware.openfire.XMPPServer;\n import org.jivesoftware.openfire.cluster.ClusterManager;\n import org.jivesoftware.openfire.cluster.ClusterNodeInfo;\n import org.jivesoftware.openfire.cluster.NodeID;\n import org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;\n import org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\n import org.jivesoftware.util.cache.Cache;\n import org.jivesoftware.util.cache.CacheFactory;\n import org.jivesoftware.util.cache.CacheWrapper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import java.time.Duration;\n import java.time.LocalTime;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state\n  * of the routing table and the sessions within it when a node which manages those sessions goes down.\n  */\n public class ClusterListener implements MembershipListener, LifecycleListener {\n \n     private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);\n \n     private boolean seniorClusterMember = false;\n \n     private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();\n     \n     private final Cluster cluster;\n     private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n     \n     /**\n      * Flag that indicates if the listener has done all clean up work when noticed that the\n      * cluster has been stopped. This will force Openfire to wait until all clean\n      * up (e.g. changing caches implementations) is done before destroying the plugin.\n      */\n     private boolean done = true;\n     /**\n      * Flag that indicates if we've joined a cluster or not\n      */\n     private boolean clusterMember = false;\n     private boolean isSenior;\n \n     ClusterListener(final Cluster cluster) {\n \n         this.cluster = cluster;\n         for (final Member member : cluster.getMembers()) {\n             clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),\n                     new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));\n         }\n     }\n \n     private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {\n         if (cache instanceof CacheWrapper) {\n             final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();\n             if (wrapped instanceof ClusteredCache) {\n                 ((ClusteredCache)wrapped).addEntryListener(listener);\n                 // Keep track of the listener that we added to the cache\n                 entryListeners.put(cache, listener);\n             }\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     private boolean isDone() {\n         return done;\n     }\n \n     synchronized void joinCluster() {\n         if (!isDone()) { // already joined\n             return;\n         }\n \n         // Trigger events\n         clusterMember = true;\n         seniorClusterMember = isSeniorClusterMember();\n \n         ClusterManager.fireJoinedCluster(false);\n \n         if (seniorClusterMember) {\n             ClusterManager.fireMarkedAsSeniorClusterMember();\n         }\n \n         waitForClusterCacheToBeInstalled();\n \n         // Let the other nodes know that we joined the cluster\n         logger.debug(\"Done joining the cluster. Now proceed informing other nodes that we joined the cluster.\");\n         CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n \n         logger.info(\"Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}\",\n             new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});\n         done = false;\n     }\n \n     boolean isSeniorClusterMember() {\n         // first cluster member is the oldest\n         final Iterator<Member> members = cluster.getMembers().iterator();\n         return members.next().getUuid().equals(cluster.getLocalMember().getUuid());\n     }\n \n     private synchronized void leaveCluster() {\n         if (isDone()) { // not a cluster member\n             return;\n         }\n         clusterMember = false;\n         final boolean wasSeniorClusterMember = seniorClusterMember;\n         seniorClusterMember = false;\n \n         // Trigger event. Wait until the listeners have processed the event. Caches will be populated\n         // again with local content.\n         ClusterManager.fireLeftCluster();\n \n         if (!XMPPServer.getInstance().isShuttingDown()) {\n             // Remove traces of directed presences sent from local entities to handlers that no longer exist\n             // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n             XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n         }\n         logger.info(\"Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}\",\n             new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});\n         done = true;\n     }\n \n     @Override\n     public void memberAdded(final MembershipEvent event) {\n         logger.info(\"Received a Hazelcast memberAdded event {}\", event);\n \n         final boolean wasSenior = isSenior;\n         isSenior = isSeniorClusterMember();\n         // local member only\n         final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n         if (event.getMember().localMember()) { // We left and re-joined the cluster\n             joinCluster();\n \n         } else {\n             if (wasSenior && !isSenior) {\n                 logger.warn(\"Recovering from split-brain; firing leftCluster()/joinedCluster() events\");\n                 ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n                 logger.debug(\"Firing joinedCluster() event\");\n                 ClusterManager.fireJoinedCluster(false);\n \n                 try {\n                     logger.debug(\"Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.\");\n                     Thread.sleep(30000L);\n                 } catch (InterruptedException e) {\n                     logger.warn(\"30 Second wait was interrupted.\", e);\n                 }\n \n                 // The following line was intended to wait until all local handling finishes before informing other\n                 // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.\n                 // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.\n                 waitForClusterCacheToBeInstalled();\n \n                 // Let the other nodes know that we joined the cluster\n                 logger.debug(\"Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.\");\n                 CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n             }\n         }\n         clusterNodesInfo.put(nodeID,\n                 new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));\n     }\n \n     /**\n      * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful\n      * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still\n      * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently\n      * discarded.\n      *\n      * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.\n      *\n      * @return Boolean indicating whether the clustered cache was actually observed to be installed.\n      */\n     private boolean waitForClusterCacheToBeInstalled() {\n         boolean failed = false;\n         if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {\n             logger.debug(\"This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.\", ClusteredCacheFactory.PLUGIN_NAME);\n             LocalTime deadLine = LocalTime.now().plusMinutes(10L);\n             while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {\n                 try {\n                     Thread.sleep(200);\n                 } catch (InterruptedException e) {\n                     logger.trace(\"Thread was interrupted while waiting for cache strategy to change.\");\n                     failed = true;\n                     break;\n                 }\n             }\n             if (!deadLine.isAfter(LocalTime.now())) {\n                 failed = true;\n                 logger.warn(\"Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.\", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());\n             }\n             logger.debug(\"Cache factory has been swapped to '{}'. Cluster join is considered complete.\", ClusteredCacheFactory.PLUGIN_NAME);\n         }\n \n         return !failed;\n     }\n \n     @Override\n     public void memberRemoved(final MembershipEvent event) {\n         logger.info(\"Received a Hazelcast memberRemoved event {}\", event);\n \n         isSenior = isSeniorClusterMember();\n         final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n \n         if (event.getMember().localMember()) {\n             logger.info(\"Leaving cluster: \" + nodeID);\n             // This node may have realized that it got kicked out of the cluster\n             leaveCluster();\n         } else {\n             // Trigger event that a node left the cluster\n             ClusterManager.fireLeftCluster(nodeID.toByteArray());\n \n             if (!seniorClusterMember && isSeniorClusterMember()) {\n                 seniorClusterMember = true;\n                 ClusterManager.fireMarkedAsSeniorClusterMember();\n             }\n \n             // Remove traces of directed presences sent from local entities to handlers that no longer exist.\n             // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n             XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n         }\n         // Delete nodeID instance (release from memory)\n         NodeID.deleteInstance(nodeID.toByteArray());\n         clusterNodesInfo.remove(nodeID);\n     }\n     \n     @SuppressWarnings(\"WeakerAccess\")\n     public List<ClusterNodeInfo> getClusterNodesInfo() {\n         return new ArrayList<>(clusterNodesInfo.values());\n     }\n \n     @Override\n     public void stateChanged(final LifecycleEvent event) {\n         if (event.getState().equals(LifecycleState.SHUTDOWN)) {\n             leaveCluster();\n         } else if (event.getState().equals(LifecycleState.STARTED)) {\n             joinCluster();\n         }\n     }\n \n     @Override\n     public void memberAttributeChanged(final MemberAttributeEvent event) {\n         logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);\n         isSenior = isSeniorClusterMember();\n         final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));\n         clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),\n                 new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));\n     }\n \n     boolean isClusterMember() {\n         return clusterMember;\n     }\n }\n--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java\n+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java\n@@ -20,7 +20,7 @@\n import com.hazelcast.core.EntryEvent;\n import com.hazelcast.core.EntryListener;\n-import com.hazelcast.core.IMap;\n-import com.hazelcast.core.MapEvent;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.map.MapEvent;\n import com.hazelcast.map.listener.MapListener;\n-import com.hazelcast.monitor.LocalMapStats;\n+import com.hazelcast.map.LocalMapStats;\n import org.jivesoftware.openfire.XMPPServer;\n import org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;\n import org.jivesoftware.openfire.cluster.NodeID;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "incompatible types: invalid method reference\n",
                "updated_files": {
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                Cluster cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        Cluster cluster = hazelcast.getCluster();\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final com.hazelcast.cluster.Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        Cluster cluster = hazelcast.getCluster();\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        Cluster cluster = hazelcast.getCluster();\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();\n        final com.hazelcast.cluster.Member current = cluster.getLocalMember();\n        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final com.hazelcast.cluster.Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();\n        final com.hazelcast.cluster.Member current = cluster.getLocalMember();\n        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final com.hazelcast.cluster.Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final com.hazelcast.cluster.Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\n",
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.LifecycleEvent;\nimport com.hazelcast.core.LifecycleEvent.LifecycleState;\nimport com.hazelcast.core.LifecycleListener;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.cluster.MemberAttributeEvent;\nimport com.hazelcast.cluster.MembershipEvent;\nimport com.hazelcast.cluster.MembershipListener;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state\n * of the routing table and the sessions within it when a node which manages those sessions goes down.\n */\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);\n\n    private boolean seniorClusterMember = false;\n\n    private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();\n    \n    private final Cluster cluster;\n    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n    \n\n    private final Cluster cluster;\n    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n\n    /**\n     * Flag that indicates if the listener has done all clean up work when noticed that the\n     * cluster has been stopped. This will force Openfire to wait until all clean\n     * up (e.g. changing caches implementations) is done before destroying the plugin.\n     */\n    private boolean done = true;\n    /**\n     * Flag that indicates if we've joined a cluster or not\n     */\n    private boolean clusterMember = false;\n    private boolean isSenior;\n\n    ClusterListener(final Cluster cluster) {\n\n        this.cluster = cluster;\n        for (final Member member : cluster.getMembers()) {\n            clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),\n                    new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));\n        }\n    }\n\n    private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {\n        if (cache instanceof CacheWrapper) {\n            final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();\n            if (wrapped instanceof ClusteredCache) {\n                ((ClusteredCache)wrapped).addEntryListener(listener);\n                // Keep track of the listener that we added to the cache\n                entryListeners.put(cache, listener);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private boolean isDone() {\n        return done;\n    }\n\n    synchronized void joinCluster() {\n        if (!isDone()) { // already joined\n            return;\n        }\n\n        // Trigger events\n        clusterMember = true;\n        seniorClusterMember = isSeniorClusterMember();\n\n        ClusterManager.fireJoinedCluster(false);\n\n        if (seniorClusterMember) {\n            ClusterManager.fireMarkedAsSeniorClusterMember();\n        }\n\n        waitForClusterCacheToBeInstalled();\n\n        // Let the other nodes know that we joined the cluster\n        logger.debug(\"Done joining the cluster. Now proceed informing other nodes that we joined the cluster.\");\n        CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n\n        logger.info(\"Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});\n        done = false;\n    }\n\n    boolean isSeniorClusterMember() {\n        // first cluster member is the oldest\n        final Iterator<Member> members = cluster.getMembers().iterator();\n        return members.next().getUuid().equals(cluster.getLocalMember().getUuid());\n    }\n\n    private synchronized void leaveCluster() {\n        if (isDone()) { // not a cluster member\n            return;\n        }\n        clusterMember = false;\n        final boolean wasSeniorClusterMember = seniorClusterMember;\n        seniorClusterMember = false;\n\n        // Trigger event. Wait until the listeners have processed the event. Caches will be populated\n        // again with local content.\n        ClusterManager.fireLeftCluster();\n\n        if (!XMPPServer.getInstance().isShuttingDown()) {\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        logger.info(\"Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});\n        done = true;\n    }\n\n    @Override\n    public void memberAdded(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberAdded event {}\", event);\n\n        final boolean wasSenior = isSenior;\n        isSenior = isSeniorClusterMember();\n        // local member only\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n        if (event.getMember().localMember()) { // We left and re-joined the cluster\n            joinCluster();\n\n        } else {\n            if (wasSenior && !isSenior) {\n                logger.warn(\"Recovering from split-brain; firing leftCluster()/joinedCluster() events\");\n                ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n                logger.debug(\"Firing joinedCluster() event\");\n                ClusterManager.fireJoinedCluster(false);\n\n                try {\n                    logger.debug(\"Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.\");\n                    Thread.sleep(30000L);\n                } catch (InterruptedException e) {\n                    logger.warn(\"30 Second wait was interrupted.\", e);\n                }\n\n                // The following line was intended to wait until all local handling finishes before informing other\n                // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.\n                // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.\n                waitForClusterCacheToBeInstalled();\n\n                // Let the other nodes know that we joined the cluster\n                logger.debug(\"Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.\");\n                CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n            }\n        }\n        clusterNodesInfo.put(nodeID,\n                new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));\n    }\n\n    /**\n     * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful\n     * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still\n     * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently\n     * discarded.\n     *\n     * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.\n     *\n     * @return Boolean indicating whether the clustered cache was actually observed to be installed.\n     */\n    private boolean waitForClusterCacheToBeInstalled() {\n        boolean failed = false;\n        if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {\n            logger.debug(\"This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.\", ClusteredCacheFactory.PLUGIN_NAME);\n            LocalTime deadLine = LocalTime.now().plusMinutes(10L);\n            while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    logger.trace(\"Thread was interrupted while waiting for cache strategy to change.\");\n                    failed = true;\n                    break;\n                }\n            }\n            if (!deadLine.isAfter(LocalTime.now())) {\n                failed = true;\n                logger.warn(\"Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.\", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());\n            }\n            logger.debug(\"Cache factory has been swapped to '{}'. Cluster join is considered complete.\", ClusteredCacheFactory.PLUGIN_NAME);\n        }\n\n        return !failed;\n    }\n\n    @Override\n    public void memberRemoved(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberRemoved event {}\", event);\n\n        isSenior = isSeniorClusterMember();\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n\n        if (event.getMember().localMember()) {\n            logger.info(\"Leaving cluster: \" + nodeID);\n            // This node may have realized that it got kicked out of the cluster\n            leaveCluster();\n        } else {\n            // Trigger event that a node left the cluster\n            ClusterManager.fireLeftCluster(nodeID.toByteArray());\n\n            if (!seniorClusterMember && isSeniorClusterMember()) {\n                seniorClusterMember = true;\n                ClusterManager.fireMarkedAsSeniorClusterMember();\n            }\n\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist.\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        // Delete nodeID instance (release from memory)\n        NodeID.deleteInstance(nodeID.toByteArray());\n        clusterNodesInfo.remove(nodeID);\n    }\n\n    \n    @SuppressWarnings(\"WeakerAccess\")\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return new ArrayList<>(clusterNodesInfo.values());\n    }\n\n    @Override\n    public void stateChanged(final LifecycleEvent event) {\n        if (event.getState().equals(LifecycleState.SHUTDOWN)) {\n            leaveCluster();\n        } else if (event.getState().equals(LifecycleState.STARTED)) {\n            joinCluster();\n        }\n    }\n\n    @Override\n    public void memberAttributeChanged(final MemberAttributeEvent event) {\n        logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);\n        isSenior = isSeniorClusterMember();\n        final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));\n        clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),\n                new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));\n    }\n\n    boolean isClusterMember() {\n        return clusterMember;\n    }\n}\n",
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.EntryEvent;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.MapEvent;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.map.LocalMapStats;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.container.PluginManager;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Clustered implementation of the Cache interface using Hazelcast.\n *\n */\npublic class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {\n\n    private final Logger logger;\n\n    private final Set<String> listeners = ConcurrentHashMap.newKeySet();\n\n    /**\n     * The map is used for distributed operations such as get, put, etc.\n     */\n    final IMap<K, V> map;\n    private String name;\n    private long numberOfGets = 0;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private Instant lastPluginClassLoaderWarning = Instant.EPOCH;\n    private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);\n\n    /**\n     * Create a new cache using the supplied named cache as the actual cache implementation\n     *\n     * @param name a name for the cache, which should be unique per vm.\n     * @param cache the cache implementation\n     */\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {\n        this.map = cache;\n        this.name = name;\n        logger = LoggerFactory.getLogger(ClusteredCache.class.getName() + \"[cache: \"+name+\"]\");\n    }\n\n    void addEntryListener(final MapListener listener) {\n        listeners.add(map.addEntryListener(listener, false));\n    }\n\n    @Override\n    public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)\n    {\n        final EntryListener<K, V> listener = new EntryListener<K, V>() {\n            @Override\n            public void mapEvicted(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map evicted event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapEvicted(eventNodeId);\n                }\n            }\n\n            @Override\n            public void mapCleared(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map cleared event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapCleared(eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryUpdated(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry update event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryRemoved(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry removed event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryRemoved((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry evicted event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryAdded(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry added event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryAdded((K) event.getKey(), (V) event.getValue(), eventNodeId);\n                }\n            }\n        };\n\n        final String listenerId = map.addEntryListener(listener, includeValues);\n        listeners.add(listenerId);\n        logger.debug(\"Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'\", includeValues, includeEventsFromLocalNode, listenerId);\n        return listenerId;\n    }\n\n    @Override\n    public void removeClusteredCacheEntryListener(@Nonnull final String listenerId) {\n        logger.debug(\"Removing clustered cache entry listener: '{}'\", listenerId);\n        map.removeEntryListener(listenerId);\n        listeners.remove(listenerId);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    @Override\n    public V put(final K key, final V object) {\n        if (object == null) { return null; }\n        checkForPluginClassLoader(key);\n        checkForPluginClassLoader(object);\n        return map.put(key, object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        numberOfGets++;\n        return map.get(key);\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public int size() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return (int) (stats.getOwnedEntryCount() + stats.getBackupEntryCount());\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return map.entrySet();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> entries) {\n        map.putAll(entries);\n\n        // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.\n        entries.entrySet().stream().findAny().ifPresent(\n            e -> {\n                checkForPluginClassLoader(e.getKey());\n                checkForPluginClassLoader(e.getValue());\n            }\n        );\n    }\n\n    @Override\n    public Collection<V> values() {\n        return map.values();\n    }\n\n    @Override\n    public long getCacheHits() {\n        return map.getLocalMapStats().getHits();\n    }\n\n    @Override\n    public long getCacheMisses() {\n        final long hits = map.getLocalMapStats().getHits();\n        return numberOfGets > hits ? numberOfGets - hits : 0;\n    }\n\n    @Override\n    public int getCacheSize() {\n        return (int) getLongCacheSize();\n    }\n\n    @Override\n    public long getLongCacheSize() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();\n    }\n\n    @Override\n    public long getMaxCacheSize() {\n        return CacheFactory.getMaxCacheSize(getName());\n    }\n\n    @Override\n    public void setMaxCacheSize(int i) {\n        setMaxCacheSize((long) i);\n    }\n\n    @Override\n    public void setMaxCacheSize(final long maxSize) {\n        CacheFactory.setMaxSizeProperty(getName(), maxSize);\n    }\n\n    @Override\n    public long getMaxLifetime() {\n        return CacheFactory.getMaxCacheLifetime(getName());\n    }\n\n    @Override\n    public void setMaxLifetime(final long maxLifetime) {\n        CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);\n    }\n\n    void destroy() {\n        listeners.forEach(map::removeEntryListener);\n        map.destroy();\n    }\n\n    boolean lock(final K key, final long timeout) {\n        boolean result = true;\n        if (timeout < 0) {\n            map.lock(key);\n        } else if (timeout == 0) {\n            result = map.tryLock(key);\n        } else {\n            try {\n                result = map.tryLock(key, timeout, TimeUnit.MILLISECONDS);\n            } catch (final InterruptedException e) {\n                logger.error(\"Failed to get cluster lock\", e);\n                result = false;\n            }\n        }\n        return result;\n    }\n\n    void unlock(final K key) {\n        try {\n            map.unlock(key);\n        } catch (final IllegalMonitorStateException e) {\n            logger.error(\"Failed to release cluster lock\", e);\n        }\n    }\n\n    /**\n     * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause\n     * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected void checkForPluginClassLoader(final Object o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is loaded by {} has been added to the cache. \" +\n                \"This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.\",\n                o.getClass(), pluginName != null ? pluginName : \"a PluginClassLoader\");\n            lastPluginClassLoaderWarning = Instant.now();\n        }\n    }\n}\n"
                },
                "compile_error_details": {
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java": {
                        "18": {
                            "lines": [
                                {
                                    "line_no": 17,
                                    "content": ""
                                },
                                {
                                    "line_no": 18,
                                    "content": "import com.hazelcast.core.Cluster;"
                                },
                                {
                                    "line_no": 19,
                                    "content": "import com.hazelcast.core.EntryListener;"
                                }
                            ],
                            "error_texts": [
                                "[18,26] cannot find symbol\n",
                                "[18,26] cannot find symbol\nsymbol: class Cluster\nlocation: package com.hazelcast.core\n"
                            ]
                        },
                        "24": {
                            "lines": [
                                {
                                    "line_no": 23,
                                    "content": "import com.hazelcast.cluster.Member;"
                                },
                                {
                                    "line_no": 24,
                                    "content": "import com.hazelcast.cluster.MemberAttributeEvent;"
                                },
                                {
                                    "line_no": 25,
                                    "content": "import com.hazelcast.cluster.MembershipEvent;"
                                }
                            ],
                            "error_texts": [
                                "[24,29] cannot find symbol\nsymbol: class MemberAttributeEvent\nlocation: package com.hazelcast.cluster\n",
                                "[24,29] cannot find symbol\n"
                            ]
                        },
                        "60": {
                            "lines": [
                                {
                                    "line_no": 59,
                                    "content": "    "
                                },
                                {
                                    "line_no": 60,
                                    "content": "    private final Cluster cluster;"
                                },
                                {
                                    "line_no": 61,
                                    "content": "    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();"
                                }
                            ],
                            "error_texts": [
                                "[60,19] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n",
                                "[60,19] cannot find symbol\n"
                            ]
                        },
                        "64": {
                            "lines": [
                                {
                                    "line_no": 63,
                                    "content": ""
                                },
                                {
                                    "line_no": 64,
                                    "content": "    private final Cluster cluster;"
                                },
                                {
                                    "line_no": 65,
                                    "content": "    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();"
                                }
                            ],
                            "error_texts": [
                                "[64,19] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n",
                                "[64,19] cannot find symbol\n"
                            ]
                        },
                        "65": {
                            "lines": [
                                {
                                    "line_no": 64,
                                    "content": "    private final Cluster cluster;"
                                },
                                {
                                    "line_no": 65,
                                    "content": "    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();"
                                },
                                {
                                    "line_no": 66,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[65,48] variable clusterNodesInfo is already defined in class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n"
                            ]
                        },
                        "79": {
                            "lines": [
                                {
                                    "line_no": 78,
                                    "content": ""
                                },
                                {
                                    "line_no": 79,
                                    "content": "    ClusterListener(final Cluster cluster) {"
                                },
                                {
                                    "line_no": 80,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[79,27] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n",
                                "[79,27] cannot find symbol\n"
                            ]
                        },
                        "276": {
                            "lines": [
                                {
                                    "line_no": 275,
                                    "content": "    @Override"
                                },
                                {
                                    "line_no": 276,
                                    "content": "    public void memberAttributeChanged(final MemberAttributeEvent event) {"
                                },
                                {
                                    "line_no": 277,
                                    "content": "        logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);"
                                }
                            ],
                            "error_texts": [
                                "[276,46] cannot find symbol\nsymbol: class MemberAttributeEvent\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n",
                                "[276,46] cannot find symbol\n"
                            ]
                        },
                        "275": {
                            "lines": [
                                {
                                    "line_no": 274,
                                    "content": ""
                                },
                                {
                                    "line_no": 275,
                                    "content": "    @Override"
                                },
                                {
                                    "line_no": 276,
                                    "content": "    public void memberAttributeChanged(final MemberAttributeEvent event) {"
                                }
                            ],
                            "error_texts": [
                                "[275,5] method does not override or implement a method from a supertype\n"
                            ]
                        }
                    },
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {
                        "500": {
                            "lines": [
                                {
                                    "line_no": 499,
                                    "content": ""
                                },
                                {
                                    "line_no": 500,
                                    "content": "    private Member getMember(final byte[] nodeID) {"
                                },
                                {
                                    "line_no": 501,
                                    "content": "        final NodeID memberToFind = NodeID.getInstance(nodeID);"
                                }
                            ],
                            "error_texts": [
                                "[500,13] cannot find symbol\nsymbol: class Member\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[500,13] cannot find symbol\n"
                            ]
                        },
                        "654": {
                            "lines": [
                                {
                                    "line_no": 653,
                                    "content": ""
                                },
                                {
                                    "line_no": 654,
                                    "content": "    public static NodeID getNodeID(final Member member) {"
                                },
                                {
                                    "line_no": 655,
                                    "content": "        return NodeID.getInstance(member.getAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));"
                                }
                            ],
                            "error_texts": [
                                "[654,42] cannot find symbol\nsymbol: class Member\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[654,42] cannot find symbol\n"
                            ]
                        },
                        "190": {
                            "lines": [
                                {
                                    "line_no": 189,
                                    "content": "                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();"
                                },
                                {
                                    "line_no": 190,
                                    "content": "                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());"
                                },
                                {
                                    "line_no": 191,
                                    "content": "                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());"
                                }
                            ],
                            "error_texts": [
                                "[190,38] cannot find symbol\nsymbol: method setStringAttribute(java.lang.String,java.lang.String)\nlocation: variable memberAttributeConfig of type com.hazelcast.config.MemberAttributeConfig\n",
                                "[190,38] cannot find symbol\n"
                            ]
                        },
                        "191": {
                            "lines": [
                                {
                                    "line_no": 190,
                                    "content": "                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());"
                                },
                                {
                                    "line_no": 191,
                                    "content": "                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());"
                                },
                                {
                                    "line_no": 192,
                                    "content": "                config.setInstanceName(\"openfire\");"
                                }
                            ],
                            "error_texts": [
                                "[191,38] cannot find symbol\nsymbol: method setStringAttribute(java.lang.String,java.lang.String)\nlocation: variable memberAttributeConfig of type com.hazelcast.config.MemberAttributeConfig\n",
                                "[191,38] cannot find symbol\n"
                            ]
                        },
                        "199": {
                            "lines": [
                                {
                                    "line_no": 198,
                                    "content": "                hazelcast = Hazelcast.newHazelcastInstance(config);"
                                },
                                {
                                    "line_no": 199,
                                    "content": "                Cluster cluster = hazelcast.getCluster();"
                                },
                                {
                                    "line_no": 200,
                                    "content": "                state = State.started;"
                                }
                            ],
                            "error_texts": [
                                "[199,17] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[199,17] cannot find symbol\n"
                            ]
                        },
                        "204": {
                            "lines": [
                                {
                                    "line_no": 203,
                                    "content": "                clusterListener.joinCluster();"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);"
                                },
                                {
                                    "line_no": 205,
                                    "content": "                membershipListener = cluster.addMembershipListener(clusterListener);"
                                }
                            ],
                            "error_texts": [
                                "[204,89] incompatible types: java.util.UUID cannot be converted to java.lang.String\n"
                            ]
                        },
                        "209": {
                            "lines": [
                                {
                                    "line_no": 208,
                                    "content": "            } catch (final Exception e) {"
                                },
                                {
                                    "line_no": 209,
                                    "content": "                cluster = null;"
                                },
                                {
                                    "line_no": 210,
                                    "content": "                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {"
                                }
                            ],
                            "error_texts": [
                                "[209,17] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[209,17] cannot find symbol\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "        }"
                                },
                                {
                                    "line_no": 229,
                                    "content": "        return cluster != null;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[229,16] cannot find symbol\n",
                                "[229,16] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "243": {
                            "lines": [
                                {
                                    "line_no": 242,
                                    "content": "        // Stop the cluster"
                                },
                                {
                                    "line_no": 243,
                                    "content": "        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);"
                                },
                                {
                                    "line_no": 244,
                                    "content": "        cluster.removeMembershipListener(membershipListener);"
                                }
                            ],
                            "error_texts": [
                                "[243,65] incompatible types: java.lang.String cannot be converted to java.util.UUID\n"
                            ]
                        },
                        "244": {
                            "lines": [
                                {
                                    "line_no": 243,
                                    "content": "        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);"
                                },
                                {
                                    "line_no": 244,
                                    "content": "        cluster.removeMembershipListener(membershipListener);"
                                },
                                {
                                    "line_no": 245,
                                    "content": "        Hazelcast.shutdownAll();"
                                }
                            ],
                            "error_texts": [
                                "[244,9] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[244,9] cannot find symbol\n"
                            ]
                        },
                        "246": {
                            "lines": [
                                {
                                    "line_no": 245,
                                    "content": "        Hazelcast.shutdownAll();"
                                },
                                {
                                    "line_no": 246,
                                    "content": "        cluster = null;"
                                },
                                {
                                    "line_no": 247,
                                    "content": "        lifecycleListener = null;"
                                }
                            ],
                            "error_texts": [
                                "[246,9] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[246,9] cannot find symbol\n"
                            ]
                        },
                        "284": {
                            "lines": [
                                {
                                    "line_no": 283,
                                    "content": "            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);"
                                },
                                {
                                    "line_no": 284,
                                    "content": "            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));"
                                },
                                {
                                    "line_no": 285,
                                    "content": "            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);"
                                }
                            ],
                            "error_texts": [
                                "[284,48] cannot find symbol\nsymbol: class MaxSizeConfig\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[284,48] cannot find symbol\n",
                                "[284,109] package MaxSizeConfig does not exist\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "    public byte[] getSeniorClusterMemberID() {"
                                },
                                {
                                    "line_no": 326,
                                    "content": "        Cluster cluster = hazelcast.getCluster();"
                                },
                                {
                                    "line_no": 327,
                                    "content": "        if (cluster != null && !cluster.getMembers().isEmpty()) {"
                                }
                            ],
                            "error_texts": [
                                "[326,9] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[326,9] cannot find symbol\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "    public byte[] getClusterMemberID() {"
                                },
                                {
                                    "line_no": 337,
                                    "content": "        Cluster cluster = hazelcast.getCluster();"
                                },
                                {
                                    "line_no": 338,
                                    "content": "        if (cluster != null) {"
                                }
                            ],
                            "error_texts": [
                                "[337,9] cannot find symbol\n",
                                "[337,9] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "354": {
                            "lines": [
                                {
                                    "line_no": 353,
                                    "content": "    public long getClusterTime() {"
                                },
                                {
                                    "line_no": 354,
                                    "content": "        Cluster cluster = hazelcast.getCluster();"
                                },
                                {
                                    "line_no": 355,
                                    "content": "        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();"
                                }
                            ],
                            "error_texts": [
                                "[354,9] cannot find symbol\nsymbol: class Cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[354,9] cannot find symbol\n"
                            ]
                        },
                        "366": {
                            "lines": [
                                {
                                    "line_no": 365,
                                    "content": ""
                                },
                                {
                                    "line_no": 366,
                                    "content": "        if (cluster == null) {"
                                },
                                {
                                    "line_no": 367,
                                    "content": "            return;"
                                }
                            ],
                            "error_texts": [
                                "[366,13] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[366,13] cannot find symbol\n"
                            ]
                        },
                        "370": {
                            "lines": [
                                {
                                    "line_no": 369,
                                    "content": "        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();"
                                },
                                {
                                    "line_no": 370,
                                    "content": "        final com.hazelcast.cluster.Member current = cluster.getLocalMember();"
                                },
                                {
                                    "line_no": 371,
                                    "content": "        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {"
                                }
                            ],
                            "error_texts": [
                                "[370,54] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[370,54] cannot find symbol\n"
                            ]
                        },
                        "371": {
                            "lines": [
                                {
                                    "line_no": 370,
                                    "content": "        final com.hazelcast.cluster.Member current = cluster.getLocalMember();"
                                },
                                {
                                    "line_no": 371,
                                    "content": "        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {"
                                },
                                {
                                    "line_no": 372,
                                    "content": "            if (!member.getUuid().equals(current.getUuid())) {"
                                }
                            ],
                            "error_texts": [
                                "[371,58] cannot find symbol\n",
                                "[371,58] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "395": {
                            "lines": [
                                {
                                    "line_no": 394,
                                    "content": "    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {"
                                },
                                {
                                    "line_no": 395,
                                    "content": "        if (cluster == null) {"
                                },
                                {
                                    "line_no": 396,
                                    "content": "            return;"
                                }
                            ],
                            "error_texts": [
                                "[395,13] cannot find symbol\n",
                                "[395,13] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "419": {
                            "lines": [
                                {
                                    "line_no": 418,
                                    "content": "    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {"
                                },
                                {
                                    "line_no": 419,
                                    "content": "        if (cluster == null) {"
                                },
                                {
                                    "line_no": 420,
                                    "content": "            return Collections.emptyList();"
                                }
                            ],
                            "error_texts": [
                                "[419,13] cannot find symbol\n",
                                "[419,13] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "423": {
                            "lines": [
                                {
                                    "line_no": 422,
                                    "content": "        final Set<com.hazelcast.cluster.Member> members = new HashSet<>();"
                                },
                                {
                                    "line_no": 423,
                                    "content": "        final com.hazelcast.cluster.Member current = cluster.getLocalMember();"
                                },
                                {
                                    "line_no": 424,
                                    "content": "        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {"
                                }
                            ],
                            "error_texts": [
                                "[423,54] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[423,54] cannot find symbol\n"
                            ]
                        },
                        "424": {
                            "lines": [
                                {
                                    "line_no": 423,
                                    "content": "        final com.hazelcast.cluster.Member current = cluster.getLocalMember();"
                                },
                                {
                                    "line_no": 424,
                                    "content": "        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {"
                                },
                                {
                                    "line_no": 425,
                                    "content": "            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {"
                                }
                            ],
                            "error_texts": [
                                "[424,58] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[424,58] cannot find symbol\n"
                            ]
                        },
                        "435": {
                            "lines": [
                                {
                                    "line_no": 434,
                                    "content": "                checkForPluginClassLoader(task);"
                                },
                                {
                                    "line_no": 435,
                                    "content": "                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);"
                                },
                                {
                                    "line_no": 436,
                                    "content": "                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());"
                                }
                            ],
                            "error_texts": [
                                "[435,27] cannot find symbol\nsymbol: class Member\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[435,27] cannot find symbol\n"
                            ]
                        },
                        "460": {
                            "lines": [
                                {
                                    "line_no": 459,
                                    "content": "    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {"
                                },
                                {
                                    "line_no": 460,
                                    "content": "        if (cluster == null) {"
                                },
                                {
                                    "line_no": 461,
                                    "content": "            return null;"
                                }
                            ],
                            "error_texts": [
                                "[460,13] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[460,13] cannot find symbol\n"
                            ]
                        },
                        "489": {
                            "lines": [
                                {
                                    "line_no": 488,
                                    "content": "    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {"
                                },
                                {
                                    "line_no": 489,
                                    "content": "        if (cluster == null) {"
                                },
                                {
                                    "line_no": 490,
                                    "content": "            return null;"
                                }
                            ],
                            "error_texts": [
                                "[489,13] cannot find symbol\n",
                                "[489,13] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "495": {
                            "lines": [
                                {
                                    "line_no": 494,
                                    "content": "        if (member != null) {"
                                },
                                {
                                    "line_no": 495,
                                    "content": "            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());"
                                },
                                {
                                    "line_no": 496,
                                    "content": "        }"
                                }
                            ],
                            "error_texts": [
                                "[495,59] cannot find symbol\n",
                                "[495,59] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "502": {
                            "lines": [
                                {
                                    "line_no": 501,
                                    "content": "        final NodeID memberToFind = NodeID.getInstance(nodeID);"
                                },
                                {
                                    "line_no": 502,
                                    "content": "        for (final com.hazelcast.cluster.Member member : cluster.getMembers()) {"
                                },
                                {
                                    "line_no": 503,
                                    "content": "            if (memberToFind.equals(getNodeID(member))) {"
                                }
                            ],
                            "error_texts": [
                                "[502,58] cannot find symbol\n",
                                "[502,58] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        },
                        "512": {
                            "lines": [
                                {
                                    "line_no": 511,
                                    "content": "    public void updateCacheStats(final Map<String, Cache> caches) {"
                                },
                                {
                                    "line_no": 512,
                                    "content": "        if (!caches.isEmpty() && cluster != null) {"
                                },
                                {
                                    "line_no": 513,
                                    "content": "            // Create the cacheStats map if necessary."
                                }
                            ],
                            "error_texts": [
                                "[512,34] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n",
                                "[512,34] cannot find symbol\n"
                            ]
                        },
                        "517": {
                            "lines": [
                                {
                                    "line_no": 516,
                                    "content": "            }"
                                },
                                {
                                    "line_no": 517,
                                    "content": "            final String uid = getNodeID(cluster.getLocalMember()).toString();"
                                },
                                {
                                    "line_no": 518,
                                    "content": "            final Map<String, long[]> stats = new HashMap<>();"
                                }
                            ],
                            "error_texts": [
                                "[517,42] cannot find symbol\n",
                                "[517,42] cannot find symbol\nsymbol: variable cluster\nlocation: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n"
                            ]
                        }
                    },
                    "src/java/org/jivesoftware/openfire/plugin/util/cluster/HazelcastClusterNodeInfo.java": {
                        "24": {
                            "lines": [
                                {
                                    "line_no": 23,
                                    "content": ""
                                },
                                {
                                    "line_no": 24,
                                    "content": "import com.hazelcast.core.Member;"
                                },
                                {
                                    "line_no": 25,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[24,26] cannot find symbol\n",
                                "[24,26] cannot find symbol\nsymbol: class Member\nlocation: package com.hazelcast.core\n"
                            ]
                        },
                        "41": {
                            "lines": [
                                {
                                    "line_no": 40,
                                    "content": ""
                                },
                                {
                                    "line_no": 41,
                                    "content": "    public HazelcastClusterNodeInfo(final Member member, final long joinedTime) {"
                                },
                                {
                                    "line_no": 42,
                                    "content": "        this.hostname = member.getStringAttribute(HOST_NAME_ATTRIBUTE) + \" (\" + member.getSocketAddress().getHostString() + \")\";"
                                }
                            ],
                            "error_texts": [
                                "[41,43] cannot find symbol\n",
                                "[41,43] cannot find symbol\nsymbol: class Member\nlocation: class org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo\n"
                            ]
                        }
                    },
                    "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java": {
                        "81": {
                            "lines": [
                                {
                                    "line_no": 80,
                                    "content": "    void addEntryListener(final MapListener listener) {"
                                },
                                {
                                    "line_no": 81,
                                    "content": "        listeners.add(map.addEntryListener(listener, false));"
                                },
                                {
                                    "line_no": 82,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[81,43] incompatible types: java.util.UUID cannot be converted to java.lang.String\n"
                            ]
                        },
                        "87": {
                            "lines": [
                                {
                                    "line_no": 86,
                                    "content": "    {"
                                },
                                {
                                    "line_no": 87,
                                    "content": "        final EntryListener<K, V> listener = new EntryListener<K, V>() {"
                                },
                                {
                                    "line_no": 88,
                                    "content": "            @Override"
                                }
                            ],
                            "error_texts": [
                                "[87,72] <anonymous org.jivesoftware.openfire.plugin.util.cache.ClusteredCache$1> is not abstract and does not override abstract method entryExpired(com.hazelcast.core.EntryEvent<K,V>) in com.hazelcast.map.listener.EntryExpiredListener\n"
                            ]
                        },
                        "143": {
                            "lines": [
                                {
                                    "line_no": 142,
                                    "content": ""
                                },
                                {
                                    "line_no": 143,
                                    "content": "        final String listenerId = map.addEntryListener(listener, includeValues);"
                                },
                                {
                                    "line_no": 144,
                                    "content": "        listeners.add(listenerId);"
                                }
                            ],
                            "error_texts": [
                                "[143,55] incompatible types: java.util.UUID cannot be converted to java.lang.String\n"
                            ]
                        },
                        "152": {
                            "lines": [
                                {
                                    "line_no": 151,
                                    "content": "        logger.debug(\"Removing clustered cache entry listener: '{}'\", listenerId);"
                                },
                                {
                                    "line_no": 152,
                                    "content": "        map.removeEntryListener(listenerId);"
                                },
                                {
                                    "line_no": 153,
                                    "content": "        listeners.remove(listenerId);"
                                }
                            ],
                            "error_texts": [
                                "[152,33] incompatible types: java.lang.String cannot be converted to java.util.UUID\n"
                            ]
                        },
                        "287": {
                            "lines": [
                                {
                                    "line_no": 286,
                                    "content": "    void destroy() {"
                                },
                                {
                                    "line_no": 287,
                                    "content": "        listeners.forEach(map::removeEntryListener);"
                                },
                                {
                                    "line_no": 288,
                                    "content": "        map.destroy();"
                                }
                            ],
                            "error_texts": [
                                "[287,27] incompatible types: invalid method reference\n",
                                "[287,27] incompatible types: invalid method reference\nincompatible types: java.lang.String cannot be converted to java.util.UUID\n"
                            ]
                        }
                    }
                }
            },
            "error": "incompatible types: invalid method reference\n",
            "span_id": 988442021437706841
        }
    ],
    "read_file": [
        {
            "input": "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java",
            "output": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.LifecycleEvent;\nimport com.hazelcast.core.LifecycleEvent.LifecycleState;\nimport com.hazelcast.core.LifecycleListener;\nimport com.hazelcast.core.Member;\nimport com.hazelcast.core.MemberAttributeEvent;\nimport com.hazelcast.core.MembershipEvent;\nimport com.hazelcast.core.MembershipListener;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state\n * of the routing table and the sessions within it when a node which manages those sessions goes down.\n */\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);\n\n    private boolean seniorClusterMember = false;\n\n    private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();\n    \n    private final Cluster cluster;\n    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n    \n    /**\n     * Flag that indicates if the listener has done all clean up work when noticed that the\n     * cluster has been stopped. This will force Openfire to wait until all clean\n     * up (e.g. changing caches implementations) is done before destroying the plugin.\n     */\n    private boolean done = true;\n    /**\n     * Flag that indicates if we've joined a cluster or not\n     */\n    private boolean clusterMember = false;\n    private boolean isSenior;\n\n    ClusterListener(final Cluster cluster) {\n\n        this.cluster = cluster;\n        for (final Member member : cluster.getMembers()) {\n            clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),\n                    new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));\n        }\n    }\n\n    private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {\n        if (cache instanceof CacheWrapper) {\n            final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();\n            if (wrapped instanceof ClusteredCache) {\n                ((ClusteredCache)wrapped).addEntryListener(listener);\n                // Keep track of the listener that we added to the cache\n                entryListeners.put(cache, listener);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private boolean isDone() {\n        return done;\n    }\n\n    synchronized void joinCluster() {\n        if (!isDone()) { // already joined\n            return;\n        }\n\n        // Trigger events\n        clusterMember = true;\n        seniorClusterMember = isSeniorClusterMember();\n\n        ClusterManager.fireJoinedCluster(false);\n\n        if (seniorClusterMember) {\n            ClusterManager.fireMarkedAsSeniorClusterMember();\n        }\n\n        waitForClusterCacheToBeInstalled();\n\n        // Let the other nodes know that we joined the cluster\n        logger.debug(\"Done joining the cluster. Now proceed informing other nodes that we joined the cluster.\");\n        CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n\n        logger.info(\"Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});\n        done = false;\n    }\n\n    boolean isSeniorClusterMember() {\n        // first cluster member is the oldest\n        final Iterator<Member> members = cluster.getMembers().iterator();\n        return members.next().getUuid().equals(cluster.getLocalMember().getUuid());\n    }\n\n    private synchronized void leaveCluster() {\n        if (isDone()) { // not a cluster member\n            return;\n        }\n        clusterMember = false;\n        final boolean wasSeniorClusterMember = seniorClusterMember;\n        seniorClusterMember = false;\n\n        // Trigger event. Wait until the listeners have processed the event. Caches will be populated\n        // again with local content.\n        ClusterManager.fireLeftCluster();\n\n        if (!XMPPServer.getInstance().isShuttingDown()) {\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        logger.info(\"Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});\n        done = true;\n    }\n\n    @Override\n    public void memberAdded(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberAdded event {}\", event);\n\n        final boolean wasSenior = isSenior;\n        isSenior = isSeniorClusterMember();\n        // local member only\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n        if (event.getMember().localMember()) { // We left and re-joined the cluster\n            joinCluster();\n\n        } else {\n            if (wasSenior && !isSenior) {\n                logger.warn(\"Recovering from split-brain; firing leftCluster()/joinedCluster() events\");\n                ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n                logger.debug(\"Firing joinedCluster() event\");\n                ClusterManager.fireJoinedCluster(false);\n\n                try {\n                    logger.debug(\"Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.\");\n                    Thread.sleep(30000L);\n                } catch (InterruptedException e) {\n                    logger.warn(\"30 Second wait was interrupted.\", e);\n                }\n\n                // The following line was intended to wait until all local handling finishes before informing other\n                // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.\n                // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.\n                waitForClusterCacheToBeInstalled();\n\n                // Let the other nodes know that we joined the cluster\n                logger.debug(\"Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.\");\n                CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n            }\n        }\n        clusterNodesInfo.put(nodeID,\n                new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));\n    }\n\n    /**\n     * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful\n     * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still\n     * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently\n     * discarded.\n     *\n     * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.\n     *\n     * @return Boolean indicating whether the clustered cache was actually observed to be installed.\n     */\n    private boolean waitForClusterCacheToBeInstalled() {\n        boolean failed = false;\n        if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {\n            logger.debug(\"This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.\", ClusteredCacheFactory.PLUGIN_NAME);\n            LocalTime deadLine = LocalTime.now().plusMinutes(10L);\n            while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    logger.trace(\"Thread was interrupted while waiting for cache strategy to change.\");\n                    failed = true;\n                    break;\n                }\n            }\n            if (!deadLine.isAfter(LocalTime.now())) {\n                failed = true;\n                logger.warn(\"Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.\", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());\n            }\n            logger.debug(\"Cache factory has been swapped to '{}'. Cluster join is considered complete.\", ClusteredCacheFactory.PLUGIN_NAME);\n        }\n\n        return !failed;\n    }\n\n    @Override\n    public void memberRemoved(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberRemoved event {}\", event);\n\n        isSenior = isSeniorClusterMember();\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n\n        if (event.getMember().localMember()) {\n            logger.info(\"Leaving cluster: \" + nodeID);\n            // This node may have realized that it got kicked out of the cluster\n            leaveCluster();\n        } else {\n            // Trigger event that a node left the cluster\n            ClusterManager.fireLeftCluster(nodeID.toByteArray());\n\n            if (!seniorClusterMember && isSeniorClusterMember()) {\n                seniorClusterMember = true;\n                ClusterManager.fireMarkedAsSeniorClusterMember();\n            }\n\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist.\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        // Delete nodeID instance (release from memory)\n        NodeID.deleteInstance(nodeID.toByteArray());\n        clusterNodesInfo.remove(nodeID);\n    }\n    \n    @SuppressWarnings(\"WeakerAccess\")\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return new ArrayList<>(clusterNodesInfo.values());\n    }\n\n    @Override\n    public void stateChanged(final LifecycleEvent event) {\n        if (event.getState().equals(LifecycleState.SHUTDOWN)) {\n            leaveCluster();\n        } else if (event.getState().equals(LifecycleState.STARTED)) {\n            joinCluster();\n        }\n    }\n\n    @Override\n    public void memberAttributeChanged(final MemberAttributeEvent event) {\n        logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);\n        isSenior = isSeniorClusterMember();\n        final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));\n        clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),\n                new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));\n    }\n\n    boolean isClusterMember() {\n        return clusterMember;\n    }\n}\n",
            "error": "",
            "span_id": 8831216059792605471
        },
        {
            "input": "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java",
            "output": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MaxSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\n",
            "error": "",
            "span_id": 4774375537159363358
        },
        {
            "input": "src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java",
            "output": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.EntryEvent;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.IMap;\nimport com.hazelcast.core.MapEvent;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.container.PluginManager;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Clustered implementation of the Cache interface using Hazelcast.\n *\n */\npublic class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {\n\n    private final Logger logger;\n\n    private final Set<String> listeners = ConcurrentHashMap.newKeySet();\n\n    /**\n     * The map is used for distributed operations such as get, put, etc.\n     */\n    final IMap<K, V> map;\n    private String name;\n    private long numberOfGets = 0;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private Instant lastPluginClassLoaderWarning = Instant.EPOCH;\n    private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);\n\n    /**\n     * Create a new cache using the supplied named cache as the actual cache implementation\n     *\n     * @param name a name for the cache, which should be unique per vm.\n     * @param cache the cache implementation\n     */\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {\n        this.map = cache;\n        this.name = name;\n        logger = LoggerFactory.getLogger(ClusteredCache.class.getName() + \"[cache: \"+name+\"]\");\n    }\n\n    void addEntryListener(final MapListener listener) {\n        listeners.add(map.addEntryListener(listener, false));\n    }\n\n    @Override\n    public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)\n    {\n        final EntryListener<K, V> listener = new EntryListener<K, V>() {\n            @Override\n            public void mapEvicted(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map evicted event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapEvicted(eventNodeId);\n                }\n            }\n\n            @Override\n            public void mapCleared(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map cleared event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapCleared(eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryUpdated(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry update event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryRemoved(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry removed event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryRemoved((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry evicted event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryAdded(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry added event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryAdded((K) event.getKey(), (V) event.getValue(), eventNodeId);\n                }\n            }\n        };\n\n        final String listenerId = map.addEntryListener(listener, includeValues);\n        listeners.add(listenerId);\n        logger.debug(\"Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'\", includeValues, includeEventsFromLocalNode, listenerId);\n        return listenerId;\n    }\n\n    @Override\n    public void removeClusteredCacheEntryListener(@Nonnull final String listenerId) {\n        logger.debug(\"Removing clustered cache entry listener: '{}'\", listenerId);\n        map.removeEntryListener(listenerId);\n        listeners.remove(listenerId);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    @Override\n    public V put(final K key, final V object) {\n        if (object == null) { return null; }\n        checkForPluginClassLoader(key);\n        checkForPluginClassLoader(object);\n        return map.put(key, object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        numberOfGets++;\n        return map.get(key);\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public int size() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return (int) (stats.getOwnedEntryCount() + stats.getBackupEntryCount());\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return map.entrySet();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> entries) {\n        map.putAll(entries);\n\n        // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.\n        entries.entrySet().stream().findAny().ifPresent(\n            e -> {\n                checkForPluginClassLoader(e.getKey());\n                checkForPluginClassLoader(e.getValue());\n            }\n        );\n    }\n\n    @Override\n    public Collection<V> values() {\n        return map.values();\n    }\n\n    @Override\n    public long getCacheHits() {\n        return map.getLocalMapStats().getHits();\n    }\n\n    @Override\n    public long getCacheMisses() {\n        final long hits = map.getLocalMapStats().getHits();\n        return numberOfGets > hits ? numberOfGets - hits : 0;\n    }\n\n    @Override\n    public int getCacheSize() {\n        return (int) getLongCacheSize();\n    }\n\n    @Override\n    public long getLongCacheSize() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();\n    }\n\n    @Override\n    public long getMaxCacheSize() {\n        return CacheFactory.getMaxCacheSize(getName());\n    }\n\n    @Override\n    public void setMaxCacheSize(int i) {\n        setMaxCacheSize((long) i);\n    }\n\n    @Override\n    public void setMaxCacheSize(final long maxSize) {\n        CacheFactory.setMaxSizeProperty(getName(), maxSize);\n    }\n\n    @Override\n    public long getMaxLifetime() {\n        return CacheFactory.getMaxCacheLifetime(getName());\n    }\n\n    @Override\n    public void setMaxLifetime(final long maxLifetime) {\n        CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);\n    }\n\n    void destroy() {\n        listeners.forEach(map::removeEntryListener);\n        map.destroy();\n    }\n\n    boolean lock(final K key, final long timeout) {\n        boolean result = true;\n        if (timeout < 0) {\n            map.lock(key);\n        } else if (timeout == 0) {\n            result = map.tryLock(key);\n        } else {\n            try {\n                result = map.tryLock(key, timeout, TimeUnit.MILLISECONDS);\n            } catch (final InterruptedException e) {\n                logger.error(\"Failed to get cluster lock\", e);\n                result = false;\n            }\n        }\n        return result;\n    }\n\n    void unlock(final K key) {\n        try {\n            map.unlock(key);\n        } catch (final IllegalMonitorStateException e) {\n            logger.error(\"Failed to release cluster lock\", e);\n        }\n    }\n\n    /**\n     * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause\n     * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected void checkForPluginClassLoader(final Object o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is loaded by {} has been added to the cache. \" +\n                \"This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.\",\n                o.getClass(), pluginName != null ? pluginName : \"a PluginClassLoader\");\n            lastPluginClassLoaderWarning = Instant.now();\n        }\n    }\n}\n",
            "error": "",
            "span_id": 12883935049023773970
        }
    ],
    "get_directory_tree": [
        {
            "input": "src/java/org/jivesoftware/openfire/plugin/util/cache",
            "output": "[\n    {\n        \"name\": \"ClusterClassLoader.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ClusteredCache.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ClusterExternalizableUtil.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ClusterListener.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ClusteredCacheFactory.java\",\n        \"type\": \"file\"\n    }\n]",
            "error": "",
            "span_id": 9423996384442830008
        }
    ],
    "get_language_server_suggestions": [],
    "reset_repo": []
}