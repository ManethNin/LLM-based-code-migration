diff --git a/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java b/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
index 2bc522a..8e0aea5 100644
--- a/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ b/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -19,15 +19,15 @@ package org.jivesoftware.openfire.plugin.util.cache;
 import com.hazelcast.config.ClasspathXmlConfig;
 import com.hazelcast.config.Config;
 import com.hazelcast.config.MapConfig;
-import com.hazelcast.config.MaxSizeConfig;
+import com.hazelcast.config.MaxSizeMaxWeightPolicy;
 import com.hazelcast.config.MemberAttributeConfig;
 import com.hazelcast.config.MemcacheProtocolConfig;
 import com.hazelcast.config.NetworkConfig;
 import com.hazelcast.config.RestApiConfig;
-import com.hazelcast.core.Cluster;
+import com.hazelcast.cluster.Cluster;
 import com.hazelcast.core.Hazelcast;
 import com.hazelcast.core.HazelcastInstance;
-import com.hazelcast.core.Member;
+import com.hazelcast.cluster.Member;
 import org.jivesoftware.openfire.JMXManager;
 import org.jivesoftware.openfire.XMPPServer;
 import org.jivesoftware.openfire.cluster.ClusterEventListener;
@@ -238,7 +238,7 @@ public class ClusteredCacheFactory implements CacheFactoryStrategy {
         // Stop the cache services.
         cacheStats = null;
         // Update the running state of the cluster
-        state = State.stopped;
+                    state = State.stopped;
 
         // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
         // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
@@ -247,7 +247,7 @@ public class ClusteredCacheFactory implements CacheFactoryStrategy {
         hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);
         cluster.removeMembershipListener(membershipListener);
         Hazelcast.shutdownAll();
-        cluster = null;
+                cluster = null;
         lifecycleListener = null;
         membershipListener = null;
         clusterListener = null;
@@ -432,7 +432,7 @@ public class ClusteredCacheFactory implements CacheFactoryStrategy {
             // Asynchronously execute the task on the other cluster members
             try {
                 logger.debug("Executing MultiTask: " + task.getClass().getName());
-                checkForPluginClassLoader(task);
+            checkForPluginClassLoader(task);
                 final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
                 long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());
                 for (final Future<T> future : futures.values()) {
@@ -505,7 +505,7 @@ public class ClusteredCacheFactory implements CacheFactoryStrategy {
                 return member;
             }
         }
-        return null;
+            return null;
     }
 
     @Override
@@ -690,14 +690,11 @@ public class ClusteredCacheFactory implements CacheFactoryStrategy {
             if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
             }
-        } catch (final Exception e) {
+            } catch (final Exception e) {
             logger.error("Unexpected exception waiting for clustering to shut down", e);
         } finally {
             ClusterManager.removeListener(clusterEventListener);
         }
     }
 
-}
-
-
-
+}
\ No newline at end of file