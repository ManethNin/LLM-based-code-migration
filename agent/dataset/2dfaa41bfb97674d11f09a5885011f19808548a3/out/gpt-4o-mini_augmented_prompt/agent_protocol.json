{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "        when(result.unwrap(any(Class.class)))"
                                },
                                {
                                    "line_no": 318,
                                    "content": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));"
                                },
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                }
                            ],
                            "error_texts": [
                                "[318,49] cannot find symbol\n",
                                "[318,49] cannot find symbol\nsymbol: method getArgumentAt(int,java.lang.Class<java.lang.Class>)\nlocation: variable invocation of type org.mockito.invocation.InvocationOnMock\n"
                            ]
                        },
                        "320": {
                            "lines": [
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                },
                                {
                                    "line_no": 320,
                                    "content": "        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));"
                                },
                                {
                                    "line_no": 321,
                                    "content": "        return result;"
                                }
                            ],
                            "error_texts": [
                                "[320,89] cannot find symbol\nsymbol: method cast(java.lang.Class<jakarta.validation.metadata.ConstraintDescriptor>)\nlocation: interface jakarta.validation.metadata.ConstraintDescriptor<capture#1 of ?>\n",
                                "[320,89] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 10119010124794418740
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "        when(result.unwrap(any(Class.class)))"
                                },
                                {
                                    "line_no": 318,
                                    "content": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));"
                                },
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                }
                            ],
                            "error_texts": [
                                "[318,49] cannot find symbol\n",
                                "[318,49] cannot find symbol\nsymbol: method getArgumentAt(int,java.lang.Class<java.lang.Class>)\nlocation: variable invocation of type org.mockito.invocation.InvocationOnMock\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 13057288985281343004
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "        when(result.unwrap(any(Class.class)))"
                                },
                                {
                                    "line_no": 318,
                                    "content": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));"
                                },
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                }
                            ],
                            "error_texts": [
                                "[318,49] cannot find symbol\n",
                                "[318,49] cannot find symbol\nsymbol: method getArgumentAt(int,java.lang.Class<java.lang.Class>)\nlocation: variable invocation of type org.mockito.invocation.InvocationOnMock\n"
                            ]
                        },
                        "320": {
                            "lines": [
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                },
                                {
                                    "line_no": 320,
                                    "content": "        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));"
                                },
                                {
                                    "line_no": 321,
                                    "content": "        return result;"
                                }
                            ],
                            "error_texts": [
                                "[320,89] cannot find symbol\nsymbol: method cast(java.lang.Class<jakarta.validation.metadata.ConstraintDescriptor>)\nlocation: interface jakarta.validation.metadata.ConstraintDescriptor<capture#1 of ?>\n",
                                "[320,89] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 13987441620868055120
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "        when(result.unwrap(any(Class.class)))"
                                },
                                {
                                    "line_no": 318,
                                    "content": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));"
                                },
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                }
                            ],
                            "error_texts": [
                                "[318,49] cannot find symbol\n",
                                "[318,49] cannot find symbol\nsymbol: method getArgumentAt(int,java.lang.Class<java.lang.Class>)\nlocation: variable invocation of type org.mockito.invocation.InvocationOnMock\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 836924851133174270
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "        when(result.unwrap(any(Class.class)))"
                                },
                                {
                                    "line_no": 318,
                                    "content": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));"
                                },
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                }
                            ],
                            "error_texts": [
                                "[318,49] cannot find symbol\n",
                                "[318,49] cannot find symbol\nsymbol: method getArgumentAt(int,java.lang.Class<java.lang.Class>)\nlocation: variable invocation of type org.mockito.invocation.InvocationOnMock\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 295591227825267147
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "320": {
                            "lines": [
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                },
                                {
                                    "line_no": 320,
                                    "content": "-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));"
                                },
                                {
                                    "line_no": 321,
                                    "content": "+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                }
                            ],
                            "error_texts": [
                                "[320,1] not a statement\n"
                            ]
                        },
                        "321": {
                            "lines": [
                                {
                                    "line_no": 320,
                                    "content": "-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));"
                                },
                                {
                                    "line_no": 321,
                                    "content": "+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                },
                                {
                                    "line_no": 322,
                                    "content": "        return result;"
                                }
                            ],
                            "error_texts": [
                                "[321,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 1768605591410429893
        },
        {
            "input": "```diff\n--- bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n+++ bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java\n@@ -318,7 +318,7 @@\n         when(result.unwrap(any(Class.class)))\n             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n         when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n         return result;\n     }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "not a statement\n",
                "updated_files": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n"
                },
                "compile_error_details": {
                    "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java": {
                        "320": {
                            "lines": [
                                {
                                    "line_no": 319,
                                    "content": "        when(result.getValidatedValue()).thenReturn(validatedValue);"
                                },
                                {
                                    "line_no": 320,
                                    "content": "-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                },
                                {
                                    "line_no": 321,
                                    "content": "+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                }
                            ],
                            "error_texts": [
                                "[320,1] not a statement\n"
                            ]
                        },
                        "321": {
                            "lines": [
                                {
                                    "line_no": 320,
                                    "content": "-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                },
                                {
                                    "line_no": 321,
                                    "content": "+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());"
                                },
                                {
                                    "line_no": 322,
                                    "content": "        return result;"
                                }
                            ],
                            "error_texts": [
                                "[321,1] not a statement\n"
                            ]
                        }
                    }
                }
            },
            "error": "not a statement\n",
            "span_id": 10147806447242831026
        }
    ],
    "read_file": [
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 16785397396475991303
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 14166810537305761607
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 6087068996451602512
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 11243403617373279799
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 13478494672133709092
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 1479656062306109228
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get().cast(ConstraintDescriptor.class));\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 16642418373496919509
        },
        {
            "input": "bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n-        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n+        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
            "error": "",
            "span_id": 1854703121436576772
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}