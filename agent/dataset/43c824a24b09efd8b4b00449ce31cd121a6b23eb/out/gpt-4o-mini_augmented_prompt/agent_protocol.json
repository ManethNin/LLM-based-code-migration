{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n+++ src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n@@ -2,35 +2,35 @@\n import de.gwdg.metadataqa.api.json.JsonBranch;\n import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\n import de.gwdg.metadataqa.api.model.XmlFieldInstance;\n import de.gwdg.metadataqa.api.schema.MarcJsonSchema;\n import de.gwdg.metadataqa.api.schema.Schema;\n import de.gwdg.metadataqa.marc.dao.Control001;\n import de.gwdg.metadataqa.marc.dao.Control003;\n import de.gwdg.metadataqa.marc.dao.Control005;\n import de.gwdg.metadataqa.marc.dao.Control006;\n import de.gwdg.metadataqa.marc.dao.Control007;\n import de.gwdg.metadataqa.marc.dao.Control008;\n import de.gwdg.metadataqa.marc.dao.DataField;\n import de.gwdg.metadataqa.marc.dao.Leader;\n import de.gwdg.metadataqa.marc.dao.record.Marc21Record;\n import de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\n import de.gwdg.metadataqa.marc.dao.record.PicaRecord;\n import de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\n import de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\n import de.gwdg.metadataqa.marc.definition.MarcVersion;\n import de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\n import de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\n import de.gwdg.metadataqa.marc.utils.MapToDatafield;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\n import de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\n import de.gwdg.metadataqa.marc.utils.pica.PicaLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\n import net.minidev.json.JSONArray;\n import org.marc4j.marc.ControlField;\n import org.marc4j.marc.Record;\n import org.marc4j.marc.Subfield;\n import org.marc4j.marc.impl.*;\n \n import java.security.InvalidParameterException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Logger;\n \n /**\n  * Factory class to create MarcRecord from JsonPathCache\n  */\n public class MarcFactory {\n \n   private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n   private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n \n   private static Schema schema = new MarcJsonSchema();\n \n   private MarcFactory() {\n     throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache) {\n     return create(cache, MarcVersion.MARC21);\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n     var marcRecord = new Marc21Record();\n-    for (JsonBranch branch : schema.getPaths()) {\n+    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n       if (branch.getParent() != null)\n         continue;\n       switch (branch.getLabel()) {\n         case \"leader\":\n           marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n           break;\n         case \"001\":\n           marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n           break;\n         case \"003\":\n           marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n           break;\n         case \"005\":\n           marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"006\":\n           marcRecord.setControl006(\n             new Control006(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"007\":\n           marcRecord.setControl007(\n             new Control007(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"008\":\n           marcRecord.setControl008(\n             new Control008(extractFirst(cache, branch), marcRecord));\n           break;\n         default:\n           JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n           for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n             var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n             var field = MapToDatafield.parse(fieldInstance, version);\n             if (field != null) {\n               marcRecord.addDataField(field);\n               field.setMarcRecord(marcRecord);\n             } else {\n               marcRecord.addUnhandledTags(branch.getLabel());\n             }\n           }\n           break;\n       }\n     }\n     return marcRecord;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": "package de.gwdg.metadataqa.marc;\n\nimport de.gwdg.metadataqa.api.json.JsonBranch;\nimport de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\nimport de.gwdg.metadataqa.api.model.XmlFieldInstance;\nimport de.gwdg.metadataqa.api.schema.MarcJsonSchema;\nimport de.gwdg.metadataqa.api.schema.Schema;\nimport de.gwdg.metadataqa.marc.dao.Control001;\nimport de.gwdg.metadataqa.marc.dao.Control003;\nimport de.gwdg.metadataqa.marc.dao.Control005;\nimport de.gwdg.metadataqa.marc.dao.Control006;\nimport de.gwdg.metadataqa.marc.dao.Control007;\nimport de.gwdg.metadataqa.marc.dao.Control008;\nimport de.gwdg.metadataqa.marc.dao.DataField;\nimport de.gwdg.metadataqa.marc.dao.Leader;\nimport de.gwdg.metadataqa.marc.dao.record.Marc21Record;\nimport de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\nimport de.gwdg.metadataqa.marc.dao.record.PicaRecord;\nimport de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\nimport de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.MarcVersion;\nimport de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\nimport de.gwdg.metadataqa.marc.utils.MapToDatafield;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\nimport net.minidev.json.JSONArray;\nimport org.marc4j.marc.ControlField;\nimport org.marc4j.marc.Record;\nimport org.marc4j.marc.Subfield;\nimport org.marc4j.marc.impl.*;\n\nimport java.security.InvalidParameterException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Factory class to create MarcRecord from JsonPathCache\n */\npublic class MarcFactory {\n\n  private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n  private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n\n  private static Schema schema = new MarcJsonSchema();\n\n  private MarcFactory() {\n    throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache) {\n    return create(cache, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n    var marcRecord = new Marc21Record();\n    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n      if (branch.getParent() != null)\n        continue;\n      switch (branch.getLabel()) {\n        case \"leader\":\n          marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n          break;\n        case \"001\":\n          marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n          break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n          break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"006\":\n          marcRecord.setControl006(\n            new Control006(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"007\":\n          marcRecord.setControl007(\n            new Control007(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"008\":\n          marcRecord.setControl008(\n            new Control008(extractFirst(cache, branch), marcRecord));\n          break;\n        default:\n          JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n          for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n            var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n            var field = MapToDatafield.parse(fieldInstance, version);\n            if (field != null) {\n              marcRecord.addDataField(field);\n              field.setMarcRecord(marcRecord);\n            } else {\n              marcRecord.addUnhandledTags(branch.getLabel());\n            }\n          }\n          break;\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord) {\n    return createFromMarc4j(marc4jRecord, null, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType) {\n    return createFromMarc4j(marc4jRecord, defaultType, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, null, marcVersion);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, defaultType, marcVersion, null);\n  }\n\n  /**\n   * Create a MarcRecord object from Marc4j object\n   * @param marc4jRecord The Marc4j record\n   * @param defaultType The defauld document type\n   * @param marcVersion The MARC version\n   * @param replecementInControlFields A ^ or # character which sould be replaced with space in control fields\n   * @return\n   */\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion,\n                                                     String replecementInControlFields) {\n    var marcRecord = new Marc21Record();\n\n    if (marc4jRecord.getLeader() != null) {\n      String data = marc4jRecord.getLeader().marshal();\n      if (replecementInControlFields != null)\n        data = data.replace(replecementInControlFields, \" \");\n      marcRecord.setLeader(new Leader(data, defaultType));\n\n      if (marcRecord.getType() == null) {\n        throw new InvalidParameterException(\n          String.format(\n            \"Error in '%s': no type has been detected. Leader: '%s'.\",\n            marc4jRecord.getControlNumberField(), marcRecord.getLeader().getLeaderString()\n          )\n        );\n      }\n    }\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, replecementInControlFields);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, marcVersion);\n\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createPicaFromMarc4j(Record marc4jRecord, PicaSchemaManager picaSchemaManager) {\n    var marcRecord = new PicaRecord();\n    // marcRecord.setSchemaType(SchemaType.PICA);\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, null);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, picaSchemaManager);\n\n    return marcRecord;\n  }\n\n  private static void importMarc4jControlFields(Record marc4jRecord,\n                                                BibliographicRecord marcRecord,\n                                                String replecementInControlFields) {\n    for (ControlField controlField : marc4jRecord.getControlFields()) {\n      String data = controlField.getData();\n      if (replecementInControlFields != null && isFixable(controlField.getTag()))\n        data = data.replace(replecementInControlFields, \" \");\n      switch (controlField.getTag()) {\n        case \"001\":\n          marcRecord.setControl001(new Control001(data)); break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(data)); break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(data, marcRecord)); break;\n        case \"006\":\n          marcRecord.setControl006(new Control006(data, marcRecord)); break;\n        case \"007\":\n          marcRecord.setControl007(new Control007(data, marcRecord)); break;\n        case \"008\":\n          marcRecord.setControl008(new Control008(data, marcRecord)); break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private static boolean isFixable(String tag) {\n    return fixableControlFields.contains(tag);\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             MarcVersion marcVersion) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = getDataFieldDefinition(dataField, marcVersion);\n      if (definition == null) {\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractDataField(dataField, definition, marcVersion);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             PicaSchemaManager schema) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = schema.lookup(dataField.getTag());\n      if (definition == null) {\n        // System.err.println(\"getTag: \" + dataField.getTag() + \" ----\");\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractPicaDataField(dataField, definition, MarcVersion.MARC21);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(org.marc4j.marc.DataField dataField,\n                                                           MarcVersion marcVersion) {\n    return getDataFieldDefinition(dataField.getTag(), marcVersion);\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(String tag, MarcVersion marcVersion) {\n    return TagDefinitionLoader.load(tag, marcVersion);\n  }\n\n  private static DataField extractDataField(org.marc4j.marc.DataField dataField,\n                                            DataFieldDefinition definition,\n                                            MarcVersion marcVersion) {\n    DataField field;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2()),\n              marcVersion\n      );\n    } else {\n      field = new DataField(\n              definition,\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static DataField extractPicaDataField(org.marc4j.marc.DataField dataField,\n                                                PicaFieldDefinition definition,\n                                                MarcVersion marcVersion) {\n    DataField field = null;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2()),\n        marcVersion\n      );\n    } else {\n      field = new DataField(\n        definition,\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {\n    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());\n    List<String> values = new ArrayList<>();\n    if (instances != null)\n      for (XmlFieldInstance instance : instances)\n        values.add(instance.getValue());\n    return values;\n  }\n\n  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {\n    List<String> list = extractList(cache, branch);\n    if (!list.isEmpty())\n      return list.get(0);\n    return null;\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")));\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText, MarcVersion marcVersion) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")), marcVersion);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines) {\n    return createFromFormattedText(lines, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines, MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (String line : lines) {\n      if (line.startsWith(\"LEADER \")) {\n        marcRecord.setLeader(line.replace(\"LEADER \", \"\"), marcVersion);\n      } else {\n        var tag = line.substring(0, 3);\n        var content = line.substring(4);\n        marcRecord.setField(tag, content, marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromAlephseq(List<AlephseqLine> lines,\n                                                       MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marcRecord.setLeader(line.getContent());\n      } else if (line.isNumericTag()) {\n        marcRecord.setField(line.getTag(), line.getInd1(), line.getInd2(), line.getContent(), marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static Record createRecordFromAlephseq(List<AlephseqLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(\n            line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0)\n          );\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcline(List<MarclineLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarclineLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcMaker(List<MarcMakerLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarcMakerLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromPica(List<PicaLine> lines,\n                                            String idField,\n                                            String idCode,\n                                            PicaSchemaManager schema) {\n    Record marc4jRecord = new RecordImpl();\n    String id = null;\n    for (PicaLine line : lines) {\n      // String tag = schema.containsKey(line.getQualifiedTag()) ? line.getQualifiedTag() : line.getTag();\n      DataFieldImpl df = new DataFieldImpl(line.getQualifiedTag(), ' ', ' ');\n      for (PicaSubfield picaSubfield : line.getSubfields()) {\n        df.addSubfield(new SubfieldImpl(picaSubfield.getCode().charAt(0), picaSubfield.getValue()));\n        if (line.getTag().equals(idField) && picaSubfield.getCode().equals(idCode))\n          id = picaSubfield.getValue();\n      }\n      marc4jRecord.addVariableField(df);\n    }\n    if (id != null)\n      marc4jRecord.addVariableField(new ControlFieldImpl(\"001\", id));\n    return marc4jRecord;\n  }\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": {
                        "3": {
                            "lines": [
                                {
                                    "line_no": 2,
                                    "content": ""
                                },
                                {
                                    "line_no": 3,
                                    "content": "import de.gwdg.metadataqa.api.json.JsonBranch;"
                                },
                                {
                                    "line_no": 4,
                                    "content": "import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;"
                                }
                            ],
                            "error_texts": [
                                "[3,35] cannot find symbol\nsymbol: class JsonBranch\nlocation: package de.gwdg.metadataqa.api.json\n",
                                "[3,35] cannot find symbol\n"
                            ]
                        },
                        "313": {
                            "lines": [
                                {
                                    "line_no": 312,
                                    "content": ""
                                },
                                {
                                    "line_no": 313,
                                    "content": "  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 314,
                                    "content": "    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());"
                                }
                            ],
                            "error_texts": [
                                "[313,64] cannot find symbol\n",
                                "[313,64] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        },
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": ""
                                },
                                {
                                    "line_no": 322,
                                    "content": "  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 323,
                                    "content": "    List<String> list = extractList(cache, branch);"
                                }
                            ],
                            "error_texts": [
                                "[322,59] cannot find symbol\n",
                                "[322,59] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 11832547706433040755
        },
        {
            "input": "```diff\n--- src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n+++ src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n@@ -2,35 +2,35 @@\n import de.gwdg.metadataqa.api.json.JsonBranch;\n import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\n import de.gwdg.metadataqa.api.model.XmlFieldInstance;\n import de.gwdg.metadataqa.api.schema.MarcJsonSchema;\n import de.gwdg.metadataqa.api.schema.Schema;\n import de.gwdg.metadataqa.marc.dao.Control001;\n import de.gwdg.metadataqa.marc.dao.Control003;\n import de.gwdg.metadataqa.marc.dao.Control005;\n import de.gwdg.metadataqa.marc.dao.Control006;\n import de.gwdg.metadataqa.marc.dao.Control007;\n import de.gwdg.metadataqa.marc.dao.Control008;\n import de.gwdg.metadataqa.marc.dao.DataField;\n import de.gwdg.metadataqa.marc.dao.Leader;\n import de.gwdg.metadataqa.marc.dao.record.Marc21Record;\n import de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\n import de.gwdg.metadataqa.marc.dao.record.PicaRecord;\n import de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\n import de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\n import de.gwdg.metadataqa.marc.definition.MarcVersion;\n import de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\n import de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\n import de.gwdg.metadataqa.marc.utils.MapToDatafield;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\n import de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\n import de.gwdg.metadataqa.marc.utils.pica.PicaLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\n import net.minidev.json.JSONArray;\n import org.marc4j.marc.ControlField;\n import org.marc4j.marc.Record;\n import org.marc4j.marc.Subfield;\n import org.marc4j.marc.impl.*;\n \n import java.security.InvalidParameterException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Logger;\n \n /**\n  * Factory class to create MarcRecord from JsonPathCache\n  */\n public class MarcFactory {\n \n   private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n   private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n \n   private static Schema schema = new MarcJsonSchema();\n \n   private MarcFactory() {\n     throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache) {\n     return create(cache, MarcVersion.MARC21);\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n     var marcRecord = new Marc21Record();\n-    for (JsonBranch branch : schema.getPaths()) {\n+    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n       if (branch.getParent() != null)\n         continue;\n       switch (branch.getLabel()) {\n         case \"leader\":\n           marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n           break;\n         case \"001\":\n           marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n           break;\n         case \"003\":\n           marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n           break;\n         case \"005\":\n           marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"006\":\n           marcRecord.setControl006(\n             new Control006(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"007\":\n           marcRecord.setControl007(\n             new Control007(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"008\":\n           marcRecord.setControl008(\n             new Control008(extractFirst(cache, branch), marcRecord));\n           break;\n         default:\n           JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n           for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n             var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n             var field = MapToDatafield.parse(fieldInstance, version);\n             if (field != null) {\n               marcRecord.addDataField(field);\n               field.setMarcRecord(marcRecord);\n             } else {\n               marcRecord.addUnhandledTags(branch.getLabel());\n             }\n           }\n           break;\n       }\n     }\n     return marcRecord;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": "package de.gwdg.metadataqa.marc;\n\nimport de.gwdg.metadataqa.api.json.JsonBranch;\nimport de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\nimport de.gwdg.metadataqa.api.model.XmlFieldInstance;\nimport de.gwdg.metadataqa.api.schema.MarcJsonSchema;\nimport de.gwdg.metadataqa.api.schema.Schema;\nimport de.gwdg.metadataqa.marc.dao.Control001;\nimport de.gwdg.metadataqa.marc.dao.Control003;\nimport de.gwdg.metadataqa.marc.dao.Control005;\nimport de.gwdg.metadataqa.marc.dao.Control006;\nimport de.gwdg.metadataqa.marc.dao.Control007;\nimport de.gwdg.metadataqa.marc.dao.Control008;\nimport de.gwdg.metadataqa.marc.dao.DataField;\nimport de.gwdg.metadataqa.marc.dao.Leader;\nimport de.gwdg.metadataqa.marc.dao.record.Marc21Record;\nimport de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\nimport de.gwdg.metadataqa.marc.dao.record.PicaRecord;\nimport de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\nimport de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.MarcVersion;\nimport de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\nimport de.gwdg.metadataqa.marc.utils.MapToDatafield;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\nimport net.minidev.json.JSONArray;\nimport org.marc4j.marc.ControlField;\nimport org.marc4j.marc.Record;\nimport org.marc4j.marc.Subfield;\nimport org.marc4j.marc.impl.*;\n\nimport java.security.InvalidParameterException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Factory class to create MarcRecord from JsonPathCache\n */\npublic class MarcFactory {\n\n  private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n  private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n\n  private static Schema schema = new MarcJsonSchema();\n\n  private MarcFactory() {\n    throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache) {\n    return create(cache, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n    var marcRecord = new Marc21Record();\n    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n      if (branch.getParent() != null)\n        continue;\n      switch (branch.getLabel()) {\n        case \"leader\":\n          marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n          break;\n        case \"001\":\n          marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n          break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n          break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"006\":\n          marcRecord.setControl006(\n            new Control006(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"007\":\n          marcRecord.setControl007(\n            new Control007(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"008\":\n          marcRecord.setControl008(\n            new Control008(extractFirst(cache, branch), marcRecord));\n          break;\n        default:\n          JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n          for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n            var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n            var field = MapToDatafield.parse(fieldInstance, version);\n            if (field != null) {\n              marcRecord.addDataField(field);\n              field.setMarcRecord(marcRecord);\n            } else {\n              marcRecord.addUnhandledTags(branch.getLabel());\n            }\n          }\n          break;\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord) {\n    return createFromMarc4j(marc4jRecord, null, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType) {\n    return createFromMarc4j(marc4jRecord, defaultType, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, null, marcVersion);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, defaultType, marcVersion, null);\n  }\n\n  /**\n   * Create a MarcRecord object from Marc4j object\n   * @param marc4jRecord The Marc4j record\n   * @param defaultType The defauld document type\n   * @param marcVersion The MARC version\n   * @param replecementInControlFields A ^ or # character which sould be replaced with space in control fields\n   * @return\n   */\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion,\n                                                     String replecementInControlFields) {\n    var marcRecord = new Marc21Record();\n\n    if (marc4jRecord.getLeader() != null) {\n      String data = marc4jRecord.getLeader().marshal();\n      if (replecementInControlFields != null)\n        data = data.replace(replecementInControlFields, \" \");\n      marcRecord.setLeader(new Leader(data, defaultType));\n\n      if (marcRecord.getType() == null) {\n        throw new InvalidParameterException(\n          String.format(\n            \"Error in '%s': no type has been detected. Leader: '%s'.\",\n            marc4jRecord.getControlNumberField(), marcRecord.getLeader().getLeaderString()\n          )\n        );\n      }\n    }\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, replecementInControlFields);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, marcVersion);\n\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createPicaFromMarc4j(Record marc4jRecord, PicaSchemaManager picaSchemaManager) {\n    var marcRecord = new PicaRecord();\n    // marcRecord.setSchemaType(SchemaType.PICA);\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, null);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, picaSchemaManager);\n\n    return marcRecord;\n  }\n\n  private static void importMarc4jControlFields(Record marc4jRecord,\n                                                BibliographicRecord marcRecord,\n                                                String replecementInControlFields) {\n    for (ControlField controlField : marc4jRecord.getControlFields()) {\n      String data = controlField.getData();\n      if (replecementInControlFields != null && isFixable(controlField.getTag()))\n        data = data.replace(replecementInControlFields, \" \");\n      switch (controlField.getTag()) {\n        case \"001\":\n          marcRecord.setControl001(new Control001(data)); break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(data)); break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(data, marcRecord)); break;\n        case \"006\":\n          marcRecord.setControl006(new Control006(data, marcRecord)); break;\n        case \"007\":\n          marcRecord.setControl007(new Control007(data, marcRecord)); break;\n        case \"008\":\n          marcRecord.setControl008(new Control008(data, marcRecord)); break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private static boolean isFixable(String tag) {\n    return fixableControlFields.contains(tag);\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             MarcVersion marcVersion) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = getDataFieldDefinition(dataField, marcVersion);\n      if (definition == null) {\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractDataField(dataField, definition, marcVersion);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             PicaSchemaManager schema) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = schema.lookup(dataField.getTag());\n      if (definition == null) {\n        // System.err.println(\"getTag: \" + dataField.getTag() + \" ----\");\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractPicaDataField(dataField, definition, MarcVersion.MARC21);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(org.marc4j.marc.DataField dataField,\n                                                           MarcVersion marcVersion) {\n    return getDataFieldDefinition(dataField.getTag(), marcVersion);\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(String tag, MarcVersion marcVersion) {\n    return TagDefinitionLoader.load(tag, marcVersion);\n  }\n\n  private static DataField extractDataField(org.marc4j.marc.DataField dataField,\n                                            DataFieldDefinition definition,\n                                            MarcVersion marcVersion) {\n    DataField field;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2()),\n              marcVersion\n      );\n    } else {\n      field = new DataField(\n              definition,\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static DataField extractPicaDataField(org.marc4j.marc.DataField dataField,\n                                                PicaFieldDefinition definition,\n                                                MarcVersion marcVersion) {\n    DataField field = null;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2()),\n        marcVersion\n      );\n    } else {\n      field = new DataField(\n        definition,\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {\n    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());\n    List<String> values = new ArrayList<>();\n    if (instances != null)\n      for (XmlFieldInstance instance : instances)\n        values.add(instance.getValue());\n    return values;\n  }\n\n  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {\n    List<String> list = extractList(cache, branch);\n    if (!list.isEmpty())\n      return list.get(0);\n    return null;\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")));\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText, MarcVersion marcVersion) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")), marcVersion);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines) {\n    return createFromFormattedText(lines, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines, MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (String line : lines) {\n      if (line.startsWith(\"LEADER \")) {\n        marcRecord.setLeader(line.replace(\"LEADER \", \"\"), marcVersion);\n      } else {\n        var tag = line.substring(0, 3);\n        var content = line.substring(4);\n        marcRecord.setField(tag, content, marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromAlephseq(List<AlephseqLine> lines,\n                                                       MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marcRecord.setLeader(line.getContent());\n      } else if (line.isNumericTag()) {\n        marcRecord.setField(line.getTag(), line.getInd1(), line.getInd2(), line.getContent(), marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static Record createRecordFromAlephseq(List<AlephseqLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(\n            line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0)\n          );\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcline(List<MarclineLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarclineLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcMaker(List<MarcMakerLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarcMakerLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromPica(List<PicaLine> lines,\n                                            String idField,\n                                            String idCode,\n                                            PicaSchemaManager schema) {\n    Record marc4jRecord = new RecordImpl();\n    String id = null;\n    for (PicaLine line : lines) {\n      // String tag = schema.containsKey(line.getQualifiedTag()) ? line.getQualifiedTag() : line.getTag();\n      DataFieldImpl df = new DataFieldImpl(line.getQualifiedTag(), ' ', ' ');\n      for (PicaSubfield picaSubfield : line.getSubfields()) {\n        df.addSubfield(new SubfieldImpl(picaSubfield.getCode().charAt(0), picaSubfield.getValue()));\n        if (line.getTag().equals(idField) && picaSubfield.getCode().equals(idCode))\n          id = picaSubfield.getValue();\n      }\n      marc4jRecord.addVariableField(df);\n    }\n    if (id != null)\n      marc4jRecord.addVariableField(new ControlFieldImpl(\"001\", id));\n    return marc4jRecord;\n  }\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": {
                        "3": {
                            "lines": [
                                {
                                    "line_no": 2,
                                    "content": ""
                                },
                                {
                                    "line_no": 3,
                                    "content": "import de.gwdg.metadataqa.api.json.JsonBranch;"
                                },
                                {
                                    "line_no": 4,
                                    "content": "import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;"
                                }
                            ],
                            "error_texts": [
                                "[3,35] cannot find symbol\nsymbol: class JsonBranch\nlocation: package de.gwdg.metadataqa.api.json\n",
                                "[3,35] cannot find symbol\n"
                            ]
                        },
                        "313": {
                            "lines": [
                                {
                                    "line_no": 312,
                                    "content": ""
                                },
                                {
                                    "line_no": 313,
                                    "content": "  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 314,
                                    "content": "    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());"
                                }
                            ],
                            "error_texts": [
                                "[313,64] cannot find symbol\n",
                                "[313,64] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        },
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": ""
                                },
                                {
                                    "line_no": 322,
                                    "content": "  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 323,
                                    "content": "    List<String> list = extractList(cache, branch);"
                                }
                            ],
                            "error_texts": [
                                "[322,59] cannot find symbol\n",
                                "[322,59] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 8517955333736240915
        },
        {
            "input": "```diff\n--- src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n+++ src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java\n@@ -2,35 +2,35 @@\n import de.gwdg.metadataqa.api.json.JsonBranch;\n import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\n import de.gwdg.metadataqa.api.model.XmlFieldInstance;\n import de.gwdg.metadataqa.api.schema.MarcJsonSchema;\n import de.gwdg.metadataqa.api.schema.Schema;\n import de.gwdg.metadataqa.marc.dao.Control001;\n import de.gwdg.metadataqa.marc.dao.Control003;\n import de.gwdg.metadataqa.marc.dao.Control005;\n import de.gwdg.metadataqa.marc.dao.Control006;\n import de.gwdg.metadataqa.marc.dao.Control007;\n import de.gwdg.metadataqa.marc.dao.Control008;\n import de.gwdg.metadataqa.marc.dao.DataField;\n import de.gwdg.metadataqa.marc.dao.Leader;\n import de.gwdg.metadataqa.marc.dao.record.Marc21Record;\n import de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\n import de.gwdg.metadataqa.marc.dao.record.PicaRecord;\n import de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\n import de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\n import de.gwdg.metadataqa.marc.definition.MarcVersion;\n import de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\n import de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\n import de.gwdg.metadataqa.marc.utils.MapToDatafield;\n \n import de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\n import de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\n import de.gwdg.metadataqa.marc.utils.pica.PicaLine;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\n import de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\n import net.minidev.json.JSONArray;\n import org.marc4j.marc.ControlField;\n import org.marc4j.marc.Record;\n import org.marc4j.marc.Subfield;\n import org.marc4j.marc.impl.*;\n \n import java.security.InvalidParameterException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Logger;\n \n /**\n  * Factory class to create MarcRecord from JsonPathCache\n  */\n public class MarcFactory {\n \n   private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n   private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n \n   private static Schema schema = new MarcJsonSchema();\n \n   private MarcFactory() {\n     throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache) {\n     return create(cache, MarcVersion.MARC21);\n   }\n \n   public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n     var marcRecord = new Marc21Record();\n-    for (JsonBranch branch : schema.getPaths()) {\n+    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n       if (branch.getParent() != null)\n         continue;\n       switch (branch.getLabel()) {\n         case \"leader\":\n           marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n           break;\n         case \"001\":\n           marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n           break;\n         case \"003\":\n           marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n           break;\n         case \"005\":\n           marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"006\":\n           marcRecord.setControl006(\n             new Control006(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"007\":\n           marcRecord.setControl007(\n             new Control007(extractFirst(cache, branch), marcRecord));\n           break;\n         case \"008\":\n           marcRecord.setControl008(\n             new Control008(extractFirst(cache, branch), marcRecord));\n           break;\n         default:\n           JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n           for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n             var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n             var field = MapToDatafield.parse(fieldInstance, version);\n             if (field != null) {\n               marcRecord.addDataField(field);\n               field.setMarcRecord(marcRecord);\n             } else {\n               marcRecord.addUnhandledTags(branch.getLabel());\n             }\n           }\n           break;\n       }\n     }\n     return marcRecord;\n   }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": "package de.gwdg.metadataqa.marc;\n\nimport de.gwdg.metadataqa.api.json.JsonBranch;\nimport de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\nimport de.gwdg.metadataqa.api.model.XmlFieldInstance;\nimport de.gwdg.metadataqa.api.schema.MarcJsonSchema;\nimport de.gwdg.metadataqa.api.schema.Schema;\nimport de.gwdg.metadataqa.marc.dao.Control001;\nimport de.gwdg.metadataqa.marc.dao.Control003;\nimport de.gwdg.metadataqa.marc.dao.Control005;\nimport de.gwdg.metadataqa.marc.dao.Control006;\nimport de.gwdg.metadataqa.marc.dao.Control007;\nimport de.gwdg.metadataqa.marc.dao.Control008;\nimport de.gwdg.metadataqa.marc.dao.DataField;\nimport de.gwdg.metadataqa.marc.dao.Leader;\nimport de.gwdg.metadataqa.marc.dao.record.Marc21Record;\nimport de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\nimport de.gwdg.metadataqa.marc.dao.record.PicaRecord;\nimport de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\nimport de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.MarcVersion;\nimport de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\nimport de.gwdg.metadataqa.marc.utils.MapToDatafield;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\nimport net.minidev.json.JSONArray;\nimport org.marc4j.marc.ControlField;\nimport org.marc4j.marc.Record;\nimport org.marc4j.marc.Subfield;\nimport org.marc4j.marc.impl.*;\n\nimport java.security.InvalidParameterException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Factory class to create MarcRecord from JsonPathCache\n */\npublic class MarcFactory {\n\n  private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n  private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n\n  private static Schema schema = new MarcJsonSchema();\n\n  private MarcFactory() {\n    throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache) {\n    return create(cache, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n    var marcRecord = new Marc21Record();\n    for (de.gwdg.metadataqa.api.json.JsonBranch branch : schema.getPaths()) {\n      if (branch.getParent() != null)\n        continue;\n      switch (branch.getLabel()) {\n        case \"leader\":\n          marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n          break;\n        case \"001\":\n          marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n          break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n          break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"006\":\n          marcRecord.setControl006(\n            new Control006(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"007\":\n          marcRecord.setControl007(\n            new Control007(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"008\":\n          marcRecord.setControl008(\n            new Control008(extractFirst(cache, branch), marcRecord));\n          break;\n        default:\n          JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n          for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n            var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n            var field = MapToDatafield.parse(fieldInstance, version);\n            if (field != null) {\n              marcRecord.addDataField(field);\n              field.setMarcRecord(marcRecord);\n            } else {\n              marcRecord.addUnhandledTags(branch.getLabel());\n            }\n          }\n          break;\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord) {\n    return createFromMarc4j(marc4jRecord, null, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType) {\n    return createFromMarc4j(marc4jRecord, defaultType, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, null, marcVersion);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, defaultType, marcVersion, null);\n  }\n\n  /**\n   * Create a MarcRecord object from Marc4j object\n   * @param marc4jRecord The Marc4j record\n   * @param defaultType The defauld document type\n   * @param marcVersion The MARC version\n   * @param replecementInControlFields A ^ or # character which sould be replaced with space in control fields\n   * @return\n   */\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion,\n                                                     String replecementInControlFields) {\n    var marcRecord = new Marc21Record();\n\n    if (marc4jRecord.getLeader() != null) {\n      String data = marc4jRecord.getLeader().marshal();\n      if (replecementInControlFields != null)\n        data = data.replace(replecementInControlFields, \" \");\n      marcRecord.setLeader(new Leader(data, defaultType));\n\n      if (marcRecord.getType() == null) {\n        throw new InvalidParameterException(\n          String.format(\n            \"Error in '%s': no type has been detected. Leader: '%s'.\",\n            marc4jRecord.getControlNumberField(), marcRecord.getLeader().getLeaderString()\n          )\n        );\n      }\n    }\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, replecementInControlFields);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, marcVersion);\n\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createPicaFromMarc4j(Record marc4jRecord, PicaSchemaManager picaSchemaManager) {\n    var marcRecord = new PicaRecord();\n    // marcRecord.setSchemaType(SchemaType.PICA);\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, null);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, picaSchemaManager);\n\n    return marcRecord;\n  }\n\n  private static void importMarc4jControlFields(Record marc4jRecord,\n                                                BibliographicRecord marcRecord,\n                                                String replecementInControlFields) {\n    for (ControlField controlField : marc4jRecord.getControlFields()) {\n      String data = controlField.getData();\n      if (replecementInControlFields != null && isFixable(controlField.getTag()))\n        data = data.replace(replecementInControlFields, \" \");\n      switch (controlField.getTag()) {\n        case \"001\":\n          marcRecord.setControl001(new Control001(data)); break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(data)); break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(data, marcRecord)); break;\n        case \"006\":\n          marcRecord.setControl006(new Control006(data, marcRecord)); break;\n        case \"007\":\n          marcRecord.setControl007(new Control007(data, marcRecord)); break;\n        case \"008\":\n          marcRecord.setControl008(new Control008(data, marcRecord)); break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private static boolean isFixable(String tag) {\n    return fixableControlFields.contains(tag);\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             MarcVersion marcVersion) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = getDataFieldDefinition(dataField, marcVersion);\n      if (definition == null) {\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractDataField(dataField, definition, marcVersion);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             PicaSchemaManager schema) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = schema.lookup(dataField.getTag());\n      if (definition == null) {\n        // System.err.println(\"getTag: \" + dataField.getTag() + \" ----\");\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractPicaDataField(dataField, definition, MarcVersion.MARC21);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(org.marc4j.marc.DataField dataField,\n                                                           MarcVersion marcVersion) {\n    return getDataFieldDefinition(dataField.getTag(), marcVersion);\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(String tag, MarcVersion marcVersion) {\n    return TagDefinitionLoader.load(tag, marcVersion);\n  }\n\n  private static DataField extractDataField(org.marc4j.marc.DataField dataField,\n                                            DataFieldDefinition definition,\n                                            MarcVersion marcVersion) {\n    DataField field;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2()),\n              marcVersion\n      );\n    } else {\n      field = new DataField(\n              definition,\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static DataField extractPicaDataField(org.marc4j.marc.DataField dataField,\n                                                PicaFieldDefinition definition,\n                                                MarcVersion marcVersion) {\n    DataField field = null;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2()),\n        marcVersion\n      );\n    } else {\n      field = new DataField(\n        definition,\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {\n    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());\n    List<String> values = new ArrayList<>();\n    if (instances != null)\n      for (XmlFieldInstance instance : instances)\n        values.add(instance.getValue());\n    return values;\n  }\n\n  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {\n    List<String> list = extractList(cache, branch);\n    if (!list.isEmpty())\n      return list.get(0);\n    return null;\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")));\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText, MarcVersion marcVersion) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")), marcVersion);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines) {\n    return createFromFormattedText(lines, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines, MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (String line : lines) {\n      if (line.startsWith(\"LEADER \")) {\n        marcRecord.setLeader(line.replace(\"LEADER \", \"\"), marcVersion);\n      } else {\n        var tag = line.substring(0, 3);\n        var content = line.substring(4);\n        marcRecord.setField(tag, content, marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromAlephseq(List<AlephseqLine> lines,\n                                                       MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marcRecord.setLeader(line.getContent());\n      } else if (line.isNumericTag()) {\n        marcRecord.setField(line.getTag(), line.getInd1(), line.getInd2(), line.getContent(), marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static Record createRecordFromAlephseq(List<AlephseqLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(\n            line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0)\n          );\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcline(List<MarclineLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarclineLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcMaker(List<MarcMakerLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarcMakerLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromPica(List<PicaLine> lines,\n                                            String idField,\n                                            String idCode,\n                                            PicaSchemaManager schema) {\n    Record marc4jRecord = new RecordImpl();\n    String id = null;\n    for (PicaLine line : lines) {\n      // String tag = schema.containsKey(line.getQualifiedTag()) ? line.getQualifiedTag() : line.getTag();\n      DataFieldImpl df = new DataFieldImpl(line.getQualifiedTag(), ' ', ' ');\n      for (PicaSubfield picaSubfield : line.getSubfields()) {\n        df.addSubfield(new SubfieldImpl(picaSubfield.getCode().charAt(0), picaSubfield.getValue()));\n        if (line.getTag().equals(idField) && picaSubfield.getCode().equals(idCode))\n          id = picaSubfield.getValue();\n      }\n      marc4jRecord.addVariableField(df);\n    }\n    if (id != null)\n      marc4jRecord.addVariableField(new ControlFieldImpl(\"001\", id));\n    return marc4jRecord;\n  }\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java": {
                        "3": {
                            "lines": [
                                {
                                    "line_no": 2,
                                    "content": ""
                                },
                                {
                                    "line_no": 3,
                                    "content": "import de.gwdg.metadataqa.api.json.JsonBranch;"
                                },
                                {
                                    "line_no": 4,
                                    "content": "import de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;"
                                }
                            ],
                            "error_texts": [
                                "[3,35] cannot find symbol\nsymbol: class JsonBranch\nlocation: package de.gwdg.metadataqa.api.json\n",
                                "[3,35] cannot find symbol\n"
                            ]
                        },
                        "313": {
                            "lines": [
                                {
                                    "line_no": 312,
                                    "content": ""
                                },
                                {
                                    "line_no": 313,
                                    "content": "  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 314,
                                    "content": "    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());"
                                }
                            ],
                            "error_texts": [
                                "[313,64] cannot find symbol\n",
                                "[313,64] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        },
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": ""
                                },
                                {
                                    "line_no": 322,
                                    "content": "  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {"
                                },
                                {
                                    "line_no": 323,
                                    "content": "    List<String> list = extractList(cache, branch);"
                                }
                            ],
                            "error_texts": [
                                "[322,59] cannot find symbol\n",
                                "[322,59] cannot find symbol\nsymbol: class JsonBranch\nlocation: class de.gwdg.metadataqa.marc.MarcFactory\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 7674977704599309959
        }
    ],
    "read_file": [
        {
            "input": "src/main/java/de/gwdg/metadataqa/marc/MarcFactory.java",
            "output": "package de.gwdg.metadataqa.marc;\n\nimport de.gwdg.metadataqa.api.json.JsonBranch;\nimport de.gwdg.metadataqa.api.model.pathcache.JsonPathCache;\nimport de.gwdg.metadataqa.api.model.XmlFieldInstance;\nimport de.gwdg.metadataqa.api.schema.MarcJsonSchema;\nimport de.gwdg.metadataqa.api.schema.Schema;\nimport de.gwdg.metadataqa.marc.dao.Control001;\nimport de.gwdg.metadataqa.marc.dao.Control003;\nimport de.gwdg.metadataqa.marc.dao.Control005;\nimport de.gwdg.metadataqa.marc.dao.Control006;\nimport de.gwdg.metadataqa.marc.dao.Control007;\nimport de.gwdg.metadataqa.marc.dao.Control008;\nimport de.gwdg.metadataqa.marc.dao.DataField;\nimport de.gwdg.metadataqa.marc.dao.Leader;\nimport de.gwdg.metadataqa.marc.dao.record.Marc21Record;\nimport de.gwdg.metadataqa.marc.dao.record.BibliographicRecord;\nimport de.gwdg.metadataqa.marc.dao.record.PicaRecord;\nimport de.gwdg.metadataqa.marc.definition.bibliographic.SchemaType;\nimport de.gwdg.metadataqa.marc.definition.structure.DataFieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.MarcVersion;\nimport de.gwdg.metadataqa.marc.definition.structure.SubfieldDefinition;\nimport de.gwdg.metadataqa.marc.definition.TagDefinitionLoader;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.AlephseqLine;\nimport de.gwdg.metadataqa.marc.utils.MapToDatafield;\n\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarcMakerLine;\nimport de.gwdg.metadataqa.marc.utils.alephseq.MarclineLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaFieldDefinition;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaLine;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSchemaManager;\nimport de.gwdg.metadataqa.marc.utils.pica.PicaSubfield;\nimport net.minidev.json.JSONArray;\nimport org.marc4j.marc.ControlField;\nimport org.marc4j.marc.Record;\nimport org.marc4j.marc.Subfield;\nimport org.marc4j.marc.impl.*;\n\nimport java.security.InvalidParameterException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Factory class to create MarcRecord from JsonPathCache\n */\npublic class MarcFactory {\n\n  private static final Logger logger = Logger.getLogger(MarcFactory.class.getCanonicalName());\n  private static final List<String> fixableControlFields = Arrays.asList(\"006\", \"007\", \"008\");\n\n  private static Schema schema = new MarcJsonSchema();\n\n  private MarcFactory() {\n    throw new IllegalStateException(\"This is a utility class, can not be instantiated\");\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache) {\n    return create(cache, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord create(JsonPathCache cache, MarcVersion version) {\n    var marcRecord = new Marc21Record();\n    for (JsonBranch branch : schema.getPaths()) {\n      if (branch.getParent() != null)\n        continue;\n      switch (branch.getLabel()) {\n        case \"leader\":\n          marcRecord.setLeader(new Leader(extractFirst(cache, branch)));\n          break;\n        case \"001\":\n          marcRecord.setControl001(new Control001(extractFirst(cache, branch)));\n          break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(extractFirst(cache, branch)));\n          break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"006\":\n          marcRecord.setControl006(\n            new Control006(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"007\":\n          marcRecord.setControl007(\n            new Control007(extractFirst(cache, branch), marcRecord));\n          break;\n        case \"008\":\n          marcRecord.setControl008(\n            new Control008(extractFirst(cache, branch), marcRecord));\n          break;\n        default:\n          JSONArray fieldInstances = (JSONArray) cache.getFragment(branch.getJsonPath());\n          for (var fieldInsanceNr = 0; fieldInsanceNr < fieldInstances.size(); fieldInsanceNr++) {\n            var fieldInstance = (Map) fieldInstances.get(fieldInsanceNr);\n            var field = MapToDatafield.parse(fieldInstance, version);\n            if (field != null) {\n              marcRecord.addDataField(field);\n              field.setMarcRecord(marcRecord);\n            } else {\n              marcRecord.addUnhandledTags(branch.getLabel());\n            }\n          }\n          break;\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord) {\n    return createFromMarc4j(marc4jRecord, null, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType) {\n    return createFromMarc4j(marc4jRecord, defaultType, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, null, marcVersion);\n  }\n\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion) {\n    return createFromMarc4j(marc4jRecord, defaultType, marcVersion, null);\n  }\n\n  /**\n   * Create a MarcRecord object from Marc4j object\n   * @param marc4jRecord The Marc4j record\n   * @param defaultType The defauld document type\n   * @param marcVersion The MARC version\n   * @param replecementInControlFields A ^ or # character which sould be replaced with space in control fields\n   * @return\n   */\n  public static BibliographicRecord createFromMarc4j(Record marc4jRecord,\n                                                     Leader.Type defaultType,\n                                                     MarcVersion marcVersion,\n                                                     String replecementInControlFields) {\n    var marcRecord = new Marc21Record();\n\n    if (marc4jRecord.getLeader() != null) {\n      String data = marc4jRecord.getLeader().marshal();\n      if (replecementInControlFields != null)\n        data = data.replace(replecementInControlFields, \" \");\n      marcRecord.setLeader(new Leader(data, defaultType));\n\n      if (marcRecord.getType() == null) {\n        throw new InvalidParameterException(\n          String.format(\n            \"Error in '%s': no type has been detected. Leader: '%s'.\",\n            marc4jRecord.getControlNumberField(), marcRecord.getLeader().getLeaderString()\n          )\n        );\n      }\n    }\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, replecementInControlFields);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, marcVersion);\n\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createPicaFromMarc4j(Record marc4jRecord, PicaSchemaManager picaSchemaManager) {\n    var marcRecord = new PicaRecord();\n    // marcRecord.setSchemaType(SchemaType.PICA);\n\n    importMarc4jControlFields(marc4jRecord, marcRecord, null);\n\n    importMarc4jDataFields(marc4jRecord, marcRecord, picaSchemaManager);\n\n    return marcRecord;\n  }\n\n  private static void importMarc4jControlFields(Record marc4jRecord,\n                                                BibliographicRecord marcRecord,\n                                                String replecementInControlFields) {\n    for (ControlField controlField : marc4jRecord.getControlFields()) {\n      String data = controlField.getData();\n      if (replecementInControlFields != null && isFixable(controlField.getTag()))\n        data = data.replace(replecementInControlFields, \" \");\n      switch (controlField.getTag()) {\n        case \"001\":\n          marcRecord.setControl001(new Control001(data)); break;\n        case \"003\":\n          marcRecord.setControl003(new Control003(data)); break;\n        case \"005\":\n          marcRecord.setControl005(new Control005(data, marcRecord)); break;\n        case \"006\":\n          marcRecord.setControl006(new Control006(data, marcRecord)); break;\n        case \"007\":\n          marcRecord.setControl007(new Control007(data, marcRecord)); break;\n        case \"008\":\n          marcRecord.setControl008(new Control008(data, marcRecord)); break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private static boolean isFixable(String tag) {\n    return fixableControlFields.contains(tag);\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             MarcVersion marcVersion) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = getDataFieldDefinition(dataField, marcVersion);\n      if (definition == null) {\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractDataField(dataField, definition, marcVersion);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  private static void importMarc4jDataFields(Record marc4jRecord,\n                                             BibliographicRecord marcRecord,\n                                             PicaSchemaManager schema) {\n    for (org.marc4j.marc.DataField dataField : marc4jRecord.getDataFields()) {\n      var definition = schema.lookup(dataField.getTag());\n      if (definition == null) {\n        // System.err.println(\"getTag: \" + dataField.getTag() + \" ----\");\n        marcRecord.addUnhandledTags(dataField.getTag());\n      }\n      var field = extractPicaDataField(dataField, definition, MarcVersion.MARC21);\n      marcRecord.addDataField(field);\n    }\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(org.marc4j.marc.DataField dataField,\n                                                           MarcVersion marcVersion) {\n    return getDataFieldDefinition(dataField.getTag(), marcVersion);\n  }\n\n  public static DataFieldDefinition getDataFieldDefinition(String tag, MarcVersion marcVersion) {\n    return TagDefinitionLoader.load(tag, marcVersion);\n  }\n\n  private static DataField extractDataField(org.marc4j.marc.DataField dataField,\n                                            DataFieldDefinition definition,\n                                            MarcVersion marcVersion) {\n    DataField field;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2()),\n              marcVersion\n      );\n    } else {\n      field = new DataField(\n              definition,\n              Character.toString(dataField.getIndicator1()),\n              Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static DataField extractPicaDataField(org.marc4j.marc.DataField dataField,\n                                                PicaFieldDefinition definition,\n                                                MarcVersion marcVersion) {\n    DataField field = null;\n    if (definition == null) {\n      field = new DataField(dataField.getTag(),\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2()),\n        marcVersion\n      );\n    } else {\n      field = new DataField(\n        definition,\n        Character.toString(dataField.getIndicator1()),\n        Character.toString(dataField.getIndicator2())\n      );\n    }\n    for (Subfield subfield : dataField.getSubfields()) {\n      var code = Character.toString(subfield.getCode());\n      SubfieldDefinition subfieldDefinition = definition == null ? null : definition.getSubfield(code);\n      MarcSubfield marcSubfield = null;\n      if (subfieldDefinition == null) {\n        marcSubfield = new MarcSubfield(null, code, subfield.getData());\n      } else {\n        marcSubfield = new MarcSubfield(subfieldDefinition, code, subfield.getData());\n      }\n      marcSubfield.setField(field);\n      field.getSubfields().add(marcSubfield);\n    }\n    field.indexSubfields();\n    return field;\n  }\n\n  private static List<String> extractList(JsonPathCache cache, JsonBranch branch) {\n    List<XmlFieldInstance> instances = cache.get(branch.getJsonPath());\n    List<String> values = new ArrayList<>();\n    if (instances != null)\n      for (XmlFieldInstance instance : instances)\n        values.add(instance.getValue());\n    return values;\n  }\n\n  private static String extractFirst(JsonPathCache cache, JsonBranch branch) {\n    List<String> list = extractList(cache, branch);\n    if (!list.isEmpty())\n      return list.get(0);\n    return null;\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")));\n  }\n\n  public static BibliographicRecord createFromFormattedText(String marcRecordAsText, MarcVersion marcVersion) {\n    return createFromFormattedText(Arrays.asList(marcRecordAsText.split(\"\\n\")), marcVersion);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines) {\n    return createFromFormattedText(lines, MarcVersion.MARC21);\n  }\n\n  public static BibliographicRecord createFromFormattedText(List<String> lines, MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (String line : lines) {\n      if (line.startsWith(\"LEADER \")) {\n        marcRecord.setLeader(line.replace(\"LEADER \", \"\"), marcVersion);\n      } else {\n        var tag = line.substring(0, 3);\n        var content = line.substring(4);\n        marcRecord.setField(tag, content, marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static BibliographicRecord createFromAlephseq(List<AlephseqLine> lines,\n                                                       MarcVersion marcVersion) {\n    if (marcVersion == null)\n      marcVersion = MarcVersion.MARC21;\n\n    var marcRecord = new Marc21Record();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marcRecord.setLeader(line.getContent());\n      } else if (line.isNumericTag()) {\n        marcRecord.setField(line.getTag(), line.getInd1(), line.getInd2(), line.getContent(), marcVersion);\n      }\n    }\n    return marcRecord;\n  }\n\n  public static Record createRecordFromAlephseq(List<AlephseqLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (AlephseqLine line : lines) {\n      if (line.isLeader()) {\n        marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(\n            line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0)\n          );\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcline(List<MarclineLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarclineLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromMarcMaker(List<MarcMakerLine> lines) {\n    Record marc4jRecord = new RecordImpl();\n    for (MarcMakerLine line : lines) {\n      if (line.isLeader()) {\n        try {\n          marc4jRecord.setLeader(new LeaderImpl(line.getContent()));\n        } catch (StringIndexOutOfBoundsException e) {\n          logger.severe(\"Error at creating leader: \" + e.getMessage());\n        }\n      } else if (line.isNumericTag()) {\n        if (line.isControlField()) {\n          marc4jRecord.addVariableField(new ControlFieldImpl(line.getTag(), line.getContent()));\n        } else {\n          var df = new DataFieldImpl(line.getTag(), line.getInd1().charAt(0), line.getInd2().charAt(0));\n          for (String[] pair : line.parseSubfields()) {\n            if (pair.length == 2 && pair[0] != null && pair[1] != null) {\n              df.addSubfield(new SubfieldImpl(pair[0].charAt(0), pair[1]));\n            } else {\n              logger.warning(String.format(\n                \"parse error in record #%s) tag %s: '%s'\",\n                line.getRecordID(), line.getTag(), line.getRawContent()\n              ));\n            }\n          }\n          marc4jRecord.addVariableField(df);\n        }\n      }\n    }\n    return marc4jRecord;\n  }\n\n  public static Record createRecordFromPica(List<PicaLine> lines,\n                                            String idField,\n                                            String idCode,\n                                            PicaSchemaManager schema) {\n    Record marc4jRecord = new RecordImpl();\n    String id = null;\n    for (PicaLine line : lines) {\n      // String tag = schema.containsKey(line.getQualifiedTag()) ? line.getQualifiedTag() : line.getTag();\n      DataFieldImpl df = new DataFieldImpl(line.getQualifiedTag(), ' ', ' ');\n      for (PicaSubfield picaSubfield : line.getSubfields()) {\n        df.addSubfield(new SubfieldImpl(picaSubfield.getCode().charAt(0), picaSubfield.getValue()));\n        if (line.getTag().equals(idField) && picaSubfield.getCode().equals(idCode))\n          id = picaSubfield.getValue();\n      }\n      marc4jRecord.addVariableField(df);\n    }\n    if (id != null)\n      marc4jRecord.addVariableField(new ControlFieldImpl(\"001\", id));\n    return marc4jRecord;\n  }\n}\n",
            "error": "",
            "span_id": 1245959306209693303
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json/JsonBranch.java",
            "output": "Error: RetryError[<Future at 0x739318862570 state=finished raised FileNotFoundError>]",
            "error": "RetryError[<Future at 0x739318862570 state=finished raised FileNotFoundError>]",
            "span_id": 18093384565574993888
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json/JsonBranch.java",
            "output": "Error: RetryError[<Future at 0x7393182aac30 state=finished raised FileNotFoundError>]",
            "error": "RetryError[<Future at 0x7393182aac30 state=finished raised FileNotFoundError>]",
            "span_id": 12616072329506672590
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json/JsonBranch.java",
            "output": "Error: RetryError[<Future at 0x7393109b2510 state=finished raised FileNotFoundError>]",
            "error": "RetryError[<Future at 0x7393109b2510 state=finished raised FileNotFoundError>]",
            "span_id": 12930276353670787329
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json/JsonBranch.java",
            "output": "Error: RetryError[<Future at 0x739318122f30 state=finished raised FileNotFoundError>]",
            "error": "RetryError[<Future at 0x739318122f30 state=finished raised FileNotFoundError>]",
            "span_id": 12216837506720147096
        }
    ],
    "get_directory_tree": [
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json",
            "output": "[\n    {\n        \"name\": \"File Not Found\",\n        \"type\": \"error\"\n    }\n]",
            "error": "",
            "span_id": 10155679385807141682
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api",
            "output": "[\n    {\n        \"name\": \"File Not Found\",\n        \"type\": \"error\"\n    }\n]",
            "error": "",
            "span_id": 716330568477288297
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json",
            "output": "[\n    {\n        \"name\": \"File Not Found\",\n        \"type\": \"error\"\n    }\n]",
            "error": "",
            "span_id": 7998079794819315864
        },
        {
            "input": "src/main/java/de/gwdg/metadataqa/api/json",
            "output": "[\n    {\n        \"name\": \"File Not Found\",\n        \"type\": \"error\"\n    }\n]",
            "error": "",
            "span_id": 6975742605224268906
        }
    ],
    "get_language_server_suggestions": [],
    "reset_repo": [
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 15382457980126479393
        },
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 15585198900791928473
        },
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 11689674542198435680
        }
    ]
}