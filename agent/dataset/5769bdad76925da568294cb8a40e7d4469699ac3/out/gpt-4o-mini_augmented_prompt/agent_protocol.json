{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java\n+++ lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java\n@@ -238,0 +239,1 @@\n+            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).getStatus();\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).getStatus();\n"
                },
                "compile_error_details": {
                    "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java": {
                        "281": {
                            "lines": [
                                {
                                    "line_no": 280,
                                    "content": "}"
                                },
                                {
                                    "line_no": 281,
                                    "content": "            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).getStatus();"
                                },
                                {
                                    "line_no": 282,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[281,13] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 1189817042680761120
        },
        {
            "input": "```diff\n--- lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java\n+++ lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java\n@@ -238,1 +238,1 @@\n-            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n+            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).getStatus();\n```",
            "output": {
                "compilation_has_succeeded": true,
                "test_has_succeeded": true,
                "error_text": "",
                "updated_files": {
                    "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).getStatus();\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n"
                },
                "compile_error_details": {}
            },
            "error": "[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO]\n[INFO] -----< io.jenkins.tools.incrementals:incrementals-enforcer-rules >------\n[INFO] Building incrementals-enforcer-rules 1.7-SNAPSHOT [5/5]\n[INFO] from enforcer-rules/pom.xml\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- clean:3.2.0:clean (default-clean) @ incrementals-enforcer-rules ---\n[INFO]\n[INFO] --- resources:3.3.1:resources (default-resources) @ incrementals-enforcer-rules ---\n[INFO] skip non existing resourceDirectory /mnt/repo/enforcer-rules/src/main/resources\n[INFO]\n[INFO] --- compiler:3.3:compile (default-compile) @ incrementals-enforcer-rules ---\n[INFO] Changes detected - recompiling the module!\n[INFO] Compiling 1 source file to /mnt/repo/enforcer-rules/target/classes\n[INFO]\n[INFO] --- resources:3.3.1:testResources (default-testResources) @ incrementals-enforcer-rules ---\n[INFO] skip non existing resourceDirectory /mnt/repo/enforcer-rules/src/test/resources\n[INFO]\n[INFO] --- compiler:3.3:testCompile (default-testCompile) @ incrementals-enforcer-rules ---\n[INFO] No sources to compile\n[INFO]\n[INFO] --- groovy:1.4:testCompile (default) @ incrementals-enforcer-rules ---\n[INFO] No sources found to compile\n[INFO]\n[INFO] --- surefire:3.2.5:test (default-test) @ incrementals-enforcer-rules ---\n[INFO] No tests to run.\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary for Incrementals Tools POM 1.7-SNAPSHOT:\n[INFO]\n[INFO] Incrementals Tools POM ............................. SUCCESS [ 2.199 s]\n[INFO] lib ................................................ SUCCESS [ 3.663 s]\n[INFO] incrementals-maven-plugin .......................... SUCCESS [ 5.891 s]\n[INFO] Git Changelist Maven Extension ..................... SUCCESS [ 1.903 s]\n[INFO] incrementals-enforcer-rules ........................ SUCCESS [ 0.197 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 20.325 s\n[INFO] Finished at: 2024-08-01T06:26:14Z\n[INFO] ------------------------------------------------------------------------",
            "span_id": 12548932197240177267
        }
    ],
    "read_file": [
        {
            "input": "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java",
            "output": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 17585493517289066043
        },
        {
            "input": "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java",
            "output": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 6651955654743312908
        },
        {
            "input": "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java",
            "output": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 12967850768386756077
        },
        {
            "input": "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java",
            "output": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 1509949678968112861
        },
        {
            "input": "lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java",
            "output": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;\n            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 5419459409311638985
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": [
        {
            "input": "",
            "output": "Successful reset of repository",
            "error": "",
            "span_id": 5463511060152991597
        }
    ]
}