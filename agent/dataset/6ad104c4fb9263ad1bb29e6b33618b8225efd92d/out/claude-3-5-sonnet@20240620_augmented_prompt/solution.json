{"compilation_has_succeeded": true, "test_has_succeeded": true, "error_text": "", "updated_files": {"src/main/java/io/github/hapjava/server/impl/connections/ConnectionImpl.java": "package io.github.hapjava.server.impl.connections;\n\nimport io.github.hapjava.server.HomekitAuthInfo;\nimport io.github.hapjava.server.impl.HomekitRegistry;\nimport io.github.hapjava.server.impl.crypto.ChachaDecoder;\nimport io.github.hapjava.server.impl.crypto.ChachaEncoder;\nimport io.github.hapjava.server.impl.http.HomekitClientConnection;\nimport io.github.hapjava.server.impl.http.HttpRequest;\nimport io.github.hapjava.server.impl.http.HttpResponse;\nimport io.github.hapjava.server.impl.jmdns.JmdnsHomekitAdvertiser;\nimport io.github.hapjava.server.impl.pairing.UpgradeResponse;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.util.Collection;\nimport java.util.function.Consumer;\nimport org.bouncycastle.util.Pack;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass ConnectionImpl implements HomekitClientConnection {\n\n  private final HttpSession httpSession;\n  private LengthPrefixedByteArrayProcessor binaryProcessor;\n  private int inboundBinaryMessageCount = 0;\n  private int outboundBinaryMessageCount = 0;\n  private byte[] readKey;\n  private byte[] writeKey;\n  private boolean isUpgraded = false;\n  private final Consumer<HttpResponse> outOfBandMessageCallback;\n  private final SubscriptionManager subscriptions;\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(HomekitClientConnection.class);\n\n  public ConnectionImpl(\n      HomekitAuthInfo authInfo,\n      HomekitRegistry registry,\n      Consumer<HttpResponse> outOfBandMessageCallback,\n      SubscriptionManager subscriptions,\n      JmdnsHomekitAdvertiser advertiser) {\n    httpSession = new HttpSession(authInfo, registry, subscriptions, this, advertiser);\n    this.outOfBandMessageCallback = outOfBandMessageCallback;\n    this.subscriptions = subscriptions;\n  }\n\n  @Override\n  public synchronized HttpResponse handleRequest(HttpRequest request) throws IOException {\n    return doHandleRequest(request);\n  }\n\n  private HttpResponse doHandleRequest(HttpRequest request) throws IOException {\n    HttpResponse response =\n        isUpgraded\n            ? httpSession.handleAuthenticatedRequest(request)\n            : httpSession.handleRequest(request);\n    if (response instanceof UpgradeResponse) {\n      isUpgraded = true;\n      readKey = ((UpgradeResponse) response).getReadKey().array();\n      writeKey = ((UpgradeResponse) response).getWriteKey().array();\n    }\n    LOGGER.trace(response.getStatusCode() + \" \" + request.getUri());\n    return response;\n  }\n\n  @Override\n  public byte[] decryptRequest(byte[] ciphertext) {\n    if (!isUpgraded) {\n      throw new RuntimeException(\"Cannot handle binary before connection is upgraded\");\n    }\n    if (binaryProcessor == null) {\n      binaryProcessor = new LengthPrefixedByteArrayProcessor();\n    }\n    Collection<byte[]> res = binaryProcessor.handle(ciphertext);\n    if (res.isEmpty()) {\n      return new byte[0];\n    } else {\n      try (ByteArrayOutputStream decrypted = new ByteArrayOutputStream()) {\n        res.stream()\n            .map(msg -> decrypt(msg))\n            .forEach(\n                bytes -> {\n                  try {\n                    decrypted.write(bytes);\n                  } catch (Exception e) {\n                    throw new RuntimeException(e);\n                  }\n                });\n        return decrypted.toByteArray();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  @Override\n  public byte[] encryptResponse(byte[] response) throws IOException {\n    int offset = 0;\n    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n      while (offset < response.length) {\n        short length = (short) Math.min(response.length - offset, 0x400);\n        byte[] lengthBytes =\n            ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(length).array();\n        baos.write(lengthBytes);\n\n        byte[] nonce = Pack.longToLittleEndian(outboundBinaryMessageCount++);\n        byte[] plaintext;\n        if (response.length == length) {\n          plaintext = response;\n        } else {\n          plaintext = new byte[length];\n          System.arraycopy(response, offset, plaintext, 0, length);\n        }\n        offset += length;\n        baos.write(new ChachaEncoder(writeKey, nonce).encodeCiphertext(plaintext, lengthBytes));\n      }\n      return baos.toByteArray();\n    }\n  }\n\n  private byte[] decrypt(byte[] msg) {\n    byte[] mac = new byte[16];\n    byte[] ciphertext = new byte[msg.length - 16];\n    System.arraycopy(msg, 0, ciphertext, 0, msg.length - 16);\n    System.arraycopy(msg, msg.length - 16, mac, 0, 16);\n    byte[] additionalData =\n        ByteBuffer.allocate(2)\n            .order(ByteOrder.LITTLE_ENDIAN)\n            .putShort((short) (msg.length - 16))\n            .array();\n    return decryptChaCha20Poly1305(mac, additionalData, ciphertext);\n  }\n\n  private byte[] decryptChaCha20Poly1305(byte[] mac, byte[] additionalData, byte[] ciphertext) {\n    try {\n      byte[] nonce = Pack.longToLittleEndian(inboundBinaryMessageCount++);\n      return new ChachaDecoder(readKey, nonce).decodeCiphertext(mac, additionalData, ciphertext);\n    } catch (IOException | InvalidCipherTextException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void close() {\n    subscriptions.removeConnection(this);\n  }\n\n  @Override\n  public void outOfBand(HttpResponse message) {\n    outOfBandMessageCallback.accept(message);\n  }\n}\n"}, "compile_error_details": {}}