diff --git a/src/main/java/de/gwdg/metadataqa/marc/dao/MarcRecord.java b/src/main/java/de/gwdg/metadataqa/marc/dao/MarcRecord.java
index c01f8767..3216ddb3 100644
--- a/src/main/java/de/gwdg/metadataqa/marc/dao/MarcRecord.java
+++ b/src/main/java/de/gwdg/metadataqa/marc/dao/MarcRecord.java
@@ -281,7 +281,7 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
                 case NONE: value = subfieldInstance.getValue(); break;
                 case BOTH: value = subfieldInstance.resolve() + "##" + subfieldInstance.getValue(); break;
               }
-              values.add(value);
+            values.add(value);
             }
           }
         }
@@ -352,7 +352,7 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
         if (controlField != null)
           mainKeyValuePairs.putAll(controlField.getKeyValuePairs(type));
 
-      for (DataField field : datafields) {
+    for (DataField field : datafields) {
         Map<String, List<String>> keyValuePairs = field.getKeyValuePairs(type, marcVersion);
         for (Map.Entry<String, List<String>> entry : keyValuePairs.entrySet()) {
           String key = entry.getKey();
@@ -425,21 +425,20 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
     String json = null;
     try {
       json = mapper.writeValueAsString(map);
-    } catch (JsonProcessingException e) {
-      logger.log(Level.WARNING, "error in asJson()", e);
-    }
+-      logger.log(Level.WARNING, "error in asJson()", e);
++}
 
     return json;
-  }
+}
 
-  @Override
+@Override
   public boolean validate(MarcVersion marcVersion) {
     return validate(marcVersion, false, null);
-  }
+}
 
   public boolean validate(MarcVersion marcVersion, boolean isSummary) {
     return validate(marcVersion, isSummary, null);
-  }
+}
 
   public boolean validate(MarcVersion marcVersion,
                           boolean isSummary,
@@ -455,7 +454,7 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
     // ValidatorResponse validatorResponse;
 
     return isValidRecord;
-  }
+}
 
   private boolean validateLeader(MarcVersion marcVersion, boolean isValidRecord) {
     boolean isValidComponent;
@@ -467,9 +466,9 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
           leaderError.setRecordId(getId());
       validationErrors.addAll(leaderErrors);
       isValidRecord = isValidComponent;
-    }
+}
     return isValidRecord;
-  }
+}
 
   private boolean validateUnhandledTags(boolean isSummary, boolean isValidRecord, IgnorableFields ignorableFields) {
     if (!unhandledTags.isEmpty()) {
@@ -477,8 +476,8 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
         for (String tag : unhandledTags) {
           if (!isIgnorableField(tag, ignorableFields))
             validationErrors.add(new ValidationError(getId(), tag, ValidationErrorType.FIELD_UNDEFINED, tag, null));
-        }
-      } else {
+}
+} else {
         Map<String, Integer> tags = new LinkedHashMap<>();
         for (String tag : unhandledTags)
           Utils.count(tag, tags);
@@ -488,54 +487,54 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
           String tag = entry.getKey();
           if (entry.getValue() == 1)
             unhandledTagsList.add(tag);
-          else
+else
             unhandledTagsList.add(String.format("%s (%d*)", tag, entry.getValue()));
-        }
+}
         for (String tag : unhandledTagsList) {
           if (!isIgnorableField(tag, ignorableFields))
             validationErrors.add(new ValidationError(getId(), tag, ValidationErrorType.FIELD_UNDEFINED, tag, null));
+}
         }
-      }
 
       isValidRecord = false;
-    }
+}
     return isValidRecord;
-  }
+}
 
   private boolean validateControlfields(MarcVersion marcVersion, boolean isValidRecord) {
     boolean isValidComponent;
     for (MarcControlField controlField : getControlfields()) {
       if (controlField != null) {
         isValidComponent = controlField.validate(marcVersion);
-        if (!isValidComponent) {
+    if (!isValidComponent) {
           validationErrors.addAll(controlField.getValidationErrors());
-          isValidRecord = isValidComponent;
+      isValidRecord = isValidComponent;
+}
         }
       }
-    }
     return isValidRecord;
-  }
+}
 
   private boolean validateDatafields(MarcVersion marcVersion,
                                      boolean isValidRecord,
-                                     IgnorableFields ignorableFields) {
+                          IgnorableFields ignorableFields) {
     ValidatorResponse validatorResponse;
     Map<DataFieldDefinition, Integer> repetitionCounter = new HashMap<>();
     for (DataField field : datafields) {
       if (field.getDefinition() != null && !isIgnorableField(field.getTag(), ignorableFields)) {
         count(field.getDefinition(), repetitionCounter);
         if (!field.validate(marcVersion)) {
-          isValidRecord = false;
+      isValidRecord = false;
           validationErrors.addAll(field.getValidationErrors());
-        }
+}
 
         validatorResponse = ClassificationReferenceValidator.validate(field);
         if (!validatorResponse.isValid()) {
           validationErrors.addAll(validatorResponse.getValidationErrors());
-          isValidRecord = false;
+      isValidRecord = false;
+}
         }
       }
-    }
 
     for (Map.Entry<DataFieldDefinition, Integer> entry : repetitionCounter.entrySet()) {
       DataFieldDefinition fieldDefinition = entry.getKey();
@@ -546,23 +545,23 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
           ValidationErrorType.FIELD_NONREPEATABLE,
           String.format("there are %d instances", count),
           fieldDefinition.getDescriptionUrl()
-        ));
-        isValidRecord = false;
+));
+      isValidRecord = false;
+}
       }
-    }
     return isValidRecord;
-  }
+}
 
   private boolean isIgnorableField(String tag, IgnorableFields ignorableFields) {
     if (ignorableFields == null)
       return false;
     return ignorableFields.contains(tag);
-  }
+}
 
-  @Override
+@Override
   public List<ValidationError> getValidationErrors() {
     return validationErrors;
-  }
+}
 
   public List<String> search(String path, String query) {
     List<String> results = new ArrayList<>();
@@ -576,7 +575,7 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
         searchPositionalControlField(instance, path, query, results);
     } else if (path.startsWith("008")) {
       searchPositionalControlField(control008, path, query, results);
-    } else {
+} else {
       Matcher matcher = dataFieldPattern.matcher(path);
       if (matcher.matches()) {
         String tag = matcher.group(1);
@@ -584,81 +583,81 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
         if (datafieldIndex.containsKey(tag)) {
           for (DataField field : datafieldIndex.get(tag)) {
             if (searchDatafield(query, results, subfieldCode, field)) break;
+}
           }
         }
-      }
       matcher = positionalPattern.matcher(path);
       if (matcher.matches()) {
         searchByPosition(query, results, matcher);
+}
       }
-    }
     return results;
-  }
+}
 
   public List<String> select(MarcSpec selector) {
     List<String> results = new ArrayList<>();
     if (selector.getFieldTag().equals("LDR")) {
       if (selector.hasRangeSelector()) {
         results.add(selector.selectRange(leader.getContent()));
-      } else {
+} else {
         results.add(leader.getContent());
-      }
+}
     } else if (controlfieldIndex.containsKey(selector.getFieldTag())) {
       for (MarcControlField field : controlfieldIndex.get(selector.getFieldTag())) {
         if (field == null)
-          continue;
+continue;
         if (!simpleControlTags.contains(field.definition.getTag())) {
           // TODO: check control subfields
-        }
-        if (selector.hasRangeSelector()) {
+}
+      if (selector.hasRangeSelector()) {
           results.add(selector.selectRange(field.getContent()));
-        } else {
+} else {
           results.add(field.getContent());
+}
         }
-      }
 
     } else if (datafieldIndex.containsKey(selector.getFieldTag())) {
       for (DataField field : datafieldIndex.get(selector.getFieldTag())) {
         if (field == null)
-          continue;
+continue;
         for (String subfieldCode : selector.getSubfieldsAsList()) {
           List<MarcSubfield> subfields = field.getSubfield(subfieldCode);
           if (subfields == null)
-            continue;
+continue;
           for (MarcSubfield subfield : subfields) {
             results.add(subfield.getValue());
+}
           }
         }
       }
-    }
     else if (selector.getFieldTag().equals("008") && control008 != null) {
       if (selector.getCharStart() != null) {
         ControlfieldPositionDefinition definition = control008.getSubfieldByPosition(selector.getCharStart());
         results.add(control008.getMap().get(definition));
-      } else {
+} else {
         results.add(control008.getContent());
+}
       }
-    }
     return results;
-  }
+}
 
   private void searchByPosition(String query, List<String> results, Matcher matcher) {
-    String tag = matcher.group(1);
+        String tag = matcher.group(1);
     String position = matcher.group(2);
-    int start;
-    int end;
+int start;
+int end;
     if (position.contains("-")) {
       String[] parts = position.split("-", 2);
       start = Integer.parseInt(parts[0]);
       end = Integer.parseInt(parts[1]);
-    } else {
+} else {
       start = Integer.parseInt(position);
       end = start + 1;
-    }
+}
     String content = null;
     if (tag.equals("Leader")) {
       content = leader.getLeaderString();
-    } else {
+} else {
       MarcControlField controlField = null;
       // TODO: fix it!
       switch (tag) {
@@ -666,15 +665,15 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
         case "007": controlField = control007.get(0); break;
         case "008": controlField = control008; break;
         default: break;
-      }
-      if (controlField != null)
+}
+        if (controlField != null)
         content = controlField.getContent();
-    }
+}
 
     if (content != null && content.substring(start, end).equals(query)) {
       results.add(content.substring(start, end));
+}
     }
-  }
 
   private boolean searchDatafield(String query, List<String> results,
                                   String subfieldCode, DataField field) {
@@ -684,45 +683,45 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
     } else if (subfieldCode.equals("ind2") && field.getInd2().equals(query)) {
       results.add(field.getInd2());
       return true;
-    } else {
-      List<MarcSubfield> subfields = field.getSubfield(subfieldCode);
+} else {
+          List<MarcSubfield> subfields = field.getSubfield(subfieldCode);
       if (subfields != null) {
-        for (MarcSubfield subfield : subfields) {
+          for (MarcSubfield subfield : subfields) {
           if (subfield.getValue().equals(query)) {
             results.add(subfield.getValue());
-            return true;
+      return true;
+}
           }
         }
       }
-    }
-    return false;
-  }
+      return false;
+}
 
   private void searchControlField(String path, String query, List<String> results) {
-    MarcControlField controlField = null;
+      MarcControlField controlField = null;
     switch (path) {
       case "001": controlField = control001; break;
       case "003": controlField = control003; break;
       case "005": controlField = control005; break;
-      default: break;
-    }
+        default: break;
+}
     if (controlField != null && controlField.getContent().equals(query))
       results.add(controlField.getContent());
-  }
+}
 
   private void searchPositionalControlField(MarcPositionalControlField controlField,
                                             String path, String query, List<String> results) {
-    if (controlField != null) {
+      if (controlField != null) {
       Map<ControlfieldPositionDefinition, String> map = controlField.getMap();
       for (ControlfieldPositionDefinition subfield : controlField.getMap().keySet()) {
         if (subfield.getId().equals(path)) {
           if (map.get(subfield).equals(query))
             results.add(map.get(subfield));
-          break;
+break;
+}
         }
       }
     }
-  }
 
   public List<DataField> getAuthorityFields() {
     List<DataField> subjects = new ArrayList<>();
@@ -730,14 +729,14 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
       "100", "110", "111", "130",
       "700", "710", "711", "730",   "720", "740", "751", "752", "753", "754",
       "800", "810", "811", "830"
-    );
+);
     for (String tag : tags) {
-      List<DataField> fields = getDatafield(tag);
+    List<DataField> fields = getDatafield(tag);
       if (fields != null && !fields.isEmpty())
         subjects.addAll(fields);
-    }
+}
     return subjects;
-  }
+}
 
   public List<DataField> getSubjects() {
     List<DataField> subjects = new ArrayList<>();
@@ -745,35 +744,35 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
       "052", "055", "072", "080", "082", "083", "084", "085", "086",
       "600", "610", "611", "630", "647", "648", "650", "651",
       "653", "654", "655", "656", "657", "658", "662"
-    );
+);
     for (String tag : tags) {
-      List<DataField> fields = getDatafield(tag);
+    List<DataField> fields = getDatafield(tag);
       if (fields != null && !fields.isEmpty())
         subjects.addAll(fields);
-    }
+}
     return subjects;
-  }
+}
 
   public List<DataField> getSubject6xx() {
     List<DataField> subjects = new ArrayList<>();
     List<String> tags = Arrays.asList("600", "610", "611", "630", "648", "650", "651");
     for (String tag : tags) {
-      List<DataField> fields = getDatafield(tag);
+    List<DataField> fields = getDatafield(tag);
       if (fields != null && !fields.isEmpty())
         subjects.addAll(fields);
-    }
+}
     return subjects;
-  }
+}
 
   public void setField(String tag, String content) {
     setField(tag, content, MarcVersion.MARC21);
-  }
+}
 
   public void setField(String tag, String content, MarcVersion marcVersion) {
     if (marcVersion.equals(MarcVersion.UNIMARC)) {
       content = UnimarcConverter.contentFromUnimarc(tag, content);
       tag = UnimarcConverter.tagFromUnimarc(tag);
-    }
+}
 
     if (tag.equals("001")) {
       setControl001(new Control001(content));
@@ -787,16 +786,16 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
       setControl007(new Control007(content, this));
     } else if (tag.equals("008")) {
       setControl008(new Control008(content, this));
-    } else {
+} else {
       DataFieldDefinition definition = MarcFactory.getDataFieldDefinition(tag, marcVersion);
       if (definition == null) {
         addUnhandledTags(tag);
-      }
+}
 
       DataField dataField = new DataField(tag, content, marcVersion);
       addDataField(dataField);
+}
     }
-  }
 
   public void setField(String tag, String ind1, String ind2, String content, MarcVersion marcVersion) {
 
@@ -812,20 +811,20 @@ public class MarcRecord implements Extractable, Validatable, Serializable {
       setControl007(new Control007(content, this));
     } else if (tag.equals("008")) {
       setControl008(new Control008(content, this));
-    } else {
+} else {
       DataFieldDefinition definition = MarcFactory.getDataFieldDefinition(tag, marcVersion);
       if (definition == null) {
         addUnhandledTags(tag);
-      }
+}
       addDataField(new DataField(tag, ind1, ind2, content, marcVersion));
+}
     }
-  }
 
   public SchemaType getSchemaType() {
     return schemaType;
-  }
+}
 
   public void setSchemaType(SchemaType schemaType) {
     this.schemaType = schemaType;
-  }
 }
+  }
\ No newline at end of file