================================ System Message ================================

Act as an expert Java software developer.
The program has issues after a version upgrade of a dependency.
Try using minimal changes to the code to fix the issues. 
Do not explain your actions or ask questions, just provide diffs that always adhere to the rules.
When you think you are done, reply with the diff that fixes the issues, after that a final verification step will happen and the conversation will be ended if it was successful. If not you get the error back.

# File editing rules:
Return edits similar to unified diffs that `diff -U0` would produce.
The diff has to be in a markdown code block, like this: ```diff ```.

Make sure you include the first 2 lines with the file paths.
Don't include timestamps with the file paths.

Start each hunk of changes with a `@@ ... @@` line.
Don't include line numbers like `diff -U0` does.
The user's patch tool doesn't need them.

The user's patch tool needs CORRECT patches that apply cleanly against the current contents of the file!
Think carefully and make sure you include and mark all lines that need to be removed or changed as `-` lines.
Make sure you mark all new or modified lines with `+`.
Don't leave out any lines or the diff patch won't apply correctly.
Dont add in new comments or change existing comments.
Make sure the diff is minimal and only includes the changes needed to fix the issue plus at least one context line so the tool can apply the diff correctly.

Indentation matters in the diffs!

Start a new hunk for each section of the file that needs changes.
Dont include unnescessary context, but include at least one line of it.
If no context is included, the tool will try to apply the changes at the end of the line.

Only output hunks that specify changes with `+` or `-` lines.
Skip any hunks that are entirely unchanging ` ` lines.

Output hunks in whatever order makes the most sense.
Hunks don't need to be in any particular order.

When editing a function, method, loop, etc use a hunk to replace the *entire* code block.
Delete the entire existing version with `-` lines and then add a new, updated version with `+` lines.
This will help you generate correct code and correct diffs.

To make a new file, show a diff from `--- /dev/null` to `+++ path/to/new/file.ext`.


================================ Human Message =================================


Updated Dependency Details: com.hazelcast:hazelcast 3.12.5 -> 5.1

Initial Error: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project hazelcast: Compilation failure: Compilation failure:
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[22,28] cannot find symbol
[ERROR]   symbol:   class MaxSizeConfig
[ERROR]   location: package com.hazelcast.config
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[27,26] cannot find symbol
[ERROR]   symbol:   class Cluster
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[30,26] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[149,20] cannot find symbol
[ERROR]   symbol:   class Cluster
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[18,26] cannot find symbol
[ERROR]   symbol:   class Cluster
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[23,26] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[24,26] cannot find symbol
[ERROR]   symbol:   class MemberAttributeEvent
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[25,26] cannot find symbol
[ERROR]   symbol:   class MembershipEvent
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[26,26] cannot find symbol
[ERROR]   symbol:   class MembershipListener
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[52,41] cannot find symbol
[ERROR]   symbol: class MembershipListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[501,13] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[655,42] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[60,19] cannot find symbol
[ERROR]   symbol:   class Cluster
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[75,27] cannot find symbol
[ERROR]   symbol:   class Cluster
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[155,35] cannot find symbol
[ERROR]   symbol:   class MembershipEvent
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[228,37] cannot find symbol
[ERROR]   symbol:   class MembershipEvent
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[271,46] cannot find symbol
[ERROR]   symbol:   class MemberAttributeEvent
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[20,26] cannot find symbol
[ERROR]   symbol:   class IMap
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[21,26] cannot find symbol
[ERROR]   symbol:   class MapEvent
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[23,29] package com.hazelcast.monitor does not exist
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[58,11] cannot find symbol
[ERROR]   symbol:   class IMap
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[74,55] cannot find symbol
[ERROR]   symbol:   class IMap
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cluster/HazelcastClusterNodeInfo.java:[24,26] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: package com.hazelcast.core
[ERROR] src/java/org/jivesoftware/openfire/plugin/util/cluster/HazelcastClusterNodeInfo.java:[41,43] cannot find symbol
[ERROR]   symbol:   class Member
[ERROR]   location: class org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo
[ERROR] -> [Help 1]

Revapi/japicmp API Changes, which describe changes in the APIs used by this project: {"japicmpResult": {}, "elementLines": {}, "revapiResult": {}, "allPotentialBreakingElements": [], "elementPatterns": {}, "project": "openfire-hazelcast-plugin"}


================================== Ai Message ==================================
Tool Calls:
  get_directory_tree_for_path (call_Ftd47TPvb6aUzwz9tXlGRPo0)
 Call ID: call_Ftd47TPvb6aUzwz9tXlGRPo0
  Args:
    relative_directory_path: src/java/org/jivesoftware/openfire/plugin/util/cache

================================= Tool Message =================================
Name: get_directory_tree_for_path

[
    {
        "name": "ClusterClassLoader.java",
        "type": "file"
    },
    {
        "name": "ClusteredCache.java",
        "type": "file"
    },
    {
        "name": "ClusterExternalizableUtil.java",
        "type": "file"
    },
    {
        "name": "ClusterListener.java",
        "type": "file"
    },
    {
        "name": "ClusteredCacheFactory.java",
        "type": "file"
    }
]

================================== Ai Message ==================================
Tool Calls:
  read_file (call_O5mvPXxdb592aFrDaNscUF70)
 Call ID: call_O5mvPXxdb592aFrDaNscUF70
  Args:
    file_path: src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java

================================= Tool Message =================================
Name: read_file

/*
 * Copyright (C) 2007-2009 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.plugin.util.cache;

import com.hazelcast.config.ClasspathXmlConfig;
import com.hazelcast.config.Config;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MaxSizeConfig;
import com.hazelcast.config.MemberAttributeConfig;
import com.hazelcast.config.MemcacheProtocolConfig;
import com.hazelcast.config.NetworkConfig;
import com.hazelcast.config.RestApiConfig;
import com.hazelcast.core.Cluster;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.Member;
import org.jivesoftware.openfire.JMXManager;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.cluster.ClusterEventListener;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.cluster.ClusterNodeInfo;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.container.Plugin;
import org.jivesoftware.openfire.container.PluginClassLoader;
import org.jivesoftware.openfire.plugin.HazelcastPlugin;
import org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;
import org.jivesoftware.util.StringUtils;
import org.jivesoftware.util.SystemProperty;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.jivesoftware.util.cache.CacheFactoryStrategy;
import org.jivesoftware.util.cache.CacheWrapper;
import org.jivesoftware.util.cache.ClusterTask;
import org.jivesoftware.util.cache.ExternalizableUtil;
import org.jivesoftware.util.cache.ExternalizableUtilStrategy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.text.MessageFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * CacheFactory implementation to use when using Hazelcast in cluster mode.
 *
 * @author Tom Evans
 * @author Gaston Dombiak
 */
public class ClusteredCacheFactory implements CacheFactoryStrategy {

    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)
        .setKey("hazelcast.executor.service.name")
        .setDefaultValue("openfire::cluster::executor")
        .setDynamic(false)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)
        .setKey("hazelcast.max.execution.seconds")
        .setDefaultValue(Duration.ofSeconds(30))
        .setChronoUnit(ChronoUnit.SECONDS)
        .setDynamic(true)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)
        .setKey("hazelcast.startup.retry.seconds")
        .setDefaultValue(Duration.ofSeconds(10))
        .setChronoUnit(ChronoUnit.SECONDS)
        .setDynamic(true)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)
        .setKey("hazelcast.startup.retry.count")
        .setDefaultValue(1)
        .setDynamic(true)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)
        .setKey("hazelcast.config.xml.filename")
        .setDefaultValue("hazelcast-cache-config.xml")
        .setDynamic(false)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
        .setKey("hazelcast.config.jmx.enabled")
        .setDefaultValue(Boolean.FALSE)
        .setDynamic(false)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
        .setKey("hazelcast.config.rest.enabled")
        .setDefaultValue(Boolean.FALSE)
        .setDynamic(false)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();
    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
        .setKey("hazelcast.config.memcache.enabled")
        .setDefaultValue(Boolean.FALSE)
        .setDynamic(false)
        .setPlugin(HazelcastPlugin.PLUGIN_NAME)
        .build();

    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);
    public static final String PLUGIN_NAME = "hazelcast";

    /**
     * Keep serialization strategy the server was using before we set our strategy. We will
     * restore old strategy when plugin is unloaded.
     */
    private ExternalizableUtilStrategy serializationStrategy;

    /**
     * Storage for cache statistics
     */
    private static Map<String, Map<String, long[]>> cacheStats;

    private static HazelcastInstance hazelcast = null;
    private static Cluster cluster = null;
    private ClusterListener clusterListener;
    private String lifecycleListener;
    private String membershipListener;

    /**
     * Keeps that running state. Initial state is stopped.
     */
    private State state = State.stopped;

    /**
     * Used to limit the amount of duplicate warnings logged.
     */
    private final Cache<String, Instant> pluginClassLoaderWarnings;

    public ClusteredCacheFactory() {
        pluginClassLoaderWarnings = CacheFactory.createLocalCache("PluginClassLoader Warnings for Clustered Tasks");
        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.
    }

    @Override
    public boolean startCluster() {
        logger.info("Starting hazelcast clustering");
        state = State.starting;

        // Set the serialization strategy to use for transmitting objects between node clusters
        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();
        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());

        // Store previous class loader (in case we change it)
        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
        final ClassLoader loader = new ClusterClassLoader();
        Thread.currentThread().setContextClassLoader(loader);
        int retry = 0;
        do {
            try {
                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());
                final NetworkConfig networkConfig = config.getNetworkConfig();
                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {
                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));
                }
                if (!HAZELCAST_REST_ENABLED.getValue()) {
                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));
                }
                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();
                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());
                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());
                config.setInstanceName("openfire");
                config.setClassLoader(loader);
                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {
                    config.setProperty("hazelcast.jmx", "true");
                    config.setProperty("hazelcast.jmx.detailed", "true");
                }
                hazelcast = Hazelcast.newHazelcastInstance(config);
                cluster = hazelcast.getCluster();
                state = State.started;
                // CacheFactory is now using clustered caches. We can add our listeners.
                clusterListener = new ClusterListener(cluster);
                clusterListener.joinCluster();
                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);
                membershipListener = cluster.addMembershipListener(clusterListener);
                logger.info("Hazelcast clustering started");
                break;
            } catch (final Exception e) {
                cluster = null;
                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {
                    logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
                        "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
                    try {
                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());
                    } catch (final InterruptedException ignored) {
                        Thread.currentThread().interrupt();
                    }
                } else {
                    logger.error("Unable to start clustering - continuing in local mode", e);
                    state = State.stopped;
                }
            }
        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());

        if (oldLoader != null) {
            // Restore previous class loader
            Thread.currentThread().setContextClassLoader(oldLoader);
        }
        return cluster != null;
    }

    @Override
    public void stopCluster() {
        // Stop the cache services.
        cacheStats = null;
        // Update the running state of the cluster
        state = State.stopped;

        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));
        // Stop the cluster
        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);
        cluster.removeMembershipListener(membershipListener);
        Hazelcast.shutdownAll();
        cluster = null;
        lifecycleListener = null;
        membershipListener = null;
        clusterListener = null;

        // Reset packet router to use to deliver packets to remote cluster nodes
        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);
        // Reset the session locator to use
        XMPPServer.getInstance().setRemoteSessionLocator(null);
        // Set the old serialization strategy was using before clustering was loaded
        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);
    }

    @Override
    public Cache createCache(final String name) {
        // Check if cluster is being started up
        while (state == State.starting) {
            // Wait until cluster is fully started (or failed)
            try {
                Thread.sleep(250);
            } catch (final InterruptedException e) {
                // Ignore
            }
        }
        if (state == State.stopped) {
            throw new IllegalStateException("Cannot create clustered cache when not in a cluster");
        }
        // Determine the time to live. Note that in Hazelcast 0 means "forever", not -1
        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);
        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);
        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes
        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);
        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);
        // It's only possible to create a dynamic config if a static one doesn't already exist
        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);
        if (staticConfig == null) {
            final MapConfig dynamicConfig = new MapConfig(name);
            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);
            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));
            logger.debug("Creating dynamic map config for cache={}, dynamicConfig={}", name, dynamicConfig);
            hazelcast.getConfig().addMapConfig(dynamicConfig);
        } else {
            logger.debug("Static configuration already exists for cache={}, staticConfig={}", name, staticConfig);
        }
        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning
        @SuppressWarnings("unchecked") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));
        return clusteredCache;
    }

    @Override
    public void destroyCache(Cache cache) {
        if (cache instanceof CacheWrapper) {
            cache = ((CacheWrapper) cache).getWrappedCache();
        }

        final ClusteredCache clustered = (ClusteredCache) cache;
        clustered.destroy();
    }

    @Override
    public boolean isSeniorClusterMember() {
        if (clusterListener == null || !clusterListener.isClusterMember()) {
            return false;
        }
        return clusterListener.isSeniorClusterMember();
    }

    @Override
    public List<ClusterNodeInfo> getClusterNodesInfo() {
        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();
    }

    @Override
    public int getMaxClusterNodes() {
        // No longer depends on license code so just return a big number
        return 10000;
    }

    @Override
    public byte[] getSeniorClusterMemberID() {
        if (cluster != null && !cluster.getMembers().isEmpty()) {
            final Member oldest = cluster.getMembers().iterator().next();
            return getNodeID(oldest).toByteArray();
        } else {
            return null;
        }
    }

    @Override
    public byte[] getClusterMemberID() {
        if (cluster != null) {
            return getNodeID(cluster.getLocalMember()).toByteArray();
        } else {
            return null;
        }
    }

    /**
     * Gets the pseudo-synchronized time from the cluster. While the cluster members may
     * have varying system times, this method is expected to return a timestamp that is
     * synchronized (or nearly so; best effort) across the cluster.
     *
     * @return Synchronized time for all cluster members
     */
    @Override
    public long getClusterTime() {
        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();
    }

    /*
     * Execute the given task on the other (non-local) cluster members.
     * Note that this method does not provide the result set for the given
     * task, as the task is run asynchronously across the cluster.
     */
    @Override
    public void doClusterTask(final ClusterTask<?> task) {

        if (cluster == null) {
            return;
        }
        final Set<Member> members = new HashSet<>();
        final Member current = cluster.getLocalMember();
        for (final Member member : cluster.getMembers()) {
            if (!member.getUuid().equals(current.getUuid())) {
                members.add(member);
            }
        }


        if (!members.isEmpty()) {
            // Asynchronously execute the task on the other cluster members
            logger.debug("Executing asynchronous MultiTask: " + task.getClass().getName());
            checkForPluginClassLoader(task);
            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
        } else {
            logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
        }
    }

    /*
     * Execute the given task on the given cluster member.
     * Note that this method does not provide the result set for the given
     * task, as the task is run asynchronously across the cluster.
     */
    @Override
    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {
        if (cluster == null) {
            return;
        }
        final Member member = getMember(nodeID);
        // Check that the requested member was found
        if (member != null) {
            // Asynchronously execute the task on the target member
            logger.debug("Executing asynchronous DistributedTask: " + task.getClass().getName());
            checkForPluginClassLoader(task);
            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);
        } else {
            final String msg = MessageFormat.format("Requested node {0} not found in cluster", new String(nodeID, StandardCharsets.UTF_8));
            logger.warn(msg);
            throw new IllegalArgumentException(msg);
        }
    }

    /*
     * Execute the given task on the designated cluster members.
     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
     * (seconds) per member until the task is run on all members.
     */
    @Override
    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {
        if (cluster == null) {
            return Collections.emptyList();
        }
        final Set<Member> members = new HashSet<>();
        final Member current = cluster.getLocalMember();
        for (final Member member : cluster.getMembers()) {
            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {
                members.add(member);
            }
        }
        final Collection<T> result = new ArrayList<>();
        if (!members.isEmpty()) {
            // Asynchronously execute the task on the other cluster members
            try {
                logger.debug("Executing MultiTask: " + task.getClass().getName());
                checkForPluginClassLoader(task);
                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());
                for (final Future<T> future : futures.values()) {
                    final long start = System.nanoTime();
                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));
                    nanosLeft = nanosLeft - (System.nanoTime() - start);
                }
            } catch (final TimeoutException te) {
                logger.error("Failed to execute cluster task within " + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);
            } catch (final Exception e) {
                logger.error("Failed to execute cluster task", e);
            }
        } else {
            logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
        }
        return result;
    }

    /*
     * Execute the given task on the designated cluster member.
     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
     * (seconds) until the task is run on the given member.
     */
    @Override
    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {
        if (cluster == null) {
            return null;
        }
        final Member member = getMember(nodeID);
        T result = null;
        // Check that the requested member was found
        if (member != null) {
            // Asynchronously execute the task on the target member
            logger.debug("Executing DistributedTask: " + task.getClass().getName());
            checkForPluginClassLoader(task);
            try {
                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);
                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);
                logger.trace("DistributedTask result: {}", result);
            } catch (final TimeoutException te) {
                logger.error("Failed to execute cluster task within " + MAX_CLUSTER_EXECUTION_TIME + " seconds", te);
            } catch (final Exception e) {
                logger.error("Failed to execute cluster task", e);
            }
        } else {
            final String msg = MessageFormat.format("Requested node {0} not found in cluster", new String(nodeID, StandardCharsets.UTF_8));
            logger.warn(msg);
            throw new IllegalArgumentException(msg);
        }
        return result;
    }

    @Override
    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {
        if (cluster == null) {
            return null;
        }
        ClusterNodeInfo result = null;
        final Member member = getMember(nodeID);
        if (member != null) {
            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());
        }
        return result;
    }

    private Member getMember(final byte[] nodeID) {
        final NodeID memberToFind = NodeID.getInstance(nodeID);
        for (final Member member : cluster.getMembers()) {
            if (memberToFind.equals(getNodeID(member))) {
                return member;
            }
        }
        return null;
    }

    @Override
    public void updateCacheStats(final Map<String, Cache> caches) {
        if (!caches.isEmpty() && cluster != null) {
            // Create the cacheStats map if necessary.
            if (cacheStats == null) {
                cacheStats = hazelcast.getMap("opt-$cacheStats");
            }
            final String uid = getNodeID(cluster.getLocalMember()).toString();
            final Map<String, long[]> stats = new HashMap<>();
            for (final String cacheName : caches.keySet()) {
                final Cache cache = caches.get(cacheName);
                // The following information is published:
                // current size, max size, num elements, cache
                // hits, cache misses.
                final long[] info = new long[5];
                info[0] = cache.getLongCacheSize();
                info[1] = cache.getMaxCacheSize();
                info[2] = cache.size();
                info[3] = cache.getCacheHits();
                info[4] = cache.getCacheMisses();
                stats.put(cacheName, info);
            }
            // Publish message
            cacheStats.put(uid, stats);
        }
    }

    @Override
    public String getPluginName() {
        return PLUGIN_NAME;
    }

    @Override
    public Lock getLock(final Object key, Cache cache) {
        if (cache instanceof CacheWrapper) {
            cache = ((CacheWrapper) cache).getWrappedCache();
        }
        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)
        @SuppressWarnings("unchecked") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);
        return clusterLock;
    }

    /**
     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class
     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is
     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
     * limited by a time interval.
     *
     * @param o the instance for which to verify the class loader
     * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
     */
    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {
        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader
            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )
        {
            // Try to determine what plugin loaded the offending class.
            String pluginName = null;
            try {
                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();
                for (final Plugin plugin : plugins) {
                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);
                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {
                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);
                        break;
                    }
                }
            } catch (Exception e) {
                logger.debug("An exception occurred while trying to determine the plugin class loader that loaded an instance of {}", o.getClass(), e);
            }
            logger.warn("An instance of {} that is executed as a cluster task. This will cause issues when reloading " +
                    "the plugin that provides this class. The plugin implementation should be modified.",
                pluginName != null ? o.getClass() + " (provided by plugin " + pluginName + ")" : o.getClass());
            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.
        }
    }

    private static class ClusterLock implements Lock {

        private final Serializable key;
        private final ClusteredCache<Serializable, ?> cache;

        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {
            this.key = key;
            this.cache = cache;
        }

        @Override
        public void lock() {
            cache.lock(key, -1);
        }

        @Override
        public void lockInterruptibly() {
            cache.lock(key, -1);
        }

        @Override
        public boolean tryLock() {
            return cache.lock(key, 0);
        }

        @Override
        public boolean tryLock(final long time, final TimeUnit unit) {
            return cache.lock(key, unit.toMillis(time));
        }

        @Override
        public void unlock() {
            cache.unlock(key);
        }

        @Override
        public Condition newCondition() {
            throw new UnsupportedOperationException();
        }
    }

    private static class CallableTask<V> implements Callable<V>, Serializable {
        private static final long serialVersionUID = -8761271979427214681L;
        private final ClusterTask<V> task;

        CallableTask(final ClusterTask<V> task) {
            this.task = task;
        }

        @Override
        public V call() {
            try {
                task.run();
                logger.trace("CallableTask[{}] result: {}", task.getClass().getName(), task.getResult());
                return task.getResult();
            } catch (final Exception e) {
                logger.error("Unexpected exception running CallableTask[{}]", task.getClass().getName(), e);
                throw e;
            }
        }
    }

    private enum State {
        stopped,
        starting,
        started
    }

    public static NodeID getNodeID(final Member member) {
        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
    }

    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {
        final Semaphore leftClusterSemaphore = new Semaphore(0);
        final ClusterEventListener clusterEventListener = new ClusterEventListener() {
            @Override
            public void joinedCluster() {
            }

            @Override
            public void joinedCluster(final byte[] bytes) {
            }

            @Override
            public void leftCluster() {
                leftClusterSemaphore.release();
            }

            @Override
            public void leftCluster(final byte[] bytes) {
            }

            @Override
            public void markedAsSeniorClusterMember() {
            }
        };
        try {
            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling
            // has been invoked for all before proceeding.
            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);
            logger.debug("Firing leftCluster() event");
            ClusterManager.fireLeftCluster();
            logger.debug("Waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
                logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
            }
        } catch (final Exception e) {
            logger.error("Unexpected exception waiting for clustering to shut down", e);
        } finally {
            ClusterManager.removeListener(clusterEventListener);
        }
    }

}





================================== Ai Message ==================================
Tool Calls:
  read_file (call_t2hAIiquWxtLxOpa69PRajRp)
 Call ID: call_t2hAIiquWxtLxOpa69PRajRp
  Args:
    file_path: src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java

================================= Tool Message =================================
Name: read_file

/*
 * Copyright (C) 1999-2009 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jivesoftware.openfire.plugin.util.cache;

import com.hazelcast.core.Cluster;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.LifecycleEvent;
import com.hazelcast.core.LifecycleEvent.LifecycleState;
import com.hazelcast.core.LifecycleListener;
import com.hazelcast.core.Member;
import com.hazelcast.core.MemberAttributeEvent;
import com.hazelcast.core.MembershipEvent;
import com.hazelcast.core.MembershipListener;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.cluster.ClusterNodeInfo;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;
import org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.jivesoftware.util.cache.CacheWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state
 * of the routing table and the sessions within it when a node which manages those sessions goes down.
 */
public class ClusterListener implements MembershipListener, LifecycleListener {

    private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);

    private boolean seniorClusterMember = false;

    private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();
    
    private final Cluster cluster;
    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();
    
    /**
     * Flag that indicates if the listener has done all clean up work when noticed that the
     * cluster has been stopped. This will force Openfire to wait until all clean
     * up (e.g. changing caches implementations) is done before destroying the plugin.
     */
    private boolean done = true;
    /**
     * Flag that indicates if we've joined a cluster or not
     */
    private boolean clusterMember = false;
    private boolean isSenior;

    ClusterListener(final Cluster cluster) {

        this.cluster = cluster;
        for (final Member member : cluster.getMembers()) {
            clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),
                    new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));
        }
    }

    private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {
        if (cache instanceof CacheWrapper) {
            final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();
            if (wrapped instanceof ClusteredCache) {
                ((ClusteredCache)wrapped).addEntryListener(listener);
                // Keep track of the listener that we added to the cache
                entryListeners.put(cache, listener);
            }
        }
    }

    @SuppressWarnings("unchecked")
    private boolean isDone() {
        return done;
    }

    synchronized void joinCluster() {
        if (!isDone()) { // already joined
            return;
        }

        // Trigger events
        clusterMember = true;
        seniorClusterMember = isSeniorClusterMember();

        ClusterManager.fireJoinedCluster(false);

        if (seniorClusterMember) {
            ClusterManager.fireMarkedAsSeniorClusterMember();
        }

        waitForClusterCacheToBeInstalled();

        // Let the other nodes know that we joined the cluster
        logger.debug("Done joining the cluster. Now proceed informing other nodes that we joined the cluster.");
        CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());

        logger.info("Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}",
            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});
        done = false;
    }

    boolean isSeniorClusterMember() {
        // first cluster member is the oldest
        final Iterator<Member> members = cluster.getMembers().iterator();
        return members.next().getUuid().equals(cluster.getLocalMember().getUuid());
    }

    private synchronized void leaveCluster() {
        if (isDone()) { // not a cluster member
            return;
        }
        clusterMember = false;
        final boolean wasSeniorClusterMember = seniorClusterMember;
        seniorClusterMember = false;

        // Trigger event. Wait until the listeners have processed the event. Caches will be populated
        // again with local content.
        ClusterManager.fireLeftCluster();

        if (!XMPPServer.getInstance().isShuttingDown()) {
            // Remove traces of directed presences sent from local entities to handlers that no longer exist
            // At this point c2s sessions are gone from the routing table so we can identify expired sessions
            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();
        }
        logger.info("Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}",
            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});
        done = true;
    }

    @Override
    public void memberAdded(final MembershipEvent event) {
        logger.info("Received a Hazelcast memberAdded event {}", event);

        final boolean wasSenior = isSenior;
        isSenior = isSeniorClusterMember();
        // local member only
        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());
        if (event.getMember().localMember()) { // We left and re-joined the cluster
            joinCluster();

        } else {
            if (wasSenior && !isSenior) {
                logger.warn("Recovering from split-brain; firing leftCluster()/joinedCluster() events");
                ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));
                logger.debug("Firing joinedCluster() event");
                ClusterManager.fireJoinedCluster(false);

                try {
                    logger.debug("Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.");
                    Thread.sleep(30000L);
                } catch (InterruptedException e) {
                    logger.warn("30 Second wait was interrupted.", e);
                }

                // The following line was intended to wait until all local handling finishes before informing other
                // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.
                // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.
                waitForClusterCacheToBeInstalled();

                // Let the other nodes know that we joined the cluster
                logger.debug("Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.");
                CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());
            }
        }
        clusterNodesInfo.put(nodeID,
                new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));
    }

    /**
     * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful
     * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still
     * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently
     * discarded.
     *
     * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.
     *
     * @return Boolean indicating whether the clustered cache was actually observed to be installed.
     */
    private boolean waitForClusterCacheToBeInstalled() {
        boolean failed = false;
        if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {
            logger.debug("This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.", ClusteredCacheFactory.PLUGIN_NAME);
            LocalTime deadLine = LocalTime.now().plusMinutes(10L);
            while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    logger.trace("Thread was interrupted while waiting for cache strategy to change.");
                    failed = true;
                    break;
                }
            }
            if (!deadLine.isAfter(LocalTime.now())) {
                failed = true;
                logger.warn("Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());
            }
            logger.debug("Cache factory has been swapped to '{}'. Cluster join is considered complete.", ClusteredCacheFactory.PLUGIN_NAME);
        }

        return !failed;
    }

    @Override
    public void memberRemoved(final MembershipEvent event) {
        logger.info("Received a Hazelcast memberRemoved event {}", event);

        isSenior = isSeniorClusterMember();
        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());

        if (event.getMember().localMember()) {
            logger.info("Leaving cluster: " + nodeID);
            // This node may have realized that it got kicked out of the cluster
            leaveCluster();
        } else {
            // Trigger event that a node left the cluster
            ClusterManager.fireLeftCluster(nodeID.toByteArray());

            if (!seniorClusterMember && isSeniorClusterMember()) {
                seniorClusterMember = true;
                ClusterManager.fireMarkedAsSeniorClusterMember();
            }

            // Remove traces of directed presences sent from local entities to handlers that no longer exist.
            // At this point c2s sessions are gone from the routing table so we can identify expired sessions
            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();
        }
        // Delete nodeID instance (release from memory)
        NodeID.deleteInstance(nodeID.toByteArray());
        clusterNodesInfo.remove(nodeID);
    }
    
    @SuppressWarnings("WeakerAccess")
    public List<ClusterNodeInfo> getClusterNodesInfo() {
        return new ArrayList<>(clusterNodesInfo.values());
    }

    @Override
    public void stateChanged(final LifecycleEvent event) {
        if (event.getState().equals(LifecycleState.SHUTDOWN)) {
            leaveCluster();
        } else if (event.getState().equals(LifecycleState.STARTED)) {
            joinCluster();
        }
    }

    @Override
    public void memberAttributeChanged(final MemberAttributeEvent event) {
        logger.info("Received a Hazelcast memberAttributeChanged event {}", event);
        isSenior = isSeniorClusterMember();
        final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));
        clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),
                new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));
    }

    boolean isClusterMember() {
        return clusterMember;
    }
}


================================== Ai Message ==================================
Tool Calls:
  read_file (call_RmThboskTLrE4W8rm5ekceKo)
 Call ID: call_RmThboskTLrE4W8rm5ekceKo
  Args:
    file_path: src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java

================================= Tool Message =================================
Name: read_file

/*
 * Copyright (C) 1999-2009 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jivesoftware.openfire.plugin.util.cache;

import com.hazelcast.core.EntryEvent;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.IMap;
import com.hazelcast.core.MapEvent;
import com.hazelcast.map.listener.MapListener;
import com.hazelcast.monitor.LocalMapStats;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.container.Plugin;
import org.jivesoftware.openfire.container.PluginClassLoader;
import org.jivesoftware.openfire.container.PluginManager;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Clustered implementation of the Cache interface using Hazelcast.
 *
 */
public class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {

    private final Logger logger;

    private final Set<String> listeners = ConcurrentHashMap.newKeySet();

    /**
     * The map is used for distributed operations such as get, put, etc.
     */
    final IMap<K, V> map;
    private String name;
    private long numberOfGets = 0;

    /**
     * Used to limit the amount of duplicate warnings logged.
     */
    private Instant lastPluginClassLoaderWarning = Instant.EPOCH;
    private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);

    /**
     * Create a new cache using the supplied named cache as the actual cache implementation
     *
     * @param name a name for the cache, which should be unique per vm.
     * @param cache the cache implementation
     */
    protected ClusteredCache(final String name, final IMap<K, V> cache) {
        this.map = cache;
        this.name = name;
        logger = LoggerFactory.getLogger(ClusteredCache.class.getName() + "[cache: "+name+"]");
    }

    void addEntryListener(final MapListener listener) {
        listeners.add(map.addEntryListener(listener, false));
    }

    @Override
    public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)
    {
        final EntryListener<K, V> listener = new EntryListener<K, V>() {
            @Override
            public void mapEvicted(MapEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing map evicted event of node '{}'", eventNodeId);
                    clusteredCacheEntryListener.mapEvicted(eventNodeId);
                }
            }

            @Override
            public void mapCleared(MapEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing map cleared event of node '{}'", eventNodeId);
                    clusteredCacheEntryListener.mapCleared(eventNodeId);
                }
            }

            @Override
            public void entryUpdated(EntryEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing entry update event of node '{}' for key '{}'", eventNodeId, event.getKey());
                    clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);
                }
            }

            @Override
            public void entryRemoved(EntryEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing entry removed event of node '{}' for key '{}'", eventNodeId, event.getKey());
                    clusteredCacheEntryListener.entryRemoved((K) event.getKey(), (V) event.getOldValue(), eventNodeId);
                }
            }

            @Override
            public void entryEvicted(EntryEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing entry evicted event of node '{}' for key '{}'", eventNodeId, event.getKey());
                    clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);
                }
            }

            @Override
            public void entryAdded(EntryEvent event) {
                if (includeEventsFromLocalNode || !event.getMember().localMember()) {
                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
                    logger.trace("Processing entry added event of node '{}' for key '{}'", eventNodeId, event.getKey());
                    clusteredCacheEntryListener.entryAdded((K) event.getKey(), (V) event.getValue(), eventNodeId);
                }
            }
        };

        final String listenerId = map.addEntryListener(listener, includeValues);
        listeners.add(listenerId);
        logger.debug("Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'", includeValues, includeEventsFromLocalNode, listenerId);
        return listenerId;
    }

    @Override
    public void removeClusteredCacheEntryListener(@Nonnull final String listenerId) {
        logger.debug("Removing clustered cache entry listener: '{}'", listenerId);
        map.removeEntryListener(listenerId);
        listeners.remove(listenerId);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(final String name) {
        this.name = name;
    }

    @Override
    public V put(final K key, final V object) {
        if (object == null) { return null; }
        checkForPluginClassLoader(key);
        checkForPluginClassLoader(object);
        return map.put(key, object);
    }

    @Override
    public V get(final Object key) {
        numberOfGets++;
        return map.get(key);
    }

    @Override
    public V remove(final Object key) {
        return map.remove(key);
    }

    @Override
    public void clear() {
        map.clear();
    }

    @Override
    public int size() {
        final LocalMapStats stats = map.getLocalMapStats();
        return (int) (stats.getOwnedEntryCount() + stats.getBackupEntryCount());
    }

    @Override
    public boolean containsKey(final Object key) {
        return map.containsKey(key);
    }

    @Override
    public boolean containsValue(final Object value) {
        return map.containsValue(value);
    }

    @Override
    public Set<Map.Entry<K, V>> entrySet() {
        return map.entrySet();
    }

    @Override
    public boolean isEmpty() {
        return map.isEmpty();
    }

    @Override
    public Set<K> keySet() {
        return map.keySet();
    }

    @Override
    public void putAll(final Map<? extends K, ? extends V> entries) {
        map.putAll(entries);

        // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.
        entries.entrySet().stream().findAny().ifPresent(
            e -> {
                checkForPluginClassLoader(e.getKey());
                checkForPluginClassLoader(e.getValue());
            }
        );
    }

    @Override
    public Collection<V> values() {
        return map.values();
    }

    @Override
    public long getCacheHits() {
        return map.getLocalMapStats().getHits();
    }

    @Override
    public long getCacheMisses() {
        final long hits = map.getLocalMapStats().getHits();
        return numberOfGets > hits ? numberOfGets - hits : 0;
    }

    @Override
    public int getCacheSize() {
        return (int) getLongCacheSize();
    }

    @Override
    public long getLongCacheSize() {
        final LocalMapStats stats = map.getLocalMapStats();
        return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();
    }

    @Override
    public long getMaxCacheSize() {
        return CacheFactory.getMaxCacheSize(getName());
    }

    @Override
    public void setMaxCacheSize(int i) {
        setMaxCacheSize((long) i);
    }

    @Override
    public void setMaxCacheSize(final long maxSize) {
        CacheFactory.setMaxSizeProperty(getName(), maxSize);
    }

    @Override
    public long getMaxLifetime() {
        return CacheFactory.getMaxCacheLifetime(getName());
    }

    @Override
    public void setMaxLifetime(final long maxLifetime) {
        CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);
    }

    void destroy() {
        listeners.forEach(map::removeEntryListener);
        map.destroy();
    }

    boolean lock(final K key, final long timeout) {
        boolean result = true;
        if (timeout < 0) {
            map.lock(key);
        } else if (timeout == 0) {
            result = map.tryLock(key);
        } else {
            try {
                result = map.tryLock(key, timeout, TimeUnit.MILLISECONDS);
            } catch (final InterruptedException e) {
                logger.error("Failed to get cluster lock", e);
                result = false;
            }
        }
        return result;
    }

    void unlock(final K key) {
        try {
            map.unlock(key);
        } catch (final IllegalMonitorStateException e) {
            logger.error("Failed to release cluster lock", e);
        }
    }

    /**
     * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause
     * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is
     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
     * limited by a time interval.
     *
     * @param o the instance for which to verify the class loader
     * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
     */
    protected void checkForPluginClassLoader(final Object o) {
        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader
            && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )
        {
            // Try to determine what plugin loaded the offending class.
            String pluginName = null;
            try {
                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();
                for (final Plugin plugin : plugins) {
                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);
                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {
                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);
                        break;
                    }
                }
            } catch (Exception e) {
                logger.debug("An exception occurred while trying to determine the plugin class loader that loaded an instance of {}", o.getClass(), e);
            }
            logger.warn("An instance of {} that is loaded by {} has been added to the cache. " +
                "This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.",
                o.getClass(), pluginName != null ? pluginName : "a PluginClassLoader");
            lastPluginClassLoaderWarning = Instant.now();
        }
    }
}


================================== Ai Message ==================================
Tool Calls:
  read_file (call_93PoxQhvqR8BTATsZOpSPvxs)
 Call ID: call_93PoxQhvqR8BTATsZOpSPvxs
  Args:
    file_path: src/java/org/jivesoftware/openfire/plugin/util/cluster/HazelcastClusterNodeInfo.java

================================= Tool Message =================================
Name: read_file

/*
 * Copyright (C) 1999-2009 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.plugin.util.cluster;

import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.cluster.ClusterNodeInfo;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory;

import com.hazelcast.core.Member;

/**
 * Cluster Node information as provided by Hazelcast.
 *
 * @author Tom Evans
 * @author Gaston Dombiak
 */
public class HazelcastClusterNodeInfo implements ClusterNodeInfo {

    public static final String HOST_NAME_ATTRIBUTE = "hostname";
    public static final String NODE_ID_ATTRIBUTE = "node-id";
    private final String hostname;
    private final NodeID nodeID;
    private final long joinedTime;
    private final boolean seniorMember;

    public HazelcastClusterNodeInfo(final Member member, final long joinedTime) {
        this.hostname = member.getStringAttribute(HOST_NAME_ATTRIBUTE) + " (" + member.getSocketAddress().getHostString() + ")";
        this.nodeID = ClusteredCacheFactory.getNodeID(member);
        this.joinedTime = joinedTime;
        this.seniorMember = ClusterManager.getSeniorClusterMember().equals(nodeID);
    }

    public String getHostName() {
        return hostname;
    }

    public NodeID getNodeID() {
        return nodeID;
    }

    public long getJoinedTime() {
        return joinedTime;
    }

    public boolean isSeniorMember() {
        return seniorMember;
    }
}


================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -6 +6 @@
 import com.hazelcast.config.ClasspathXmlConfig;
@@ -9,2 +9,0 @@
-import com.hazelcast.config.MaxSizeConfig;
-import com.hazelcast.config.MemberAttributeConfig;
@@ -12,0 +10 @@
+import com.hazelcast.config.InstanceNameConfig;
@@ -13,0 +12 @@
+import com.hazelcast.config.MapSizeConfig;
@@ -14,0 +14 @@
+import com.hazelcast.config.MemberAttributeConfig;
@@ -15,0 +16 @@
+import com.hazelcast.config.MemcacheProtocolConfig;
@@ -16,0 +18 @@
+import com.hazelcast.config.NetworkConfig;
@@ -17,0 +20 @@
+import com.hazelcast.config.RestApiConfig;
@@ -18,0 +22 @@
+import com.hazelcast.instance.impl.HazelcastInstanceFactory;
@@ -19,0 +24 @@
+import com.hazelcast.cluster.Cluster;
@@ -20,0 +26 @@
+import com.hazelcast.cluster.Member;
@@ -21,0 +28 @@
+import com.hazelcast.core.HazelcastInstance;
@@ -22,0 +30 @@
+import com.hazelcast.map.IMap;
@@ -23,0 +32 @@
+import com.hazelcast.map.listener.MapListener;
@@ -24,0 +34 @@
+import com.hazelcast.monitor.LocalMapStats;
@@ -25,0 +36 @@
+import com.hazelcast.spi.impl.executionservice.ExecutionService;
@@ -26,0 +38 @@
+import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;
@@ -27,0 +40 @@
+import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;
@@ -28,0 +42 @@
+import com.hazelcast.spi.impl.servicemanager.ServiceManager;
@@ -29,0 +44 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;
@@ -30,0 +46 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;
@@ -31,0 +48 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;
@@ -32,0 +50 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;
@@ -33,0 +52 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;
@@ -34,0 +54 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;
@@ -35,0 +56 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;
@@ -36,0 +58 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;
@@ -37,0 +60 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;
@@ -38,0 +62 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -39,0 +64 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -40,0 +66 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -41,0 +68 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -42,0 +70 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -43,0 +72 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -44,0 +74 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -45,0 +76 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -46,0 +78 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl
Tool Calls:
  compile_maven_stateful (649LI9XSO)
 Call ID: 649LI9XSO
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -6 +6 @@
 import com.hazelcast.config.ClasspathXmlConfig;
@@ -9,2 +9,0 @@
-import com.hazelcast.config.MaxSizeConfig;
-import com.hazelcast.config.MemberAttributeConfig;
@@ -12,0 +10 @@
+import com.hazelcast.config.InstanceNameConfig;
@@ -13,0 +12 @@
+import com.hazelcast.config.MapSizeConfig;
@@ -14,0 +14 @@
+import com.hazelcast.config.MemberAttributeConfig;
@@ -15,0 +16 @@
+import com.hazelcast.config.MemcacheProtocolConfig;
@@ -16,0 +18 @@
+import com.hazelcast.config.NetworkConfig;
@@ -17,0 +20 @@
+import com.hazelcast.config.RestApiConfig;
@@ -18,0 +22 @@
+import com.hazelcast.instance.impl.HazelcastInstanceFactory;
@@ -19,0 +24 @@
+import com.hazelcast.cluster.Cluster;
@@ -20,0 +26 @@
+import com.hazelcast.cluster.Member;
@@ -21,0 +28 @@
+import com.hazelcast.core.HazelcastInstance;
@@ -22,0 +30 @@
+import com.hazelcast.map.IMap;
@@ -23,0 +32 @@
+import com.hazelcast.map.listener.MapListener;
@@ -24,0 +34 @@
+import com.hazelcast.monitor.LocalMapStats;
@@ -25,0 +36 @@
+import com.hazelcast.spi.impl.executionservice.ExecutionService;
@@ -26,0 +38 @@
+import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;
@@ -27,0 +40 @@
+import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;
@@ -28,0 +42 @@
+import com.hazelcast.spi.impl.servicemanager.ServiceManager;
@@ -29,0 +44 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;
@@ -30,0 +46 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;
@@ -31,0 +48 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;
@@ -32,0 +50 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;
@@ -33,0 +52 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;
@@ -34,0 +54 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;
@@ -35,0 +56 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;
@@ -36,0 +58 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;
@@ -37,0 +60 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;
@@ -38,0 +62 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -39,0 +64 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -40,0 +66 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -41,0 +68 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -42,0 +70 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -43,0 +72 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;
@@ -44,0 +74 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -45,0 +76 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;
@@ -46,0 +78 @@
+import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (94WDL0ZBV)
 Call ID: 94WDL0ZBV
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+// Fixing the issue
```
Tool Calls:
  compile_maven_stateful (call_fwHIAsctlDERmvkRTuUIdUGw)
 Call ID: call_fwHIAsctlDERmvkRTuUIdUGw
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+// Fixing the issue
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (call_M4SA8vhuRIHT1iAd3WlPQ9RG)
 Call ID: call_M4SA8vhuRIHT1iAd3WlPQ9RG
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (call_04xQpaHCncGtjrl5he5Ejg4w)
 Call ID: call_04xQpaHCncGtjrl5he5Ejg4w
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (call_y1BDWQVIoSXJwRzT6VxeNtvs)
 Call ID: call_y1BDWQVIoSXJwRzT6VxeNtvs
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n\n\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (call_NY811WM7wKhA5cb52FWPmKp3)
 Call ID: call_NY811WM7wKhA5cb52FWPmKp3
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n\n\n\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}

================================== Ai Message ==================================

```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```
Tool Calls:
  compile_maven_stateful (call_jDgnqI6xl1FitPF4zudKVzwK)
 Call ID: call_jDgnqI6xl1FitPF4zudKVzwK
  Args:
    diff: ```diff
--- src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
+++ src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java
@@ -701,0 +702,1 @@
+
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": false, "test_has_succeeded": false, "error_text": "class, interface, or enum expected\n", "updated_files": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\nimport com.hazelcast.config.InstanceNameConfig;\nimport com.hazelcast.config.MapSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.instance.impl.HazelcastInstanceFactory;\nimport com.hazelcast.cluster.Cluster;\nimport com.hazelcast.cluster.Member;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport com.hazelcast.spi.impl.executionservice.ExecutionService;\nimport com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;\nimport com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;\nimport com.hazelcast.spi.impl.servicemanager.ServiceManager;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\nimport com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;\n\n// Fixing the issue\n\n\n\n\n\n"}, "compile_error_details": {"src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java": {"702": {"lines": [{"line_no": 701, "content": ""}, {"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}], "error_texts": ["[702,1] class, interface, or enum expected\n"]}, "703": {"lines": [{"line_no": 702, "content": "import com.hazelcast.config.InstanceNameConfig;"}, {"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}], "error_texts": ["[703,1] class, interface, or enum expected\n"]}, "704": {"lines": [{"line_no": 703, "content": "import com.hazelcast.config.MapSizeConfig;"}, {"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}], "error_texts": ["[704,1] class, interface, or enum expected\n"]}, "705": {"lines": [{"line_no": 704, "content": "import com.hazelcast.config.MemberAttributeConfig;"}, {"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}], "error_texts": ["[705,1] class, interface, or enum expected\n"]}, "706": {"lines": [{"line_no": 705, "content": "import com.hazelcast.config.MemcacheProtocolConfig;"}, {"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}], "error_texts": ["[706,1] class, interface, or enum expected\n"]}, "707": {"lines": [{"line_no": 706, "content": "import com.hazelcast.config.NetworkConfig;"}, {"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}], "error_texts": ["[707,1] class, interface, or enum expected\n"]}, "708": {"lines": [{"line_no": 707, "content": "import com.hazelcast.config.RestApiConfig;"}, {"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}], "error_texts": ["[708,1] class, interface, or enum expected\n"]}, "709": {"lines": [{"line_no": 708, "content": "import com.hazelcast.instance.impl.HazelcastInstanceFactory;"}, {"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}], "error_texts": ["[709,1] class, interface, or enum expected\n"]}, "710": {"lines": [{"line_no": 709, "content": "import com.hazelcast.cluster.Cluster;"}, {"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}], "error_texts": ["[710,1] class, interface, or enum expected\n"]}, "711": {"lines": [{"line_no": 710, "content": "import com.hazelcast.cluster.Member;"}, {"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}], "error_texts": ["[711,1] class, interface, or enum expected\n"]}, "712": {"lines": [{"line_no": 711, "content": "import com.hazelcast.core.HazelcastInstance;"}, {"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}], "error_texts": ["[712,1] class, interface, or enum expected\n"]}, "713": {"lines": [{"line_no": 712, "content": "import com.hazelcast.map.IMap;"}, {"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}], "error_texts": ["[713,1] class, interface, or enum expected\n"]}, "714": {"lines": [{"line_no": 713, "content": "import com.hazelcast.map.listener.MapListener;"}, {"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}], "error_texts": ["[714,1] class, interface, or enum expected\n"]}, "715": {"lines": [{"line_no": 714, "content": "import com.hazelcast.monitor.LocalMapStats;"}, {"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}], "error_texts": ["[715,1] class, interface, or enum expected\n"]}, "716": {"lines": [{"line_no": 715, "content": "import com.hazelcast.spi.impl.executionservice.ExecutionService;"}, {"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}], "error_texts": ["[716,1] class, interface, or enum expected\n"]}, "717": {"lines": [{"line_no": 716, "content": "import com.hazelcast.spi.impl.executionservice.impl.ExecutionServiceImpl;"}, {"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}], "error_texts": ["[717,1] class, interface, or enum expected\n"]}, "718": {"lines": [{"line_no": 717, "content": "import com.hazelcast.spi.impl.proxyservice.impl.ProxyServiceImpl;"}, {"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}], "error_texts": ["[718,1] class, interface, or enum expected\n"]}, "719": {"lines": [{"line_no": 718, "content": "import com.hazelcast.spi.impl.servicemanager.ServiceManager;"}, {"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}], "error_texts": ["[719,1] class, interface, or enum expected\n"]}, "720": {"lines": [{"line_no": 719, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl;"}, {"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}], "error_texts": ["[720,1] class, interface, or enum expected\n"]}, "721": {"lines": [{"line_no": 720, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig;"}, {"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}], "error_texts": ["[721,1] class, interface, or enum expected\n"]}, "722": {"lines": [{"line_no": 721, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder;"}, {"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}], "error_texts": ["[722,1] class, interface, or enum expected\n"]}, "723": {"lines": [{"line_no": 722, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl;"}, {"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}], "error_texts": ["[723,1] class, interface, or enum expected\n"]}, "724": {"lines": [{"line_no": 723, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder;"}, {"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}], "error_texts": ["[724,1] class, interface, or enum expected\n"]}, "725": {"lines": [{"line_no": 724, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl;"}, {"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[725,1] class, interface, or enum expected\n"]}, "726": {"lines": [{"line_no": 725, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder;"}, {"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[726,1] class, interface, or enum expected\n"]}, "727": {"lines": [{"line_no": 726, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[727,1] class, interface, or enum expected\n"]}, "728": {"lines": [{"line_no": 727, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[728,1] class, interface, or enum expected\n"]}, "729": {"lines": [{"line_no": 728, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[729,1] class, interface, or enum expected\n"]}, "730": {"lines": [{"line_no": 729, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[730,1] class, interface, or enum expected\n"]}, "731": {"lines": [{"line_no": 730, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[731,1] class, interface, or enum expected\n"]}, "732": {"lines": [{"line_no": 731, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}], "error_texts": ["[732,1] class, interface, or enum expected\n"]}, "733": {"lines": [{"line_no": 732, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[733,1] class, interface, or enum expected\n"]}, "734": {"lines": [{"line_no": 733, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder;"}, {"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}], "error_texts": ["[734,1] class, interface, or enum expected\n"]}, "735": {"lines": [{"line_no": 734, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 735, "content": "import com.hazelcast.spi.impl.servicemanager.impl.ServiceManagerImpl.ServiceManagerConfig.ServiceManagerConfigBuilder.ServiceManagerConfigBuilderImpl.ServiceManagerConfigBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilder.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl.ServiceManagerConfigBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImplBuilderImpl;"}, {"line_no": 736, "content": ""}], "error_texts": ["[735,1] class, interface, or enum expected\n"]}}}}