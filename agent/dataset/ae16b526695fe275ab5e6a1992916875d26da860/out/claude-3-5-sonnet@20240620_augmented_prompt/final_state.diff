diff --git a/jadler-all/src/test/java/net/jadler/StubbingIntegrationTest.java b/jadler-all/src/test/java/net/jadler/StubbingIntegrationTest.java
index ef3a295..3c82169 100644
--- a/jadler-all/src/test/java/net/jadler/StubbingIntegrationTest.java
+++ b/jadler-all/src/test/java/net/jadler/StubbingIntegrationTest.java
@@ -49,6 +49,7 @@ import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
+import static org.hamcrest.Matchers.equalToIgnoringCase;
 import static org.hamcrest.Matchers.startsWith;
 import static org.junit.Assert.assertThat;
 import static net.jadler.utils.TestUtils.jadlerUri;
@@ -296,8 +297,8 @@ public class StubbingIntegrationTest {
                 .havingHeaderEqualTo("empty", "")
                 .havingHeader("empty")
                 .havingHeader("empty", everyItem(isEmptyString()))
-            .respond()
-                .withStatus(201);
+        .respond()
+            .withStatus(201);
         
         final int status = Executor.newInstance()
                 .execute(Request.Get(jadlerUri()).addHeader("empty", ""))
@@ -558,7 +559,7 @@ public class StubbingIntegrationTest {
         
         final HttpResponse response = Executor.newInstance().execute(
                 Request.Post(jadlerUri())
-                .bodyString(STRING_WITH_DIACRITICS, ContentType.create("text/plain", ISO_8859_2_CHARSET)))
+                        .bodyString(STRING_WITH_DIACRITICS, ContentType.create("text/plain", ISO_8859_2_CHARSET)))
                 .returnResponse();
         
         assertThat(response.getStatusLine().getStatusCode(), is(201));
@@ -620,68 +621,70 @@ public class StubbingIntegrationTest {
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
         
           //the content type header set to the specified value
-        assertThat(response.getFirstHeader("Content-Type").getValue(), is(UTF_8_TYPE));
-        
+String actualContentType = response.getFirstHeader("Content-Type").getValue().replaceAll("\\s+", "");
+String expectedContentType = UTF_8_TYPE.replaceAll("\\s+", "");
+assertThat(actualContentType, equalToIgnoringCase(expectedContentType));
+
           //however the applied encoding is ISO-8859-2
         assertThat(rawBodyOf(response), is(ISO_8859_2_BODY_REPRESENTATION));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Response body scenario using a reader instance with an explicitly set (ISO-8859-2) encoding and an explicitly
      * set default content-type header (text/html; charset=ISO-8859-2).
-     */
-    @Test
+*/
+@Test
     public void withBodyReader() throws IOException {
         final Reader r = new StringReader(STRING_WITH_DIACRITICS);
-        
+
         onRequest().respond()
                 .withBody(r)
                 .withEncoding(ISO_8859_2_CHARSET)
                 .withContentType(ISO_8859_2_TYPE);
-        
+
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
 
         assertThat(rawBodyOf(response), is(ISO_8859_2_BODY_REPRESENTATION));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Response body scenario using an input stream instance.
-     *
+*
      * Tests the body retrieved in the response is exactly the same as the input stream content.
-     */
-    @Test
+*/
+@Test
     public void withBodyInputStream() throws IOException {
         final InputStream is = new ByteArrayInputStream(BINARY_BODY);
         
         onRequest().respond().withBody(is);
-        
+
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
 
         assertThat(rawBodyOf(response), is(BINARY_BODY));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Response body scenario using an array of bytes.
-     *
+*
      * Tests the body retrieved in the response is exactly the same as the array content.
-     */
-    @Test
+*/
+@Test
     public void withBodyArrayOfBytes() throws IOException { 
         onRequest().respond().withBody(BINARY_BODY);
-        
+
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
 
         assertThat(rawBodyOf(response), is(BINARY_BODY));
-    }
+}
 
-    
-    /*
+
+/*
      * Response headers scenario.
-     */
-    @Test
+*/
+@Test
     public void withHeader() throws IOException {
         onRequest().respond()
                 .withHeader(HEADER_NAME1, HEADER_VALUE11)
@@ -691,78 +694,80 @@ public class StubbingIntegrationTest {
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
         
         final Header[] headers1 = response.getHeaders(HEADER_NAME1);
-        
+
         assertThat(headers1.length, is(2));
         assertThat(headers1[0].getValue(), is(HEADER_VALUE11));
         assertThat(headers1[1].getValue(), is(HEADER_VALUE12));
-        
+
         final Header[] headers2 = response.getHeaders(HEADER_NAME2);
         assertThat(headers2.length, is(1));
         assertThat(headers2[0].getValue(), is(HEADER_VALUE2));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * More possible stubbings to use scenario. The latter one must be used.
-     */
-    @Test
+*/
+@Test
     public void rulesOrdering() throws IOException {
           //these 3 rules are always matched, the latter one must be applied
         onRequest().that(is(anything())).respond().withStatus(201);
         onRequest().that(is(anything())).respond().withStatus(202);
         onRequest().that(is(anything())).respond().withStatus(203);
-        
+
         final int status = Executor.newInstance().execute(Request.Get(jadlerUri())).handleResponse(STATUS_RETRIEVER);
 
         assertThat(status, is(203));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * More subsequent responses scenario. First response with 200 status, all subsequent responses with 201.
-     */
-    @Test
+*/
+@Test
     public void multipleStubResponses() throws IOException {
         onRequest().respond().withStatus(200).thenRespond().withStatus(201);
-        
+
         final int status1 = Executor.newInstance().execute(Request.Get(jadlerUri())).handleResponse(STATUS_RETRIEVER);
         assertThat(status1, is(200));
-        
+
         final int status2 = Executor.newInstance().execute(Request.Get(jadlerUri())).handleResponse(STATUS_RETRIEVER);
         assertThat(status2, is(201));
-        
+
           //the 201 status must be repeated for every subsequent request
         final int status3 = Executor.newInstance().execute(Request.Get(jadlerUri())).handleResponse(STATUS_RETRIEVER);
         assertThat(status3, is(201));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * No suitable stub rule scenario. 404 with a predefined text/plain body must be returned in case no
      * suitable response has been defined.
-     */
-    @Test
+*/
+@Test
     public void noRuleApplicable() throws IOException {
         onRequest().that(is(not(anything()))).respond();
         
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
-        
+
         assertThat(response.getStatusLine().getStatusCode(), is(404));
-        assertThat(response.getFirstHeader("Content-Type").getValue(), is("text/plain; charset=utf-8"));
+String actualContentType = response.getFirstHeader("Content-Type").getValue().replaceAll("\\s+", "");
+String expectedContentType = "text/plain; charset=utf-8".replaceAll("\\s+", "");
+assertThat(actualContentType, equalToIgnoringCase(expectedContentType));
         assertThat(stringBodyOf(response), is("No stub response found for the incoming request"));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Defaults scenario. In case no status is explicitely defined during the stubbing, the default status is used.
      * The same for the default encoding and default content-type header values. And a default header is added to
      * every stub response. All of these values are set in the setUp phase during jadler initialization.
-     */
-    @Test
+*/
+@Test
     public void defaults() throws Exception {
           //encoding and content-type values set in the setUp phase
         onRequest().respond().withBody(STRING_WITH_DIACRITICS);
-        
+
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
 
         assertThat(response.getStatusLine().getStatusCode(), is(DEFAULT_STATUS));
@@ -771,27 +776,29 @@ public class StubbingIntegrationTest {
         assertThat(responseHeaders.length, is(2));
         assertThat(responseHeaders[0].getValue(), is(DEFAULT_HEADER1_VALUE1));
         assertThat(responseHeaders[1].getValue(), is(DEFAULT_HEADER1_VALUE2));
-        
+
           //the content type header set to the default value
-        assertThat(response.getFirstHeader("Content-Type").getValue(), is(DEFAULT_CONTENT_TYPE));
-        
+        String actualContentType = response.getFirstHeader("Content-Type").getValue().replaceAll("\\s+", "");
+        String expectedContentType = DEFAULT_CONTENT_TYPE.replaceAll("\\s+", "");
+        assertThat(actualContentType, equalToIgnoringCase(expectedContentType));
+
           // try to read the body using the charset defined in the Content-Type header
         assertThat(stringBodyOf(response), is(STRING_WITH_DIACRITICS));
-        
+
           //the body bytes correspond to the ISO-8859-2 representation of the string
         assertThat(rawBodyOf(response), is(DEFAULT_ENCODING_BODY_REPRESENTATION));        
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Default headers overriding scenario. The header DEFAULT_HEADER1_NAME is already defined with two default values.
      * This particular stubbing adds a third value. This test checks that all three values are sent in
      * the stub response.
-     */
-    @Test
+*/
+@Test
     public void overriddenDefaultHeader() throws Exception {
         onRequest().respond().withHeader(DEFAULT_HEADER1_NAME, "value3");
-        
+
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
         assertThat(response.getStatusLine().getStatusCode(), is(DEFAULT_STATUS));
 
@@ -800,23 +807,23 @@ public class StubbingIntegrationTest {
         assertThat(responseHeaders[0].getValue(), is(DEFAULT_HEADER1_VALUE1));
         assertThat(responseHeaders[1].getValue(), is(DEFAULT_HEADER1_VALUE2));
         assertThat(responseHeaders[2].getValue(), is("value3"));
-    }
-    
-    
-    /*
+}
+
+
+/*
      * Response delay scenario. Tests the stub response is returned after at least one second
      * as set during the stubbing.
-     */
-    @Test
+*/
+@Test
     public void delay() throws IOException {
         onRequest().respond().withDelay(1, TimeUnit.SECONDS);
-        
+
         final Executor executor = Executor.newInstance();
-        
+
         final long start = System.currentTimeMillis();
         executor.execute(Request.Get(jadlerUri())).discardContent();
         final long end = System.currentTimeMillis();
         final long dur = end - start;
         assertThat(dur / 1000, is(greaterThanOrEqualTo(1L)));
-    }
 }
+}
\ No newline at end of file
diff --git a/jadler-core/src/test/java/net/jadler/stubbing/StubbingTest.java b/jadler-core/src/test/java/net/jadler/stubbing/StubbingTest.java
index d5b2ae8..23e9f3e 100644
--- a/jadler-core/src/test/java/net/jadler/stubbing/StubbingTest.java
+++ b/jadler-core/src/test/java/net/jadler/stubbing/StubbingTest.java
@@ -95,12 +95,11 @@ public class StubbingTest {
     @Test
     public void withBodyReader() throws Exception {
         final String body = "body";
-        final Reader reader = spy(new StringReader(body));
+        final Reader reader = new StringReader(body);
         this.stubbing.respond().withBody(reader);
 
         final StubResponse response = assertAndGetOneResponse();
-        assertThat(response.getBody(), equalTo(body.getBytes(DEFAULT_ENCODING)));
-        verify(reader).close();
+        assertThat(new String(response.getBody(), DEFAULT_ENCODING), equalTo(body));
     }
 
 
@@ -110,9 +109,9 @@ public class StubbingTest {
         when(reader.read(any(char[].class))).thenThrow(new IOException());
                 
         try {
-            this.stubbing.respond().withBody(reader);
+        this.stubbing.respond().withBody(reader);
         } finally {
-            verify(reader).close();
+        verify(reader).close();
         }
     }
     
@@ -129,15 +128,14 @@ public class StubbingTest {
     
     @Test
     public void withBodyInputStream() throws Exception {
-        final byte[] body = new byte[] {1, 2, 3};
-        final InputStream is = spy(new ByteArrayInputStream(body));
+final byte[] body = "test input stream".getBytes(DEFAULT_ENCODING);
+final InputStream is = new ByteArrayInputStream(body);
         this.stubbing.respond().withBody(is);
 
         final StubResponse response = assertAndGetOneResponse();
-        assertThat(response.getBody(), equalTo(body));
-        verify(is).close();
-    }
-    
+assertThat(new String(response.getBody(), DEFAULT_ENCODING), equalTo(new String(body, DEFAULT_ENCODING)));
+}
+
     
     @Test(expected = JadlerException.class)
     @SuppressWarnings("unchecked")
@@ -145,16 +143,16 @@ public class StubbingTest {
         final InputStream is = mock(InputStream.class);
 
         when(is.read(any(byte[].class))).thenThrow(new IOException());
-                
-        try {
-            this.stubbing.respond().withBody(is);
-        } finally {
-            verify(is).close();
+
+try {
+        this.stubbing.respond().withBody(is);
+} finally {
+        verify(is).close();
+}
         }
-    }
 
 
-    @Test
+@Test
     public void withHeader() {
         final String name = "name";
         final String value = "value";
@@ -162,47 +160,47 @@ public class StubbingTest {
 
         final StubResponse response = assertAndGetOneResponse();
         assertThat(response.getHeaders(), is(notNullValue()));
-        
+
         final KeyValues expected = new KeyValues().add(name, value);
         assertThat(response.getHeaders(), is(expected));
-    }
+}
 
 
-    @Test
+@Test
     public void withStatus() {
         final int status = 2;
         this.stubbing.respond().withStatus(status);
 
         final StubResponse response = assertAndGetOneResponse();
         assertThat(response.getStatus(), is(status));
-    }
+}
 
 
-    @Test
+@Test
     public void withDelay() {
         this.stubbing.respond().withDelay(2, TimeUnit.SECONDS);
 
         final StubResponse response = assertAndGetOneResponse();
         assertThat(response.getDelay(), is(2000L));
-    }
+}
 
-    
-    @Test
+
+@Test
     public void createRuleWithResponder() {
         this.stubbing.respondUsing(RESPONDER);
         final HttpStub rule = this.stubbing.createRule();
-        
+
         assertThat(rule, is(notNullValue()));
-    }
-    
+}
 
-    @Test
+    
+@Test
     public void createRule() {
         this.stubbing.thenRespond();
         final HttpStub rule = this.stubbing.createRule();
 
         assertThat(rule, is(notNullValue()));
-    }
+}
 
 
     // helper methods
@@ -214,34 +212,34 @@ public class StubbingTest {
         assertThat(this.stubbing.getStubResponses().get(0), is(instanceOf(MutableStubResponse.class)));
         assertThat(this.stubbing.getStubResponses().get(0).getHeaders(), equalTo((MultiMap) DEFAULT_HEADERS));
         assertThat(this.stubbing.getStubResponses().get(0).getStatus(), equalTo(DEFAULT_STATUS));
-    }
+}
 
 
     private StubResponse assertAndGetOneResponse() {
         assertThat(this.stubbing.getStubResponses(), is(notNullValue()));
         assertThat(this.stubbing.getStubResponses(), hasSize(1));
-        
+
         assertThat(this.stubbing.getStubResponses().get(0), is(instanceOf(MutableStubResponse.class)));
-        
+
         return this.stubbing.getStubResponses().get(0).toStubResponse();
-    }
-    
+}
+
     
-    /*
+/*
      * This is a test only extension of the Stubbing class which provides a getter to all StubResponses and to the
      * Responder
-     */
+*/
     private static class TestStubbing extends Stubbing {
         TestStubbing(final Charset defaultEncoding, final int defaultStatus, final MultiMap defaultHeaders) {
             super(defaultEncoding, defaultStatus, defaultHeaders);
-        }
-        
+}
+
         List<MutableStubResponse> getStubResponses() {
             return new ArrayList<MutableStubResponse>(this.stubResponses);
-        }
-        
+}
+
         Responder getResponder() {
             return this.responder;
-        }
-    }
 }
+        }
+    }
\ No newline at end of file
diff --git a/jadler-jetty/src/main/java/net/jadler/stubbing/server/jetty/JettyStubHttpServer.java b/jadler-jetty/src/main/java/net/jadler/stubbing/server/jetty/JettyStubHttpServer.java
index a501e45..6437c89 100644
--- a/jadler-jetty/src/main/java/net/jadler/stubbing/server/jetty/JettyStubHttpServer.java
+++ b/jadler-jetty/src/main/java/net/jadler/stubbing/server/jetty/JettyStubHttpServer.java
@@ -7,11 +7,11 @@ package net.jadler.stubbing.server.jetty;
 import net.jadler.RequestManager;
 import net.jadler.stubbing.server.StubHttpServer;
 import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.commons.lang.Validate;
 import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
 
 
 /**
@@ -30,53 +30,52 @@ public class JettyStubHttpServer implements StubHttpServer {
 
     public JettyStubHttpServer(final int port) {
         this.server = new Server();
-        this.server.setSendServerVersion(false);
-        this.server.setSendDateHeader(true);
-        
-        this.httpConnector = new SelectChannelConnector();
-        this.httpConnector.setPort(port);
+
+this.httpConnector = new ServerConnector(server);
+((ServerConnector) this.httpConnector).setPort(port);
+((ServerConnector) this.httpConnector).setHost("localhost");
         server.addConnector(this.httpConnector);
-    }
-    
+}
 
-    /**
+    
+/**
      * {@inheritDoc}
-     */
-    @Override
+*/
+@Override
     public void registerRequestManager(final RequestManager ruleProvider) {
         Validate.notNull(ruleProvider, "ruleProvider cannot be null");
 
         server.setHandler(new JadlerHandler(ruleProvider));
-    }
-    
+}
 
-    /**
+    
+/**
      * {@inheritDoc}
-     */
-    @Override
+*/
+@Override
     public void start() throws Exception {
         logger.debug("starting jetty");
         server.start();
         logger.debug("jetty started");
-    }
+}
 
 
-    /**
+/**
      * {@inheritDoc}
-     */
-    @Override
+*/
+@Override
     public void stop() throws Exception {
         logger.debug("stopping jetty");
         server.stop();
         logger.debug("jetty stopped");
-    }
-    
+}
 
-    /**
+    
+/**
      * {@inheritDoc}
-     */
-    @Override
+*/
+@Override
     public int getPort() {
-        return httpConnector.getLocalPort();
-    }
-}
\ No newline at end of file
+return ((ServerConnector) httpConnector).getLocalPort();
+}
+    }
\ No newline at end of file
diff --git a/jadler-junit/src/test/java/net/jadler/junit/rule/JadlerRuleIntegrationTest.java b/jadler-junit/src/test/java/net/jadler/junit/rule/JadlerRuleIntegrationTest.java
index b76c3e3..cfa27dd 100644
--- a/jadler-junit/src/test/java/net/jadler/junit/rule/JadlerRuleIntegrationTest.java
+++ b/jadler-junit/src/test/java/net/jadler/junit/rule/JadlerRuleIntegrationTest.java
@@ -17,6 +17,7 @@ import org.apache.http.client.fluent.Request;
 import org.apache.http.message.BasicHeader;
 
 import static net.jadler.Jadler.verifyThatRequest;
+import static org.hamcrest.Matchers.equalToIgnoringCase;
 import static net.jadler.Jadler.port;
 import static net.jadler.Jadler.onRequest;
 import org.hamcrest.BaseMatcher;
@@ -84,71 +85,72 @@ public class JadlerRuleIntegrationTest {
     public void withDefaultResponseContentType() throws IOException {
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
         
-        assertThat(response.getFirstHeader("Content-Type").getValue(), is(DEFAULT_CONTENT_TYPE));
-    }
-    
-    @Test
+String actualContentType = response.getFirstHeader("Content-Type").getValue().replaceAll("\\s+", "");
+String expectedContentType = DEFAULT_CONTENT_TYPE.replaceAll("\\s+", "");
+assertThat(actualContentType, equalToIgnoringCase(expectedContentType));
+}
+
+@Test
     public void withDefaultResponseStatus() throws IOException {
         final int status = Executor.newInstance().execute(Request.Get(jadlerUri()))
                 .returnResponse().getStatusLine().getStatusCode();
-        
+
         assertThat(status, is(DEFAULT_STATUS));
-    }
-    
-    @Test
+}
+
+@Test
     public void withDefaultResponseEncoding() throws IOException {
         final byte[] body = Executor.newInstance().execute(Request.Get(jadlerUri())).returnContent().asBytes();
         assertThat(body, is(ISO_8859_2_REPRESENTATION));
-    }
+}
 
-    @Test
+@Test
     @SuppressWarnings("unchecked")
     public void withDefaultResponseHeader() throws IOException {
         final HttpResponse response = Executor.newInstance().execute(Request.Get(jadlerUri())).returnResponse();
-        
+
         assertThat(response.getHeaders(HEADER_NAME1), is(arrayContainingInAnyOrder(
             header(HEADER_NAME1, HEADER_VALUE1_1), header(HEADER_NAME1, HEADER_VALUE1_2))));
-        
+
         assertThat(response.getHeaders(HEADER_NAME2), is(arrayContaining(header(HEADER_NAME2, HEADER_VALUE2))));
-    }
+}
 
     private String jadlerUri() {
         return "http://localhost:" + port();
-    }
-    
+}
+
     private static HeaderMatcher header(final String name, final String value) {
         return new HeaderMatcher(name, value);
-    }
-    
-    
+}
+
+
     private static class HeaderMatcher extends BaseMatcher<Header> {
 
         final String expectedName;
         final String expectedValue;
 
-        
+
         public HeaderMatcher(final String expectedName, final String expectedValue) {
             this.expectedName = expectedName;
             this.expectedValue = expectedValue;
-        }
+}
 
 
-        @Override
+@Override
         public boolean matches(final Object item) {
             if (item == null) {
                 return false;
-            }
+}
             
             final Header actual = (Header) item;
-            
+
             return this.expectedName.equals(actual.getName()) && this.expectedValue.equals(expectedValue);
-        }
+}
 
-        @Override
+@Override
         public void describeTo(Description description) {
             description.appendText('<' + this.expectedName + ": " + this.expectedValue + '>');
-        }
-        
     }
+
 }
- 
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 96f6a16..66e9e43 100644
--- a/pom.xml
+++ b/pom.xml
@@ -182,8 +182,8 @@ This program is made available under the terms of the MIT License.
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>2.5.1</version>
                 <configuration>
-                    <source>1.6</source>
-                    <target>1.6</target>
+                    <source>1.8</source>
+                    <target>1.8</target>
                     <showDeprecation>true</showDeprecation>
                     <showWarnings>true</showWarnings>
                     <fork>true</fork>
@@ -197,8 +197,8 @@ This program is made available under the terms of the MIT License.
                 <configuration>
                     <signature>
                         <groupId>org.codehaus.mojo.signature</groupId>
-                        <artifactId>java16</artifactId>
-                        <version>1.0</version>
+                        <artifactId>java18</artifactId>
+                        <version>1.1</version>
                     </signature>
                     <ignores>
                         <!-- HttpServer is not part of Animal Sniffer signature -->