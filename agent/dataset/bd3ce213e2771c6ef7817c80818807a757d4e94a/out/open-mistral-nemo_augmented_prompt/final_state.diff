diff --git a/src/main/java/de/uniwue/helper/RecognitionHelper.java b/src/main/java/de/uniwue/helper/RecognitionHelper.java
index c0a0290..7f237b1 100644
--- a/src/main/java/de/uniwue/helper/RecognitionHelper.java
+++ b/src/main/java/de/uniwue/helper/RecognitionHelper.java
@@ -170,7 +170,7 @@ public class RecognitionHelper {
         } else {
             progress = -1;
         }
-        return progress;
+            return progress;
     }
 
     /**
@@ -207,61 +207,76 @@ public class RecognitionHelper {
 
         //// Estimate Skew
         if (cmdArgsWork.contains("--estimate_skew")) {
-        	// Calculate the skew of all regions where none was calculated before
-        	List<String> skewparams = new ArrayList<>();
+         // Calculate the skew of all regions where none was calculated before
+         List<String> skewparams = new ArrayList<>();
             skewparams.add("skewestimate");
-        	final int maxskewIndex = cmdArgsWork.indexOf("--maxskew");
-        	if(maxskewIndex > -1) {
-        		skewparams.add(cmdArgsWork.remove(maxskewIndex));
-        		skewparams.add(cmdArgsWork.remove(maxskewIndex));
-        	}
-        	final int skewstepsIndex = cmdArgsWork.indexOf("--skewsteps");
-        	if(skewstepsIndex > -1) {
-        		skewparams.add(cmdArgsWork.remove(skewstepsIndex));
-        		skewparams.add(cmdArgsWork.remove(skewstepsIndex));
-        	}
-
-			// Create temp json file with all segment images (to not overload parameter list)
-			// Temp file in a temp folder named "skew-<random numbers>.json"
-			File segmentListFile = File.createTempFile("skew-",".json");
-			skewparams.add(segmentListFile.toString());
-			segmentListFile.deleteOnExit(); // Delete if OCR4all terminates
-			ObjectMapper mapper = new ObjectMapper();
-			ArrayNode dataList = mapper.createArrayNode();
-			for (String pageId : pageIds) {
-				ArrayNode pageList = mapper.createArrayNode();
-				pageList.add(projConf.getImageDirectoryByType(projectImageType) + pageId +
-						projConf.getImageExtensionByType(projectImageType));
-				final String pageXML = projConf.OCR_DIR + pageId + projConf.CONF_EXT;
-				pageList.add(pageXML);
-
-				// Add affected line segment images with their absolute path to the json file
-				dataList.add(pageList);
-			}
-			ObjectWriter writer = mapper.writer();
-			writer.writeValue(segmentListFile, dataList);
-
-            processHandler = new ProcessHandler();
+         final int maxskewIndex = cmdArgsWork.indexOf("--maxskew");
+         if(maxskewIndex > -1) {
+          skewparams.add(cmdArgsWork.remove(maxskewIndex));
+          skewparams.add(cmdArgsWork.remove(maxskewIndex));
+         }
+         final int skewstepsIndex = cmdArgsWork.indexOf("--skewsteps");
+         if(skewstepsIndex > -1) {
+          skewparams.add(cmdArgsWork.remove(skewstepsIndex));
+          skewparams.add(cmdArgsWork.remove(skewstepsIndex));
+         }
+
+   // Create temp json file with all segment images (to not overload parameter list)
+   // Temp file in a temp folder named "skew-<random numbers>.json"
+   File segmentListFile = File.createTempFile("skew-",".json");
+   skewparams.add(segmentListFile.toString());
+   segmentListFile.deleteOnExit(); // Delete if OCR4all terminates
+   ObjectMapper mapper = new ObjectMapper();
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+mapper.enable(SerializationFeature.INDENT_OUTPUT);
+   ArrayNode dataList = mapper.createArrayNode();
+   for (String pageId : pageIds) {
+    ArrayNode pageList = mapper.createArrayNode();
+    pageList.add(projConf.getImageDirectoryByType(projectImageType) + pageId +
+      projConf.getImageExtensionByType(projectImageType));
+            final String pageXML = projConf.OCR_DIR + pageId + projConf.CONF_EXT;
+    pageList.add(pageXML);
+
+    // Add affected line segment images with their absolute path to the json file
+    dataList.add(pageList);
+}
+   ObjectWriter writer = mapper.writer();
+   writer.writeValue(segmentListFile, dataList);
+
+        processHandler = new ProcessHandler();
             processHandler.setFetchProcessConsole(true);
             processHandler.startProcess("ocr4all-helper-scripts", skewparams, false);
 
-        	cmdArgsWork.remove("--estimate_skew");
-        }
+         cmdArgsWork.remove("--estimate_skew");
+}
 
 
         //// Recognize
-		// Reset recognition data
-		deleteOldFiles(pageIds);
-		initialize(pageIds);
+  // Reset recognition data
+  deleteOldFiles(pageIds);
+  initialize(pageIds);
 
-        int index;
+int index;
         if (cmdArgsWork.contains("--checkpoint")) {
             index = cmdArgsWork.indexOf("--checkpoint");
             for(String ckpt : extractModelsOfJoinedString(cmdArgsWork.get(index + 1))) {
                 if (!new File(ckpt).exists())
                     throw new IOException("Model does not exist under the specified path");
-            }
-        }
+}
+}
 
         List<String> command = new ArrayList<>();
         // Ugly hack but helpers will be rewritten for the next release anyways. Don't use as basis for future code!
@@ -269,25 +284,25 @@ public class RecognitionHelper {
             cmdArgsWork.remove("--data.output_glyphs");
             command.add("--data.output_glyphs");
             command.add("True");
-        }
+}
         if(cmdArgsWork.contains("--data.output_confidences")){
             cmdArgsWork.remove("--data.output_confidences");
             command.add("--data.output_confidences");
             command.add("True");
-        }
+}
 
         command.add("--data.images");
-        // Create temp json file with all segment images (to not overload parameter list)
-		// Temp file in a temp folder named "calamari-<random numbers>.json"
+   // Create temp json file with all segment images (to not overload parameter list)
+  // Temp file in a temp folder named "calamari-<random numbers>.json"
         File segmentListFile = File.createTempFile("calamari-",".files");
         segmentListFile.deleteOnExit();
 
         List<String> content = new ArrayList<>();
-        for (String pageId : pageIds) {
+   for (String pageId : pageIds) {
             // Add affected images with their absolute path to the file
             content.add(projConf.getImageDirectoryByType(projectImageType) + pageId +
-                                projConf.getImageExtensionByType(projectImageType));
-        }
+      projConf.getImageExtensionByType(projectImageType));
+}
         Files.write(segmentListFile.toPath(), content, StandardOpenOption.APPEND);
         command.add(segmentListFile.toString());
 
@@ -298,8 +313,8 @@ public class RecognitionHelper {
             command.add(arg);
             if (arg.equals("--checkpoint") && cmdArgsIterator.hasNext()) {
                 command.addAll(extractModelsOfJoinedString(cmdArgsIterator.next()));
-            }
-        }
+}
+}
 
         command.add("--data");
         command.add("PageXML");
@@ -314,13 +329,13 @@ public class RecognitionHelper {
         command.add("1");
 
         command.add("--verbose");
-        command.add("True");
+            command.add("True");
 
         command.add("--predictor.progress_bar");
         command.add("False");
 
         processHandler = new ProcessHandler();
-        processHandler.setFetchProcessConsole(true);
+            processHandler.setFetchProcessConsole(true);
         processHandler.startProcess("calamari-predict", command, false);
 
         // Execute progress update to fill processState data structure with correct values
@@ -333,31 +348,31 @@ public class RecognitionHelper {
 
         // Clean up temp segmentListFile
         // segmentListFile.delete();
-    }
+}
 
-    /**
+/**
      * Resets the progress (use if an error occurs)
-     */
+*/
     public void resetProgress() {
         RecognitionRunning = false;
-        progress = -1;
-    }
+            progress = -1;
+}
 
-    /**
+/**
      * Cancels the process
-     */
+*/
     public void cancelProcess() {
         if (processHandler != null)
             processHandler.stopProcess();
         RecognitionRunning = false;
-    }
+}
 
-    /**
+/**
      * Returns the Ids of the pages, for which line segmentation was already executed
-     *
+*
      * @return List with page ids
      * @throws IOException
-     */
+*/
     public ArrayList<String> getValidPageIds() throws IOException {
         // Get all pages and check which ones are already line segmented
         ArrayList<String> validPageIds = new ArrayList<String>();
@@ -365,23 +380,23 @@ public class RecognitionHelper {
         for (String pageId : allPageIds) {
             if (procStateCol.lineSegmentationState(pageId) == true)
                 validPageIds.add(pageId);
-        }
+}
 
         Collections.sort(validPageIds);
         return validPageIds;
-    }
+}
 
-    /**
+/**
      * Deletion of old process related files
-     *
+*
      * @param pageIds Identifiers of the pages (e.g 0002,0003)
-     */
+*/
     public void deleteOldFiles(List<String> pageIds) throws IOException {
         // Delete potential TextEquivs already existing in the page xmls
         for(String pageId : pageIds) {
             File pageXML = new File(projConf.OCR_DIR + pageId + projConf.CONF_EXT);
             if (!pageXML.exists())
-                return;
+return;
 
             // Load pageXML and replace/delete all Textline text content
             String pageXMLContent = new String(Files.readAllBytes(pageXML.toPath()));
@@ -392,68 +407,68 @@ public class RecognitionHelper {
                 fileWriter.write(pageXMLContent);
                 fileWriter.flush();
                 fileWriter.close();
-            }
-    	}
-    }
+}
+}
+}
 
-    /**
+/**
      * Creates the recognition files of the linesegments that were skipped by the ocropus-rpred script
-     *
+*
      * @throws IOException
-     */
+*/
     public void createSkippedSegments() throws IOException{
         for(String pageId : processState.keySet()) {
             for(String segmentId :processState.get(pageId).keySet()) {
                 for (String lineSegmentId : processState.get(pageId).get(segmentId).keySet()) {
                     if (processState.get(pageId).get(segmentId).get(lineSegmentId))
-                        continue;
+continue;
 
                     FileUtils.writeStringToFile(new File(projConf.PAGE_DIR + pageId + File.separator +
                         segmentId + File.separator + lineSegmentId + projConf.REC_EXT), "", "UTF8");
-                }
-            }
-        }
-    }
+}
+}
+}
+}
 
-    /**
+/**
      * Checks if process depending files already exist
-     *
+*
      * @param pageIds Identifiers of the pages (e.g 0002,0003)
      * @return Information if files exist
-     */
+*/
     public boolean doOldFilesExist(String[] pageIds) {
-        for (String pageId : pageIds) {
+   for (String pageId : pageIds) {
             if (procStateCol.recognitionState(pageId))
                 return true;
-        }
+}
         return false;
-    }
+}
 
-    /**
+/**
      * Lists all available Models from the model directory
      * Consider the subsequent information to load models correctly
-     *
+*
      * Possible model location directories:
      * ProjectConfiguration.PROJ_MODEL_DEFAULT_DIR
      * ProjectConfiguration.PROJ_MODEL_CUSTOM_DIR
-     *
+*
      * Model path structures on the filesystem:
      * Default: OS_PATH/{TRAINING_IDENTIFIER}/{ID}.ckpt.json
      * Custom:  OS_PATH/{PROJECT_NAME}/{TRAINING_IDENTIFIER}/{ID}.ckpt.json
-     *
+*
      * Example: /var/ocr4all/models/default/Baiter_000/Baiter.ckpt.json
      * Display: Baiter_000/Baiter
      * Example: /var/ocr4all/models/custom/Bibel/0/0.ckpt.json
      * Display: Bibel/0/0
      * Example: /var/ocr4all/models/custom/Bibel/heading/0.ckpt.json
      * Display: Bibel/heading/0
-     *
+*
      * The models need to be in the following structure:
      * ANY_PATH/{MODEL_NAME}/ANY_NAME.ckpt.json
-     *
+*
      * @return Map of models (key = modelName | value = path)
      * @throws IOException
-     */
+*/
     public static TreeMap<String, String> listModels() throws IOException{
         TreeMap<String, String> models = new TreeMap<String, String>();
 
@@ -465,7 +480,7 @@ public class RecognitionHelper {
         Files.walk(Paths.get(ProjectConfiguration.PROJ_MODEL_DIR), FileVisitOption.FOLLOW_LINKS)
         .map(Path::toFile)
         .filter(fileEntry -> fileEntry.getName().endsWith(ProjectConfiguration.MODEL_EXT))
-        .forEach(
+.forEach(
             fileEntry -> {
                 // Remove OS path and model extension from display string (only display significant information)
                 String modelName = fileEntry.getAbsolutePath();
@@ -474,19 +489,19 @@ public class RecognitionHelper {
                 modelName = modelName.replace(ProjectConfiguration.MODEL_EXT, "");
 
                 models.put(modelName, fileEntry.getAbsolutePath());
-        });
+});
 
-        return models;
-    }
+            return models;
+}
 
-    /**
+/**
      * Determines conflicts with the process
-     *
+*
      * @param currentProcesses Processes that are currently running
      * @param inProcessFlow Indicates if the process is executed within the ProcessFlow
      * @return Type of process conflict
-     */
+*/
     public int getConflictType(List<String> currentProcesses, boolean inProcessFlow) {
         return ProcessConflictDetector.recognitionConflict(currentProcesses, inProcessFlow);
-    }
 }
+}
\ No newline at end of file