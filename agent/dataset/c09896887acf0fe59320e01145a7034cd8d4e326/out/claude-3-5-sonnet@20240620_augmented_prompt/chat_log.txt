================================ System Message ================================

Act as an expert Java software developer.
The program has issues after a version upgrade of a dependency.
Try using minimal changes to the code to fix the issues. 
Do not explain your actions or ask questions, just provide diffs that always adhere to the rules.
When you think you are done, reply with the diff that fixes the issues, after that a final verification step will happen and the conversation will be ended if it was successful. If not you get the error back.

# File editing rules:
Return edits similar to unified diffs that `diff -U0` would produce.
The diff has to be in a markdown code block, like this: ```diff ```.

Make sure you include the first 2 lines with the file paths.
Don't include timestamps with the file paths.

Start each hunk of changes with a `@@ ... @@` line.
Don't include line numbers like `diff -U0` does.
The user's patch tool doesn't need them.

The user's patch tool needs CORRECT patches that apply cleanly against the current contents of the file!
Think carefully and make sure you include and mark all lines that need to be removed or changed as `-` lines.
Make sure you mark all new or modified lines with `+`.
Don't leave out any lines or the diff patch won't apply correctly.
Dont add in new comments or change existing comments.
Make sure the diff is minimal and only includes the changes needed to fix the issue plus at least one context line so the tool can apply the diff correctly.

Indentation matters in the diffs!

Start a new hunk for each section of the file that needs changes.
Dont include unnescessary context, but include at least one line of it.
If no context is included, the tool will try to apply the changes at the end of the line.

Only output hunks that specify changes with `+` or `-` lines.
Skip any hunks that are entirely unchanging ` ` lines.

Output hunks in whatever order makes the most sense.
Hunks don't need to be in any particular order.

When editing a function, method, loop, etc use a hunk to replace the *entire* code block.
Delete the entire existing version with `-` lines and then add a new, updated version with `+` lines.
This will help you generate correct code and correct diffs.

To make a new file, show a diff from `--- /dev/null` to `+++ path/to/new/file.ext`.


================================ Human Message =================================


Updated Dependency Details: org.kohsuke:github-api 1.93 -> 1.314

Initial Error: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.3:compile (default-compile) on project lib: Compilation failure
[ERROR] lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java:[239,126] status has private access in org.kohsuke.github.GHCompare
[ERROR] -> [Help 1]

Revapi/japicmp API Changes, which describe changes in the APIs used by this project: {"japicmpResult": {"getCompare": ["SUPERCLASS_REMOVED", "CLASS_REMOVED", "FIELD_REMOVED", "INTERFACE_REMOVED", "CONSTRUCTOR_REMOVED", "METHOD_REMOVED", "METHOD_ADDED_TO_PUBLIC_CLASS"], "connect": ["SUPERCLASS_REMOVED", "CLASS_REMOVED", "FIELD_REMOVED", "INTERFACE_REMOVED", "CONSTRUCTOR_REMOVED", "METHOD_REMOVED", "METHOD_ADDED_TO_PUBLIC_CLASS"], "getRepository": ["SUPERCLASS_REMOVED", "CLASS_REMOVED", "FIELD_REMOVED", "INTERFACE_REMOVED", "CONSTRUCTOR_REMOVED", "METHOD_REMOVED", "METHOD_ADDED_TO_PUBLIC_CLASS"]}, "elementLines": {"getCompare": "[ERROR] /incrementals-tools/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java:[239,126] status has private access in org.kohsuke.github.GHCompare", "connect": "[ERROR] /incrementals-tools/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java:[239,126] status has private access in org.kohsuke.github.GHCompare", "getRepository": "[ERROR] /incrementals-tools/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java:[239,126] status has private access in org.kohsuke.github.GHCompare"}, "revapiResult": {"getCompare": [], "connect": [], "getRepository": []}, "allPotentialBreakingElements": ["connect()", "getCompare(java.lang.String,java.lang.String)", "getRepository(java.lang.String)"], "elementPatterns": {"getCompare": "has private access in", "connect": "has private access in", "getRepository": "has private access in"}, "project": "incrementals-tools"}


================================== Ai Message ==================================

To address the compilation error and the API changes, I'll modify the UpdateChecker.java file. Here's the diff to fix the issues:
Tool Calls:
  validate_diffs (toolu_vrtx_01DDgou4NV8uELPbx23FWW9b)
 Call ID: toolu_vrtx_01DDgou4NV8uELPbx23FWW9b
  Args:
    diff: ```diff
--- a/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
+++ b/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
@@ -236,7 +236,7 @@ public final class UpdateChecker {
         GHCompare compare = repo.getCompare(baseline, head);
         LOGGER.fine(() -> "compare " + compare);
         List<GHCompare.Commit> commits = compare.getCommits();
-        if (compare.getStatus() == GHCompare.Status.identical) {
+        if (compare.getAheadBy() == 0 && compare.getBehindBy() == 0) {
             LOGGER.fine(() -> "no changes in " + compare);
             return null;
         }
```

================================= Tool Message =================================
Name: validate_diffs

Diff Error: UnifiedDiffNoMatch: hunk failed to apply!

lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java does not contain lines that match the diff you provided!
Try again.
DO NOT, NEVER, skip blank lines, comments, docstrings, etc!
The diff needs to apply cleanly to the lines in lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java!
Make extra sure the indentation is correct.

lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java does not contain these 7 exact lines in a row:
```
        GHCompare compare = repo.getCompare(baseline, head);
        LOGGER.fine(() -> "compare " + compare);
        List<GHCompare.Commit> commits = compare.getCommits();
        if (compare.getStatus() == GHCompare.Status.identical) {
            LOGGER.fine(() -> "no changes in " + compare);
            return null;
        }
```


================================== Ai Message ==================================

I apologize for the error. Let me try again with a more accurate diff:
Tool Calls:
  validate_diffs (toolu_vrtx_016dxV4ABG3ZNQ1QrryuvpkK)
 Call ID: toolu_vrtx_016dxV4ABG3ZNQ1QrryuvpkK
  Args:
    diff: ```diff
--- a/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
+++ b/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
@@ -236,7 +236,7 @@ public final class UpdateChecker {
         GHCompare compare = repo.getCompare(baseline, head);
         LOGGER.fine(() -> "compare " + compare);
         List<GHCompare.Commit> commits = compare.getCommits();
-        if (compare.status == GHCompare.Status.identical) {
+        if (compare.getAheadBy() == 0 && compare.getBehindBy() == 0) {
             LOGGER.fine(() -> "no changes in " + compare);
             return null;
         }
```

================================= Tool Message =================================
Name: validate_diffs

Diff Error: UnifiedDiffNoMatch: hunk failed to apply!

lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java does not contain lines that match the diff you provided!
Try again.
DO NOT, NEVER, skip blank lines, comments, docstrings, etc!
The diff needs to apply cleanly to the lines in lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java!
Make extra sure the indentation is correct.

lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java does not contain these 7 exact lines in a row:
```
        GHCompare compare = repo.getCompare(baseline, head);
        LOGGER.fine(() -> "compare " + compare);
        List<GHCompare.Commit> commits = compare.getCommits();
        if (compare.status == GHCompare.Status.identical) {
            LOGGER.fine(() -> "no changes in " + compare);
            return null;
        }
```


================================== Ai Message ==================================

I apologize for the continued error. Let me try to read the file contents to ensure we have the correct context:
Tool Calls:
  read_file_lines (toolu_vrtx_01CWi2tK48BPNkynK4jd2hvJ)
 Call ID: toolu_vrtx_01CWi2tK48BPNkynK4jd2hvJ
  Args:
    file_path: lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
    lines: [235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245]

================================= Tool Message =================================
Name: read_file_lines

{"235": "     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>", "236": "     */", "237": "    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {", "238": "        try {", "239": "            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;", "240": "            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;", "241": "        } catch (FileNotFoundException x) {", "242": "            // For example, that branch does not exist in this repository.", "243": "            return false;", "244": "        }", "245": "        // TODO check behavior when the comparison is huge (too many commits or too large diff)"}

================================== Ai Message ==================================

Thank you for providing the file contents. Now I can create an accurate diff to fix the issue:
Tool Calls:
  validate_diffs (toolu_vrtx_01UCHFNjRcvdfHfsWRKQA6m5)
 Call ID: toolu_vrtx_01UCHFNjRcvdfHfsWRKQA6m5
  Args:
    diff: ```diff
--- a/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
+++ b/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
@@ -237,7 +237,8 @@ public final class UpdateChecker {
     private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {
         try {
-            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;
-            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;
+            GHCompare compare = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash);
+            return compare.getAheadBy() == 0 || compare.getBehindBy() > 0;
         } catch (FileNotFoundException x) {
             // For example, that branch does not exist in this repository.
             return false;
```

================================= Tool Message =================================
Name: validate_diffs

{'lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java': '/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace(\'.\', \'/\') + \'/\' + artifactId + \'/\' + version + \'/\';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + \'-\' + version + \'.\' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info("Group ID Cache hit on artifact ID: " + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + \':\' + artifactId + \':\' + currentVersion + \':\' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info("Cache hit on updates to " + groupId + ":" + artifactId + ":" + currentVersion + " within " + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info("Searching for updates to " + groupId + ":" + artifactId + ":" + currentV + " within " + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info("Found no candidates");\n            return null;\n        }\n        log.info("Found " + candidates.size() + " candidates from " + candidates.first() + " down to " + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info("Stopping search at " + candidate + " since it is no newer than " + currentV);\n                return null;\n            }\n            log.info("Considering " + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info("Mapped to: " + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info("Seems to be within " + branch + ", so accepting");\n                    return candidate;\n                } else {\n                    log.info("Does not seem to be within " + branch);\n                }\n            } else {\n                log.info("Does not seem to be an incremental release, so accepting");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace(\'.\', \'/\') + \'/\' + artifactId + "/maven-metadata.xml";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, "versions", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName("version");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return "https://github.com/" + owner + \'/\' + repo + "/commit/" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL("pom");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName("scm");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, "url", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile("https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?").matcher(url);\n        if (!m.matches()) {\n            throw new Exception("Unexpected /project/scm/url " + url + " in " + pom + "; expecting https://github.com/owner/repo format");\n        }\n        Element tagE = theElement(scmE, "tag", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace("${project.artifactId}", vnr.artifactId);\n        if (!tag.matches("[a-f0-9]{40}")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u â€¦ https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href="https://developer.github.com/v3/repos/commits/#compare-two-commits">Compare two commits</a>\n     * @see <a href="https://stackoverflow.com/a/23970412/12916">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare compare = GitHub.connect().getRepository(ghc.owner + \'/\' + ghc.repo).getCompare(branch, ghc.hash);\n            return compare.getAheadBy() == 0 || compare.getBehindBy() > 0;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception("Could not find <" + tagName + "> in " + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException("Usage: java " + UpdateChecker.class.getName() + " <groupId> <artifactId> <currentVersion> <branch>");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList("https://repo.jenkins-ci.org/releases/", "https://repo.jenkins-ci.org/incrementals/")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println("Found: " + result);\n        } else {\n            System.err.println("Nothing found.");\n        }\n    }\n\n}\n'}

================================== Ai Message ==================================

The diff has been successfully validated. Now, let's apply this change to fix the compilation error:
Tool Calls:
  compile_maven_stateful (toolu_vrtx_01KZS9CQedtfU1UyMwtbZLZp)
 Call ID: toolu_vrtx_01KZS9CQedtfU1UyMwtbZLZp
  Args:
    diff: ```diff
--- a/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
+++ b/lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java
@@ -237,7 +237,8 @@ public final class UpdateChecker {
     private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {
         try {
-            GHCompare.Status status = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash).status;
-            return status == GHCompare.Status.identical || status == GHCompare.Status.behind;
+            GHCompare compare = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash);
+            return compare.getAheadBy() == 0 || compare.getBehindBy() > 0;
         } catch (FileNotFoundException x) {
             // For example, that branch does not exist in this repository.
             return false;
```

================================= Tool Message =================================
Name: compile_maven_stateful

{"compilation_has_succeeded": true, "test_has_succeeded": true, "error_text": "", "updated_files": {"lib/src/main/java/io/jenkins/tools/incrementals/lib/UpdateChecker.java": "/*\n * The MIT License\n *\n * Copyright 2018 CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage io.jenkins.tools.incrementals.lib;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.maven.artifact.versioning.ComparableVersion;\nimport org.kohsuke.github.GHCompare;\nimport org.kohsuke.github.GitHub;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Looks for updates (incremental or otherwise) to a specific artifact.\n */\npublic final class UpdateChecker {\n\n    private final Log log;\n    private final List<String> repos;\n    /** keys are {@code groupId:artifactId:currentVersion:branch} */\n    private final Map<String, VersionAndRepo> cache = new HashMap<>();\n\n    private final Map<String, String> groupIdCache = new HashMap<>();\n\n    public UpdateChecker(Log log, List<String> repos) {\n        this.log = log;\n        this.repos = repos;\n    }\n\n    @FunctionalInterface\n    public interface Log {\n        void info(String message);\n    }\n\n    public static final class VersionAndRepo implements Comparable<VersionAndRepo> {\n        public final String groupId;\n        public final String artifactId;\n        public final ComparableVersion version;\n        public final String repo;\n        VersionAndRepo(String groupId, String artifactId, ComparableVersion version, String repo) {\n            this.groupId = groupId;\n            this.artifactId = artifactId;\n            this.version = version;\n            this.repo = repo;\n        }\n        /** Sort by version descending. */\n        @Override public int compareTo(VersionAndRepo o) {\n            assert o.groupId.equals(groupId) && o.artifactId.equals(artifactId);\n            return o.version.compareTo(version);\n        }\n        /** @return for example: {@code https://repo/net/nowhere/lib/1.23/} */\n        public String baseURL() {\n            return repo + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/';\n        }\n        /**\n         * @param type for example, {@code pom}\n         * @return for example: {@code https://repo/net/nowhere/lib/1.23/lib-1.23.pom}\n         */\n        public String fullURL(String type) {\n            return baseURL() + artifactId + '-' + version + '.' + type;\n        }\n        @Override public String toString() {\n            return baseURL();\n        }\n    }\n\n    public @CheckForNull String findGroupId(String artifactId) throws IOException, InterruptedException {\n        String cacheKey = artifactId;\n        if (groupIdCache.containsKey(cacheKey)) {\n            log.info(\"Group ID Cache hit on artifact ID: \" + artifactId);\n            return groupIdCache.get(cacheKey);\n        }\n\n        //TODO: implement to support non-Incremental formats\n        // Needs to load UC JSON and query it like https://github.com/jenkinsci/docker/pull/668\n        return null;\n    }\n\n    public @CheckForNull VersionAndRepo find(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        String cacheKey = groupId + ':' + artifactId + ':' + currentVersion + ':' + branch;\n        if (cache.containsKey(cacheKey)) {\n            log.info(\"Cache hit on updates to \" + groupId + \":\" + artifactId + \":\" + currentVersion + \" within \" + branch);\n            return cache.get(cacheKey);\n        }\n        VersionAndRepo result = doFind(groupId, artifactId, currentVersion, branch);\n        cache.put(cacheKey, result);\n        return result;\n    }\n\n    private @CheckForNull VersionAndRepo doFind(String groupId, String artifactId, String currentVersion, String branch) throws Exception {\n        ComparableVersion currentV = new ComparableVersion(currentVersion);\n        log.info(\"Searching for updates to \" + groupId + \":\" + artifactId + \":\" + currentV + \" within \" + branch);\n        SortedSet<VersionAndRepo> candidates = loadVersions(groupId, artifactId);\n        if (candidates.isEmpty()) {\n            log.info(\"Found no candidates\");\n            return null;\n        }\n        log.info(\"Found \" + candidates.size() + \" candidates from \" + candidates.first() + \" down to \" + candidates.last());\n        for (VersionAndRepo candidate : candidates) {\n            if (candidate.version.compareTo(currentV) <= 0) {\n                log.info(\"Stopping search at \" + candidate + \" since it is no newer than \" + currentV);\n                return null;\n            }\n            log.info(\"Considering \" + candidate);\n            GitHubCommit ghc = loadGitHubCommit(candidate);\n            if (ghc != null) {\n                log.info(\"Mapped to: \" + ghc);\n                if (isAncestor(ghc, branch)) {\n                    log.info(\"Seems to be within \" + branch + \", so accepting\");\n                    return candidate;\n                } else {\n                    log.info(\"Does not seem to be within \" + branch);\n                }\n            } else {\n                log.info(\"Does not seem to be an incremental release, so accepting\");\n                // TODO may still be useful to select MRP versions targeted to an origin branch.\n                // (For example, select the latest backport from a stable branch rather than trunk.)\n                // The problem is that we cannot then guarantee that the POM has been flattened\n                // (this is only guaranteed for repositories which *may* produce incrementals),\n                // and loadGitHubCommit will not work for nonflattened POMs from reactor submodules:\n                // it would have to be made more complicated to resolve the parent POM(s),\n                // or we would need to switch the implementation to use Maven/Aether resolution APIs.\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for all known versions of a given artifact.\n     * @param repos a set of repository URLs to check\n     * @return a possibly empty set of versions, sorted descending\n     */\n    private SortedSet<VersionAndRepo> loadVersions(String groupId, String artifactId) throws Exception {\n        // TODO consider using official Aether APIs here (could make use of local cache)\n        SortedSet<VersionAndRepo> r = new TreeSet<>();\n        for (String repo : repos) {\n            String mavenMetadataURL = repo + groupId.replace('.', '/') + '/' + artifactId + \"/maven-metadata.xml\";\n            Document doc;\n            try {\n                doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(mavenMetadataURL);\n            } catch (FileNotFoundException x) {\n                continue; // not even defined in this repo, fine\n            }\n            Element versionsE = theElement(doc, \"versions\", mavenMetadataURL);\n            NodeList versionEs = versionsE.getElementsByTagName(\"version\");\n            for (int i = 0; i < versionEs.getLength(); i++) {\n                // Not bothering to exclude timestamped snapshots for now, since we are working with release repositories anyway.\n                r.add(new VersionAndRepo(groupId, artifactId, new ComparableVersion(versionEs.item(i).getTextContent()), repo));\n            }\n        }\n        return r;\n    }\n\n    private static final class GitHubCommit {\n        final String owner;\n        final String repo;\n        final String hash;\n        GitHubCommit(String owner, String repo, String hash) {\n            this.owner = owner;\n            this.repo = repo;\n            this.hash = hash;\n        }\n        @Override public String toString() {\n            return \"https://github.com/\" + owner + '/' + repo + \"/commit/\" + hash;\n        }\n    }\n\n    /**\n     * Parses {@code /project/scm/url} and {@code /project/scm/tag} out of a POM, if mapped to a commit.\n     */\n    private static @CheckForNull GitHubCommit loadGitHubCommit(VersionAndRepo vnr) throws Exception {\n        String pom = vnr.fullURL(\"pom\");\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pom);\n        NodeList scmEs = doc.getElementsByTagName(\"scm\");\n        if (scmEs.getLength() != 1) {\n            return null;\n        }\n        Element scmE = (Element) scmEs.item(0);\n        Element urlE = theElement(scmE, \"url\", pom);\n        String url = urlE.getTextContent();\n        Matcher m = Pattern.compile(\"https?://github[.]com/([^/]+)/([^/]+?)([.]git)?(/.*)?\").matcher(url);\n        if (!m.matches()) {\n            throw new Exception(\"Unexpected /project/scm/url \" + url + \" in \" + pom + \"; expecting https://github.com/owner/repo format\");\n        }\n        Element tagE = theElement(scmE, \"tag\", pom);\n        String tag = tagE.getTextContent();\n        String groupId = m.group(1);\n        String artifactId = m.group(2).replace(\"${project.artifactId}\", vnr.artifactId);\n        if (!tag.matches(\"[a-f0-9]{40}\")) {\n            return null;\n        }\n        return new GitHubCommit(groupId, artifactId, tag);\n    }\n\n    /**\n     * Checks whether a commit is an ancestor of a given branch head.\n     * {@code curl -s -u \u2026 https://api.github.com/repos/<owner>/<repo>/compare/<branch>...<hash> | jq -r .status}\n     * will return {@code identical} or {@code behind} if so, else {@code diverged} or {@code ahead}.\n     * @param branch may be {@code master} or {@code forker:branch}\n     * @see <a href=\"https://developer.github.com/v3/repos/commits/#compare-two-commits\">Compare two commits</a>\n     * @see <a href=\"https://stackoverflow.com/a/23970412/12916\">Discussion</a>\n     */\n    private static boolean isAncestor(GitHubCommit ghc, String branch) throws Exception {\n        try {\n            GHCompare compare = GitHub.connect().getRepository(ghc.owner + '/' + ghc.repo).getCompare(branch, ghc.hash);\n            return compare.getAheadBy() == 0 || compare.getBehindBy() > 0;\n        } catch (FileNotFoundException x) {\n            // For example, that branch does not exist in this repository.\n            return false;\n        }\n        // TODO check behavior when the comparison is huge (too many commits or too large diff)\n        // and perhaps fall back to cloning into a temp dir and pulling all PR refs https://gist.github.com/piscisaureus/3342247\n        // Currently https://developer.github.com/v4/object/commit/ does no better than this.\n    }\n\n    private static Element theElement(Document doc, String tagName, String url) throws Exception {\n        return theElement(doc.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(Element parent, String tagName, String url) throws Exception {\n        return theElement(parent.getElementsByTagName(tagName), tagName, url);\n    }\n\n    private static Element theElement(NodeList nl, String tagName, String url) throws Exception {\n        if (nl.getLength() != 1) {\n            throw new Exception(\"Could not find <\" + tagName + \"> in \" + url);\n        }\n        return (Element) nl.item(0);\n    }\n\n    public static void main(String... argv) throws Exception {\n        if (argv.length != 4) {\n            throw new IllegalStateException(\"Usage: java \" + UpdateChecker.class.getName() + \" <groupId> <artifactId> <currentVersion> <branch>\");\n        }\n        VersionAndRepo result = new UpdateChecker(\n                message -> System.err.println(message),\n                Arrays.asList(\"https://repo.jenkins-ci.org/releases/\", \"https://repo.jenkins-ci.org/incrementals/\")).\n            find(argv[0], argv[1], argv[2], argv[3]);\n        if (result != null) {\n            System.err.println(\"Found: \" + result);\n        } else {\n            System.err.println(\"Nothing found.\");\n        }\n    }\n\n}\n"}, "compile_error_details": {}}