{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 3281028191163486430
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoEdits: no applicable hunks found!\nThe provided diff does not contain any hunks that can be applied to the files in the repository.\nEnsure that your diff correctly specifies the changes and try again.\nThe diff needs to apply to the existing lines in the files.",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoEdits: no applicable hunks found!\nThe provided diff does not contain any hunks that can be applied to the files in the repository.\nEnsure that your diff correctly specifies the changes and try again.\nThe diff needs to apply to the existing lines in the files.",
            "span_id": 2911135784419293114
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 320547440697525063
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 510805811113243702
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 6805503165743169775
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nRenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nRenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "span_id": 16470760085396432808
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 6558505372491396662
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java": {
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": ""
                                },
                                {
                                    "line_no": 32,
                                    "content": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;"
                                },
                                {
                                    "line_no": 33,
                                    "content": "import org.apache.maven.doxia.sink.Sink;"
                                }
                            ],
                            "error_texts": [
                                "[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n"
                            ]
                        },
                        "385": {
                            "lines": [
                                {
                                    "line_no": 384,
                                    "content": "        {"
                                },
                                {
                                    "line_no": 385,
                                    "content": "            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );"
                                },
                                {
                                    "line_no": 386,
                                    "content": "            SiteRendererSink sink = new SiteRendererSink( context );"
                                }
                            ],
                            "error_texts": [
                                "[385,13] cannot find symbol\n",
                                "[385,44] cannot find symbol\n",
                                "[385,44] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n",
                                "[385,13] cannot find symbol\nsymbol: class RenderingContext\nlocation: class org.scoverage.plugin.SCoverageReportMojo\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 3302483272432480210
        },
        {
            "input": "```diff\n--- src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n+++ src/main/java/org/scoverage/plugin/SCoverageReportMojo.java\n@@ -32,1 +32,1 @@\n-import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n+import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n@@ -385,1 +385,1 @@\n-            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n+            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nRenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/scoverage/plugin/SCoverageReportMojo.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/scoverage/plugin/SCoverageReportMojo.java does not contain these 1 exact lines in a row:\n```\nRenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n```",
            "span_id": 2193151128413596389
        }
    ],
    "read_file": [
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 5709434741632021652
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 16980251515474511573
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 15566084600370925681
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 10341407321525102008
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 1025609908911949881
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext; // Updated import for new package structure\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" ); // Updated constructor usage\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 12397551087046103014
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 6095409429243432817
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 10237772868377182909
        },
        {
            "input": "src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
            "output": "/*\n * Copyright 2014-2022 Grzegorz Slowikowski (gslowikowski at gmail dot com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.scoverage.plugin;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\n\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.IOUtils;\nimport scoverage.serialize.Serializer;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\n\n/**\n * Generates code coverage by unit tests report in forked {@code scoverage} life cycle.\n * <br>\n * <br>\n * In forked {@code scoverage} life cycle project is compiled with SCoverage instrumentation\n * and unit tests are executed before report generation.\n * <br>\n * \n * @author <a href=\"mailto:gslowikowski@gmail.com\">Grzegorz Slowikowski</a>\n * @since 1.0.0\n */\n@Mojo( name = \"report\", threadSafe = false )\n@Execute( lifecycle = \"scoverage\", phase = LifecyclePhase.TEST )\npublic class SCoverageReportMojo\n    extends AbstractMojo\n    implements MavenReport\n{\n\n    /**\n     * Allows SCoverage to be skipped.\n     * <br>\n     * \n     * @since 1.0.0\n     */\n    @Parameter( property = \"scoverage.skip\", defaultValue = \"false\" )\n    private boolean skip;\n\n    /**\n     * In multi-module project additionally generate aggregated SCoverage report.\n     * <br>\n     * \n     * @since 1.1.0\n     */\n    @Parameter( property = \"scoverage.aggregate\", defaultValue = \"false\" )\n    private boolean aggregate;\n\n    /**\n     * In multi-module project generate only aggregated SCoverage report.\n     * <br>\n     * <br>\n     * Scoverage reports for individual modules will not be generated.\n     * <br>\n     *\n     * @since 1.4.0\n     */\n    @Parameter( property = \"scoverage.aggregateOnly\", defaultValue = \"false\" )\n    private boolean aggregateOnly;\n\n    /**\n     * The file encoding to use when reading Scala sources.\n     * <br>\n     * \n     * @since 1.2.0\n     */\n    @Parameter( property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Specifies if the build will fail if there are errors during report execution or not.\n     */\n    @Parameter( property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true )\n    private boolean failOnError;\n\n    /**\n     * Maven project to interact with.\n     */\n    @Parameter( defaultValue = \"${project}\", readonly = true, required = true )\n    private MavenProject project;\n\n    /**\n     * All Maven projects in the reactor.\n     */\n    @Parameter( defaultValue = \"${reactorProjects}\", required = true, readonly = true )\n    private List<MavenProject> reactorProjects;\n\n    /**\n     * Destination directory where the coverage data files should be written.\n     */\n    @Parameter( property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true )\n    private File dataDirectory;\n\n    /**\n     * Destination directory for generated HTML report files.\n     */\n    @Parameter( property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true )\n    private File outputDirectory;\n\n    /**\n     * Destination directory for XML report files.\n     */\n    @Parameter( property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true )\n    private File xmlOutputDirectory;\n\n    /**\n     * The name of the destination directory.\n     * <br>\n     */\n    @Parameter( property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true )\n    private String destDir;\n\n    /**\n     * The name of the SCoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"name\", readonly = true )\n    private String name;\n\n    /**\n     * The description of the Scoverage report to be displayed in the Maven Generated Reports page\n     * (i.e. <code>project-reports.html</code>).\n     */\n    @Parameter( property = \"description\", readonly = true )\n    private String description;\n\n    /** {@inheritDoc} */\n    @Override\n    public String getName( Locale locale )\n    {\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.name\" );\n        }\n\n        return name;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getDescription( Locale locale )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            return getBundle( locale ).getString( \"report.scoverage.description\" );\n        }\n\n        return description;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public void generate( Sink sink, Locale locale )\n        throws MavenReportException\n    {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        if ( canAttachAggregatedReportToSite && !( canGenerateNonAggregatedReport || canGenerateAggregatedReport ) )\n        {\n            return; // aggregated report for top level project is generated by last reactor project\n        }\n\n        try\n        {\n            long ts = System.currentTimeMillis();\n\n            // If top-level project is last reactor project it should generate ONLY aggregated report here\n            if ( canGenerateNonAggregatedReport )\n            {\n                generateReports();\n            }\n\n            // Aggregated report must be generated in last reactor project. It may be top-level\n            // project (this is very rare case) or any other project.\n            // Whatever project it is, it must generate report in top-level project's site directory.\n            // WARNING: Last reactor project cannot have scoverage generation skipped\n            // ('skip' configuration parameter set)!\n            if ( canGenerateAggregatedReport )\n            {\n                generateAggregatedReports();\n            }\n\n            long te = System.currentTimeMillis();\n            getLog().debug( String.format( \"Mojo execution time: %d ms\", te - ts ) );\n        }\n        catch ( MavenReportException e )\n        {\n            if ( failOnError )\n            {\n                throw e;\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( failOnError )\n            {\n                throw new MavenReportException( \"Report generation exception\", e );\n            }\n            getLog().error( \"Error while creating scoverage report: \" + e.getMessage(), e );\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getOutputName()\n    {\n        return destDir + \"/index\";\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isExternalReport()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean canGenerateReport()\n    {\n        if ( !skip && !\"pom\".equals( project.getPackaging() ) )\n        {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit( project, reactorProjects );\n        }\n\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite; \n\n        if ( !result && canGenerateAggregatedReport() )\n        {\n            // last project, but not top-level one\n            // generate here, because 'false' must be returned to Maven in order to avoid adding to this module's site\n            try\n            {\n                generateAggregatedReports();\n            }\n            catch ( MavenReportException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport()\n    {\n        if ( skip )\n        {\n            return false;\n        }\n        if ( \"pom\".equals( project.getPackaging() ) )\n        {\n            return false;\n        }\n        if ( aggregateOnly && reactorProjects.size() > 1 )\n        {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        if ( !coverageFile.exists() || !coverageFile.isFile() )\n        {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1\n                && project == reactorProjects.get( reactorProjects.size() - 1 );\n    }\n\n    private boolean canAttachAggregatedReportToSite()\n    {\n        return ( aggregate || aggregateOnly ) && reactorProjects.size() > 1 && project.isExecutionRoot();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String getCategoryName()\n    {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public File getReportOutputDirectory()\n    {\n        return outputDirectory;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setReportOutputDirectory( File reportOutputDirectory )\n    {\n        updateReportOutputDirectory( reportOutputDirectory );\n    }\n\n    private void updateReportOutputDirectory( File reportOutputDirectory )\n    {\n        if ( reportOutputDirectory != null && destDir != null\n             && !reportOutputDirectory.getAbsolutePath().endsWith( destDir ) )\n        {\n            this.outputDirectory = new File( reportOutputDirectory, destDir );\n        }\n        else\n        {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    /**\n     * Generates SCoverage report.\n     * \n     * @throws MojoExecutionException if unexpected problem occurs\n     */\n    @Override\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( !canGenerateReport() )\n        {\n            getLog().info( \"Skipping SCoverage report generation\" );\n            return;\n        }\n\n        try\n        {\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n            SiteRendererSink sink = new SiteRendererSink( context );\n            Locale locale = Locale.getDefault();\n            generate( sink, locale );\n        }\n        catch ( MavenReportException e )\n        {\n            String prefix = \"An error has occurred in \" + getName( Locale.ENGLISH ) + \" report generation\";\n            throw new MojoExecutionException( prefix + \": \" + e.getMessage(), e );\n        }\n    }\n\n    /**\n     * Gets the resource bundle for the specified locale.\n     *\n     * @param locale The locale of the currently generated report.\n     * @return The resource bundle for the requested locale.\n     */\n    private ResourceBundle getBundle( Locale locale )\n    {\n        return ResourceBundle.getBundle( \"scoverage-report\", locale, getClass().getClassLoader() );\n    }\n\n    private void generateReports()\n        throws MavenReportException /*, RuntimeException*/\n    {\n        @SuppressWarnings( \"unchecked\" )\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>( sourceDirs.size() );\n        for ( String dir: sourceDirs )\n        {\n            sourceRoots.add( new File( dir ) );\n        }\n\n        mkdirs( outputDirectory );\n        mkdirs( xmlOutputDirectory );\n\n        File coverageFile = Serializer.coverageFile( dataDirectory );\n        getLog().info( String.format( \"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath() ) );\n        Coverage coverage = Serializer.deserialize( coverageFile, project.getBasedir() );\n\n        getLog().info( String.format( \"Reading scoverage measurements [%s*]...\",\n                                      new File( dataDirectory, Constants.MeasurementsPrefix() ).getAbsolutePath() ) );\n        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( dataDirectory ) );\n        scala.collection.Set<Tuple2<Object, String>> measurements =\n                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n        coverage.apply( measurements );\n\n        getLog().info( \"Generating coverage reports...\" );\n        writeReports( coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory );\n        getLog().info( \"Coverage reports completed.\" );\n    }\n\n    private void generateAggregatedReports()\n        throws MavenReportException\n    {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for ( MavenProject module : reactorProjects )\n        {\n            if ( module.isExecutionRoot() )\n            {\n                topLevelModule = module;\n            }\n            else if ( !module.getPackaging().equals( \"pom\" ) )\n            {\n                File scoverageDataDir = rebase( dataDirectory, module );\n                if ( scoverageDataDir.isDirectory() )\n                {\n                    scoverageDataDirs.add( scoverageDataDir );\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage  = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList( IOUtils.findMeasurementFiles( scoverageDataDir ) );\n                        scala.collection.Set<Tuple2<Object, String>> measurements =\n                                IOUtils.invoked( CollectionConverters.asScala( measurementFiles ).toSeq(), encoding );\n                        subCoverage.apply( measurements );\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(\n                                    statement.location(),\n                                    statementId,\n                                    statement.start(),\n                                    statement.end(),\n                                    statement.line(),\n                                    statement.desc(),\n                                    statement.symbolName(),\n                                    statement.treeName(),\n                                    statement.branch(),\n                                    statement.count(),\n                                    statement.ignored(),\n                                    statement.tests()\n                            );\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n\n                    File sourceRootsFile = new File( scoverageDataDir, \"source.roots\" );\n                    if ( sourceRootsFile.isFile() )\n                    {\n                        try\n                        {\n                            BufferedReader r = new BufferedReader( new InputStreamReader(\n                                    new FileInputStream( sourceRootsFile ), \"UTF-8\" ) );\n                            try\n                            {\n                                String path = r.readLine();\n                                while ( path != null )\n                                {\n                                    sourceRoots.add( new File( path ) );\n                                    path = r.readLine();\n                                }\n                            }\n                            finally\n                            {\n                                r.close();\n                            }\n                        }\n                        catch ( IOException e )\n                        {\n                            throw new MavenReportException( \"...\", e );\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Empty report must be generated or top-level site will contain invalid link to non-existent Scoverage report\n        if ( scoverageDataDirs.isEmpty() )\n        {\n            getLog().info( \"No subproject data to aggregate, skipping SCoverage report generation\" );\n            return;\n        }*/\n\n        if ( getLog().isDebugEnabled() && scoverageDataDirs.size() > 0 )\n        {\n            getLog().debug( String.format( \"Found %d subproject subproject scoverage data directories:\",\n                    scoverageDataDirs.size() ) );\n            for ( File dataDir: scoverageDataDirs )\n            {\n                getLog().debug( String.format( \"- %s\", dataDir.getAbsolutePath() ) );\n            }\n        }\n        else\n        {\n            getLog().info( String.format( \"Found %d subproject scoverage data directories.\",\n                    scoverageDataDirs.size() ) );\n        }\n\n        File topLevelModuleOutputDirectory = rebase( outputDirectory, topLevelModule );\n        File topLevelModuleXmlOutputDirectory = rebase( xmlOutputDirectory, topLevelModule );\n\n        mkdirs( topLevelModuleOutputDirectory );\n        mkdirs( topLevelModuleXmlOutputDirectory );\n\n        getLog().info( \"Generating coverage aggregated reports...\" );\n        writeReports( coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory,\n                      topLevelModuleOutputDirectory );\n        getLog().info( \"Coverage aggregated reports completed.\" );\n    }\n\n    private void writeReports( Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory,\n                               File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory )\n    {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala( sourceRoots ).toSeq();\n\n        new CoberturaXmlWriter( sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written Cobertura XML report [%s]\",\n                                      new File( coberturaXmlOutputDirectory, \"cobertura.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageXmlWriter( sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written XML coverage report [%s]\",\n                                      new File( scoverageXmlOutputDirectory, \"scoverage.xml\" ).getAbsolutePath() ) );\n\n        new ScoverageHtmlWriter( sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply( encoding ) ).write( coverage );\n        getLog().info( String.format( \"Written HTML coverage report [%s]\",\n                                      new File( scoverageHtmlOutputDirectory, \"index.html\" ).getAbsolutePath() ) );\n\n        getLog().info( String.format( \"Statement coverage.: %s%%\", coverage.statementCoverageFormatted() ) );\n        getLog().info( String.format( \"Branch coverage....: %s%%\", coverage.branchCoverageFormatted() ) );\n    }\n\n    private void mkdirs( File directory )\n        throws MavenReportException\n    {\n        if ( !directory.exists() && !directory.mkdirs() )\n        {\n            throw new MavenReportException( String.format( \"Cannot create \\\"%s\\\" directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n        else if ( directory.exists() && !directory.isDirectory() )\n        {\n            throw new MavenReportException( String.format( \"Directory \\\"%s\\\" exists but is not a directory \",\n                                                           directory.getAbsolutePath() ) );\n        }\n    }\n\n    private File rebase( File file, MavenProject otherModule )\n    {\n        return new File( file.getAbsolutePath().replace( project.getBasedir().getAbsolutePath(),\n                                                         otherModule.getBasedir().getAbsolutePath() ) );\n    }\n\n}\n",
            "error": "",
            "span_id": 5716811086350497758
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}