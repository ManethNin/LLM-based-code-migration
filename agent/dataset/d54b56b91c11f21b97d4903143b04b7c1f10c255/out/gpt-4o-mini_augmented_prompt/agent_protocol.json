{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java\n+++ src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java\n@@ -1,12 +1,12 @@\n package com.google.pubsublite.kafka.sink;\n \n import com.google.cloud.pubsublite.CloudZone;\n import com.google.cloud.pubsublite.ProjectPath;\n-import com.google.cloud.pubsublite.PublishMetadata;\n import com.google.cloud.pubsublite.TopicName;\n import com.google.cloud.pubsublite.TopicPath;\n import com.google.cloud.pubsublite.internal.Publisher;\n import com.google.cloud.pubsublite.internal.wire.PubsubContext;\n import com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\n import com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\n import com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\n+import com.google.cloud.pubsublite.internal.wire.PublishMetadata;\n import java.util.Map;\n import org.apache.kafka.common.config.ConfigValue;\n \n class PublisherFactoryImpl implements PublisherFactory {\n \n@@ -20,7 +20,7 @@\n   @Override\n   public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n     Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n     RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n     TopicPath topic =\n         TopicPath.newBuilder()\n             .setProject(\n                 ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                     .project())\n             .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n             .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n             .build();\n     builder.setTopic(topic);\n     builder.setPublisherFactory(\n         partition ->\n             SinglePartitionPublisherBuilder.newBuilder()\n                 .setTopic(topic)\n                 .setPartition(partition)\n-                .setContext(PubsubContext.of(FRAMEWORK))\n+                .setContext(PubsubContext.of(FRAMEWORK, null))\n                 .build());\n     return builder.build();\n   }\n }\n--- src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java\n+++ src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java\n@@ -1,6 +1,6 @@\n package com.google.pubsublite.kafka.sink;\n \n-import com.google.cloud.pubsublite.PublishMetadata;\n+import com.google.cloud.pubsublite.internal.wire.PublishMetadata;\n import com.google.cloud.pubsublite.internal.Publisher;\n import java.util.Map;\n \n interface PublisherFactory {\n \n   Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n }\n--- src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java\n+++ src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java\n@@ -1,6 +1,6 @@\n package com.google.pubsublite.kafka.sink;\n \n import static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n \n-import com.google.cloud.pubsublite.PublishMetadata;\n+import com.google.cloud.pubsublite.internal.wire.PublishMetadata;\n import com.google.cloud.pubsublite.Message;\n import com.google.cloud.pubsublite.internal.Publisher;\n import com.google.common.annotations.VisibleForTesting;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "no suitable method found for of(com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework,<nulltype>)\n",
                "updated_files": {
                    "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
                    "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
                    "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java": {
                        "22": {
                            "lines": [
                                {
                                    "line_no": 21,
                                    "content": "import com.google.cloud.pubsublite.Message;"
                                },
                                {
                                    "line_no": 22,
                                    "content": "import com.google.cloud.pubsublite.internal.wire.PublishMetadata;"
                                },
                                {
                                    "line_no": 23,
                                    "content": "import com.google.cloud.pubsublite.internal.Publisher;"
                                }
                            ],
                            "error_texts": [
                                "[22,49] cannot find symbol\nsymbol: class PublishMetadata\nlocation: package com.google.cloud.pubsublite.internal.wire\n",
                                "[22,49] cannot find symbol\n"
                            ]
                        },
                        "43": {
                            "lines": [
                                {
                                    "line_no": 42,
                                    "content": "  private final PublisherFactory factory;"
                                },
                                {
                                    "line_no": 43,
                                    "content": "  private @Nullable Publisher<PublishMetadata> publisher;"
                                },
                                {
                                    "line_no": 44,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[43,31] cannot find symbol\n",
                                "[43,31] cannot find symbol\nsymbol: class PublishMetadata\nlocation: class com.google.pubsublite.kafka.sink.PubSubLiteSinkTask\n"
                            ]
                        }
                    },
                    "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java": {
                        "18": {
                            "lines": [
                                {
                                    "line_no": 17,
                                    "content": ""
                                },
                                {
                                    "line_no": 18,
                                    "content": "import com.google.cloud.pubsublite.internal.wire.PublishMetadata;"
                                },
                                {
                                    "line_no": 19,
                                    "content": "import com.google.cloud.pubsublite.internal.Publisher;"
                                }
                            ],
                            "error_texts": [
                                "[18,49] cannot find symbol\n",
                                "[18,49] cannot find symbol\nsymbol: class PublishMetadata\nlocation: package com.google.cloud.pubsublite.internal.wire\n"
                            ]
                        },
                        "24": {
                            "lines": [
                                {
                                    "line_no": 23,
                                    "content": ""
                                },
                                {
                                    "line_no": 24,
                                    "content": "  Publisher<PublishMetadata> newPublisher(Map<String, String> params);"
                                },
                                {
                                    "line_no": 25,
                                    "content": "}"
                                }
                            ],
                            "error_texts": [
                                "[24,13] cannot find symbol\nsymbol: class PublishMetadata\nlocation: interface com.google.pubsublite.kafka.sink.PublisherFactory\n",
                                "[24,13] cannot find symbol\n"
                            ]
                        }
                    },
                    "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java": {
                        "27": {
                            "lines": [
                                {
                                    "line_no": 26,
                                    "content": "import com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;"
                                },
                                {
                                    "line_no": 27,
                                    "content": "import com.google.cloud.pubsublite.internal.wire.PublishMetadata;"
                                },
                                {
                                    "line_no": 28,
                                    "content": "import java.util.Map;"
                                }
                            ],
                            "error_texts": [
                                "[27,49] cannot find symbol\nsymbol: class PublishMetadata\nlocation: package com.google.cloud.pubsublite.internal.wire\n",
                                "[27,49] cannot find symbol\n"
                            ]
                        },
                        "36": {
                            "lines": [
                                {
                                    "line_no": 35,
                                    "content": "  @Override"
                                },
                                {
                                    "line_no": 36,
                                    "content": "  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {"
                                },
                                {
                                    "line_no": 37,
                                    "content": "    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);"
                                }
                            ],
                            "error_texts": [
                                "[36,20] cannot find symbol\n",
                                "[36,20] cannot find symbol\nsymbol: class PublishMetadata\nlocation: class com.google.pubsublite.kafka.sink.PublisherFactoryImpl\n"
                            ]
                        },
                        "53": {
                            "lines": [
                                {
                                    "line_no": 52,
                                    "content": "                .setPartition(partition)"
                                },
                                {
                                    "line_no": 53,
                                    "content": "                .setContext(PubsubContext.of(FRAMEWORK, null))"
                                },
                                {
                                    "line_no": 54,
                                    "content": "                .build());"
                                }
                            ],
                            "error_texts": [
                                "[53,42] no suitable method found for of(com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework,<nulltype>)\nmethod com.google.cloud.pubsublite.internal.wire.PubsubContext.of(com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework) is not applicable\n(actual and formal argument lists differ in length)\nmethod com.google.cloud.pubsublite.internal.wire.PubsubContext.of() is not applicable\n(actual and formal argument lists differ in length)\n",
                                "[53,42] no suitable method found for of(com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework,<nulltype>)\n"
                            ]
                        }
                    }
                }
            },
            "error": "no suitable method found for of(com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework,<nulltype>)\n",
            "span_id": 10331019226405952396
        }
    ],
    "read_file": [
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.PublishMetadata;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 7027693630447012687
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 17443793116157277496
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 13939230894608183144
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 7288837390904230878
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 14447795453728943986
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 1499639868324856011
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 10757575889588150438
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 9808685894519291202
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 11826874724240298087
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 10868686028171947127
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 16799265637477162744
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 1824055795985628127
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 10406813071093336428
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 7191279575637254762
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 11605575907587373211
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 8861344893073628013
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 2860650327115925700
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 7892281613838432316
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 11989059905846131571
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 7288323154868257350
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 2608036406765301266
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 10179570448955591637
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 7368529946867636686
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 2729611576715414664
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 1686282564109426938
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 1647776068667854037
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 14650245141424112888
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 5796597774270322720
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 8289703407815276910
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 8882636673605604597
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 12615884374851264983
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 16795761594145471710
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 8029588450308759507
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 12659133538591518411
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 3734150017362826989
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 6003317877621476176
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 1529684363961211471
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 14303194722188553205
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 7490227109697228201
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactoryImpl.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.CloudZone;\nimport com.google.cloud.pubsublite.ProjectPath;\nimport com.google.cloud.pubsublite.TopicName;\nimport com.google.cloud.pubsublite.TopicPath;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext;\nimport com.google.cloud.pubsublite.internal.wire.PubsubContext.Framework;\nimport com.google.cloud.pubsublite.internal.wire.RoutingPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.SinglePartitionPublisherBuilder;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport java.util.Map;\nimport org.apache.kafka.common.config.ConfigValue;\n\nclass PublisherFactoryImpl implements PublisherFactory {\n\n  private static final Framework FRAMEWORK = Framework.of(\"KAFKA_CONNECT\");\n\n  @Override\n  public Publisher<PublishMetadata> newPublisher(Map<String, String> params) {\n    Map<String, ConfigValue> config = ConfigDefs.config().validateAll(params);\n    RoutingPublisherBuilder.Builder builder = RoutingPublisherBuilder.newBuilder();\n    TopicPath topic =\n        TopicPath.newBuilder()\n            .setProject(\n                ProjectPath.parse(\"projects/\" + config.get(ConfigDefs.PROJECT_FLAG).value())\n                    .project())\n            .setLocation(CloudZone.parse(config.get(ConfigDefs.LOCATION_FLAG).value().toString()))\n            .setName(TopicName.of(config.get(ConfigDefs.TOPIC_NAME_FLAG).value().toString()))\n            .build();\n    builder.setTopic(topic);\n    builder.setPublisherFactory(\n        partition ->\n            SinglePartitionPublisherBuilder.newBuilder()\n                .setTopic(topic)\n                .setPartition(partition)\n                .setContext(PubsubContext.of(FRAMEWORK, null))\n                .build());\n    return builder.build();\n  }\n}\n",
            "error": "",
            "span_id": 18312896727193105578
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PublisherFactory.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport java.util.Map;\n\ninterface PublisherFactory {\n\n  Publisher<PublishMetadata> newPublisher(Map<String, String> params);\n}\n",
            "error": "",
            "span_id": 16413594592246225635
        },
        {
            "input": "src/main/java/com/google/pubsublite/kafka/sink/PubSubLiteSinkTask.java",
            "output": "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.pubsublite.kafka.sink;\n\nimport static com.google.pubsublite.kafka.sink.Schemas.encodeToBytes;\n\nimport com.google.api.core.ApiService.State;\nimport com.google.cloud.pubsublite.Message;\nimport com.google.cloud.pubsublite.internal.wire.PublishMetadata;\nimport com.google.cloud.pubsublite.internal.Publisher;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.util.Timestamps;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.utils.AppInfoParser;\nimport org.apache.kafka.connect.header.ConnectHeaders;\nimport org.apache.kafka.connect.header.Header;\nimport org.apache.kafka.connect.sink.SinkRecord;\nimport org.apache.kafka.connect.sink.SinkTask;\n\npublic class PubSubLiteSinkTask extends SinkTask {\n\n  private final PublisherFactory factory;\n  private @Nullable Publisher<PublishMetadata> publisher;\n\n  @VisibleForTesting\n  PubSubLiteSinkTask(PublisherFactory factory) {\n    this.factory = factory;\n  }\n\n  public PubSubLiteSinkTask() {\n    this(new PublisherFactoryImpl());\n  }\n\n  @Override\n  public String version() {\n    return AppInfoParser.getVersion();\n  }\n\n  @Override\n  public void start(Map<String, String> map) {\n    if (publisher != null) {\n      throw new IllegalStateException(\"Called start when publisher already exists.\");\n    }\n    publisher = factory.newPublisher(map);\n    publisher.startAsync().awaitRunning();\n  }\n\n  @Override\n  public void put(Collection<SinkRecord> collection) {\n    if (publisher.state() != State.RUNNING) {\n      if (publisher.state() == State.FAILED) {\n        throw new IllegalStateException(\"Publisher has failed.\", publisher.failureCause());\n      } else {\n        throw new IllegalStateException(\"Publisher not currently running.\");\n      }\n    }\n    for (SinkRecord record : collection) {\n      Message.Builder message = Message.builder();\n      if (record.key() != null) {\n        message.setKey(encodeToBytes(record.keySchema(), record.key()));\n      }\n      if (record.value() != null) {\n        message.setData(encodeToBytes(record.valueSchema(), record.value()));\n      }\n      ImmutableListMultimap.Builder<String, ByteString> attributes =\n          ImmutableListMultimap.builder();\n      getRecordHeaders(record)\n          .forEach(\n              header ->\n                  attributes.put(\n                      header.key(), Schemas.encodeToBytes(header.schema(), header.value())));\n      if (record.topic() != null) {\n        attributes.put(Constants.KAFKA_TOPIC_HEADER, ByteString.copyFromUtf8(record.topic()));\n      }\n      if (record.kafkaPartition() != null) {\n        attributes.put(\n            Constants.KAFKA_PARTITION_HEADER,\n            ByteString.copyFromUtf8(record.kafkaPartition().toString()));\n        attributes.put(\n            Constants.KAFKA_OFFSET_HEADER,\n            ByteString.copyFromUtf8(Long.toString(record.kafkaOffset())));\n      }\n      if (record.timestamp() != null) {\n        attributes.put(\n            Constants.KAFKA_EVENT_TIME_TYPE_HEADER,\n            ByteString.copyFromUtf8(record.timestampType().name));\n        message.setEventTime(Timestamps.fromMillis(record.timestamp()));\n      }\n      message.setAttributes(attributes.build());\n      publisher.publish(message.build());\n    }\n  }\n\n  private Iterable<? extends Header> getRecordHeaders(SinkRecord record) {\n    ConnectHeaders headers = new ConnectHeaders();\n    if (record.headers() != null) {\n      for (Header header : record.headers()) {\n        headers.add(header);\n      }\n    }\n    return headers;\n  }\n\n  @Override\n  public void flush(Map<TopicPartition, OffsetAndMetadata> currentOffsets) {\n    try {\n      if (publisher != null) {\n        publisher.flush();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void stop() {\n    if (publisher == null) {\n      throw new IllegalStateException(\"Called stop when publisher doesn't exist.\");\n    }\n    try {\n      publisher.flush();\n      publisher.stopAsync().awaitTerminated();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    } finally {\n      publisher = null;\n    }\n  }\n}\n",
            "error": "",
            "span_id": 888223794720216287
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}