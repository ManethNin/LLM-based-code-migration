{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "I apologize for the oversight. Let's compile the project with the changes we've made. Here's the diff for all the changes:\n\n```diff\n--- a/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@ -10,7 +10,6 @@ import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n \n /**\n  * This class implements an output stream in which the data is\n@@ -398,7 +397,7 @@ public class ByteArrayOutputStream extends OutputStream\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(new byte[0]);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n--- a/src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@ -8,8 +8,6 @@ import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n-import org.apache.commons.io.input.BoundedInputStream;\n-import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n@@ -201,14 +199,12 @@ public abstract class AbstractZipUnArchiver\n                 {\n                     try ( InputStream in = zipFile.getInputStream( ze ) )\n                     {\n-                        BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n-                        CountingInputStream cis = new CountingInputStream( bis );\n-                        extractFile( getSourceFile(), outputDirectory, cis,\n+                        extractFile( getSourceFile(), outputDirectory, in,\n                                      ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                      ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                      resolveSymlink( zipFile, ze ), getFileMappers() );\n \n-                        remainingSpace -= cis.getByteCount();\n+                        remainingSpace -= ze.getSize();\n                         if ( remainingSpace < 0 )\n                         {\n                             throw new ArchiverException( \"Maximum output size limit reached\" );\n--- a/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@ -25,7 +25,6 @@ import java.util.zip.ZipFile;\n import java.util.zip.ZipOutputStream;\n \n import org.apache.commons.compress.parallel.InputStreamSupplier;\n-import org.apache.commons.io.output.NullPrintStream;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\n import org.codehaus.plexus.util.IO",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport javax.annotation.Nonnull;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n */\npublic abstract class AbstractZipUnArchiver\n    extends AbstractUnArchiver\n{\n\n    private static final String NATIVE_ENCODING = \"native-encoding\";\n\n    private String encoding = \"UTF8\";\n\n    private long maxOutputSize = Long.MAX_VALUE;\n\n    public AbstractZipUnArchiver()\n    {\n    }\n\n    public AbstractZipUnArchiver( final File sourceFile )\n    {\n        super( sourceFile );\n    }\n\n    /**\n     * Sets the encoding to assume for file names and comments.\n     * <p>\n     * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n     * </p>\n     */\n    public void setEncoding( String encoding )\n    {\n        if ( NATIVE_ENCODING.equals( encoding ) )\n        {\n            encoding = null;\n        }\n        this.encoding = encoding;\n    }\n\n    /**\n     * Set maximum allowed size of the produced output.\n     *\n     * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n     *\n     * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n     * @throws IllegalArgumentException if specified output size is less or equal to 0\n     */\n    public void setMaxOutputSize( long maxOutputSize ) {\n        if ( maxOutputSize <= 0 ) {\n            throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n        }\n        this.maxOutputSize = maxOutputSize;\n    }\n\n    private static class ZipEntryFileInfo\n        implements PlexusIoResource\n    {\n\n        private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n\n        private final ZipArchiveEntry zipEntry;\n\n        ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                          final ZipArchiveEntry zipEntry )\n        {\n            this.zipFile = zipFile;\n            this.zipEntry = zipEntry;\n        }\n\n        public String getName()\n        {\n            return zipEntry.getName();\n        }\n\n        @Override\n        public boolean isDirectory()\n        {\n            return zipEntry.isDirectory();\n        }\n\n        @Override\n        public boolean isFile()\n        {\n            return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n        }\n\n        @Override\n        public boolean isSymbolicLink()\n        {\n            return zipEntry.isUnixSymlink();\n        }\n\n        @Nonnull\n        @Override\n        public InputStream getContents()\n            throws IOException\n        {\n            return zipFile.getInputStream( zipEntry );\n        }\n\n        @Override\n        public long getLastModified()\n        {\n            final long l = zipEntry.getTime();\n            return l == 0 ? PlexusIoResource.UNKNOWN_MODIFICATION_DATE : l;\n        }\n\n        @Override\n        public long getSize()\n        {\n            final long l = zipEntry.getSize();\n            return l == -1 ? PlexusIoResource.UNKNOWN_RESOURCE_SIZE : l;\n        }\n\n        @Override\n        public URL getURL()\n            throws IOException\n        {\n            return null;\n        }\n\n        @Override\n        public boolean isExisting()\n        {\n            return true;\n        }\n\n    }\n\n    @Override\n    protected void execute()\n        throws ArchiverException\n    {\n        execute( \"\", getDestDirectory() );\n    }\n\n    private String resolveSymlink( ZipFile zf, ZipArchiveEntry ze )\n        throws IOException\n    {\n        if ( ze.isUnixSymlink() )\n        {\n            return zf.getUnixSymlink( ze );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    protected void execute( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        getLogger().debug( \"Expanding: \" + getSourceFile() + \" into \" + outputDirectory );\n        try ( ZipFile zipFile = new ZipFile( getSourceFile(), encoding, true ) )\n        {\n            long remainingSpace = maxOutputSize;\n            final Enumeration<ZipArchiveEntry> e = zipFile.getEntriesInPhysicalOrder();\n\n            while ( e.hasMoreElements() )\n            {\n                final ZipArchiveEntry ze = e.nextElement();\n                final ZipEntryFileInfo fileInfo = new ZipEntryFileInfo( zipFile, ze );\n                if ( !isSelected( ze.getName(), fileInfo ) )\n                {\n                    continue;\n                }\n\n                if ( ze.getName().startsWith( path ) )\n                {\n                    try ( InputStream in = zipFile.getInputStream( ze ) )\n                    {\n                        extractFile( getSourceFile(), outputDirectory, in,\n                                     ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                     ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                     resolveSymlink( zipFile, ze ), getFileMappers() );\n\n                        remainingSpace -= ze.getSize();\n                        if ( remainingSpace < 0 )\n                        {\n                            throw new ArchiverException( \"Maximum output size limit reached\" );\n                        }\n                    }\n                }\n            }\n            getLogger().debug( \"expand complete\" );\n        }\n        catch ( final IOException ioe )\n        {\n            throw new ArchiverException( \"Error while expanding \" + getSourceFile().getAbsolutePath(), ioe );\n        }\n    }\n\n}\n",
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "27": {
                            "lines": [
                                {
                                    "line_no": 26,
                                    "content": ""
                                },
                                {
                                    "line_no": 27,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 28,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[27,36] cannot find symbol\n",
                                "[27,36] cannot find symbol\nsymbol: class ThresholdingOutputStream\nlocation: package org.apache.commons.io.output\n"
                            ]
                        },
                        "32": {
                            "lines": [
                                {
                                    "line_no": 31,
                                    "content": " */"
                                },
                                {
                                    "line_no": 32,
                                    "content": "class OffloadingOutputStream extends ThresholdingOutputStream"
                                },
                                {
                                    "line_no": 33,
                                    "content": "{"
                                }
                            ],
                            "error_texts": [
                                "[32,38] cannot find symbol\nsymbol: class ThresholdingOutputStream\n",
                                "[32,38] cannot find symbol\n"
                            ]
                        },
                        "129": {
                            "lines": [
                                {
                                    "line_no": 128,
                                    "content": "     */"
                                },
                                {
                                    "line_no": 129,
                                    "content": "    @Override"
                                },
                                {
                                    "line_no": 130,
                                    "content": "    protected OutputStream getStream() throws IOException"
                                }
                            ],
                            "error_texts": [
                                "[129,5] method does not override or implement a method from a supertype\n"
                            ]
                        },
                        "143": {
                            "lines": [
                                {
                                    "line_no": 142,
                                    "content": "     */"
                                },
                                {
                                    "line_no": 143,
                                    "content": "    @Override"
                                },
                                {
                                    "line_no": 144,
                                    "content": "    protected void thresholdReached() throws IOException"
                                }
                            ],
                            "error_texts": [
                                "[143,5] method does not override or implement a method from a supertype\n"
                            ]
                        },
                        "207": {
                            "lines": [
                                {
                                    "line_no": 206,
                                    "content": "     */"
                                },
                                {
                                    "line_no": 207,
                                    "content": "    @Override"
                                },
                                {
                                    "line_no": 208,
                                    "content": "    public void close() throws IOException"
                                }
                            ],
                            "error_texts": [
                                "[207,5] method does not override or implement a method from a supertype\n"
                            ]
                        },
                        "210": {
                            "lines": [
                                {
                                    "line_no": 209,
                                    "content": "    {"
                                },
                                {
                                    "line_no": 210,
                                    "content": "        super.close();"
                                },
                                {
                                    "line_no": 211,
                                    "content": "        closed = true;"
                                }
                            ],
                            "error_texts": [
                                "[210,9] cannot find symbol\nsymbol: variable super\nlocation: class org.codehaus.plexus.archiver.zip.OffloadingOutputStream\n",
                                "[210,9] cannot find symbol\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "299": {
                            "lines": [
                                {
                                    "line_no": 298,
                                    "content": ""
                                },
                                {
                                    "line_no": 299,
                                    "content": "            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;"
                                },
                                {
                                    "line_no": 300,
                                    "content": "            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );"
                                }
                            ],
                            "error_texts": [
                                "[299,43] cannot find symbol\n",
                                "[299,43] cannot find symbol\nsymbol: variable NullPrintStream\nlocation: class org.codehaus.plexus.archiver.jar.JarToolModularJarArchiver\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/DeferredScatterOutputStream.java": {
                        "44": {
                            "lines": [
                                {
                                    "line_no": 43,
                                    "content": "    {"
                                },
                                {
                                    "line_no": 44,
                                    "content": "        dfos.write( data, offset, length );"
                                },
                                {
                                    "line_no": 45,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[44,13] cannot find symbol\n",
                                "[44,13] cannot find symbol\nsymbol: method write(byte[],int,int)\nlocation: variable dfos of type org.codehaus.plexus.archiver.zip.OffloadingOutputStream\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 12815399622065556000
        },
        {
            "input": "It seems there are still some issues with the changes we made. Let's address them one by one:\n\n1. For the OffloadingOutputStream class, we need to implement the ThresholdingOutputStream functionality ourselves. Let's update the file:\n\n```diff\n--- a/src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n@@ -24,12 +24,11 @@ import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.nio.file.Files;\n \n-import org.apache.commons.io.output.ThresholdingOutputStream;\n-\n /**\n  * Offloads to disk when a given memory consumption has been reacehd\n  */\n-class OffloadingOutputStream extends ThresholdingOutputStream\n+class OffloadingOutputStream extends OutputStream\n {\n+    private final int threshold;\n+    private long written;\n \n     // ----------------------------------------------------------- Data members\n \n@@ -70,7 +69,8 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n      */\n     public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n     {\n-        this( threshold, null, prefix, suffix, directory );\n+        super();\n+        this.threshold = threshold;\n         if ( prefix == null )\n         {\n             throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n@@ -89,7 +89,8 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n      */\n     private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n     {\n-        super( threshold );\n+        super();\n+        this.threshold = threshold;\n         this.outputFile = outputFile;\n \n         memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n@@ -126,7 +127,6 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n      *\n      * @exception java.io.IOException if an error occurs.\n      */\n-    @Override\n     protected OutputStream getStream() throws IOException\n     {\n         return currentOutputStream;\n@@ -140,7 +140,6 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n      *\n      * @exception java.io.IOException if an error occurs.\n      */\n-    @Override\n     protected void thresholdReached() throws IOException\n     {\n         if ( prefix != null )\n@@ -150,6 +149,14 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n         currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n     }\n \n+    @Override\n+    public void write(int b) throws IOException {\n+        getStream().write(b);\n+        written++;\n+        if (written > threshold) {\n+            thresholdReached();\n+        }\n+    }\n+\n     public InputStream getInputStream() throws IOException\n     {\n \n@@ -204,10 +211,9 @@ class OffloadingOutputStream extends ThresholdingOutputStream\n      *\n      * @exception java.io.IOException if an error occurs.\n      */\n-    @Override\n     public void close() throws IOException\n     {\n-        super.close();\n+        getStream().close();\n         closed = true;\n         currentOutputStream.close();\n     }\n```\n\n2. For the JarToolModularJarArchiver class, we need to replace the NullPrintStream with a custom implementation:\n\n```diff\n--- a/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@ -296,7 +296,7 @@ public class JarToolModularJarArchiver\n             // Test the output code validating the --date option.\n             String[] args = { \"--date\", \"2099-12",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends OutputStream\n{\n    private final int threshold;\n    private long written;\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        super();\n        this.threshold = threshold;\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        super();\n        this.threshold = threshold;\n        this.outputFile = outputFile;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        getStream().write(b);\n        written++;\n        if (written > threshold) {\n            thresholdReached();\n        }\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    public void close() throws IOException\n    {\n        getStream().close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "96": {
                            "lines": [
                                {
                                    "line_no": 95,
                                    "content": "        }"
                                },
                                {
                                    "line_no": 96,
                                    "content": "    }"
                                },
                                {
                                    "line_no": 97,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[96,5] variable prefix might not have been initialized\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "299": {
                            "lines": [
                                {
                                    "line_no": 298,
                                    "content": ""
                                },
                                {
                                    "line_no": 299,
                                    "content": "            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;"
                                },
                                {
                                    "line_no": 300,
                                    "content": "            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );"
                                }
                            ],
                            "error_texts": [
                                "[299,43] cannot find symbol\n",
                                "[299,43] cannot find symbol\nsymbol: variable NullPrintStream\nlocation: class org.codehaus.plexus.archiver.jar.JarToolModularJarArchiver\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 3122079359440713862
        },
        {
            "input": "```diff\n--- a/src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n@@ -76,6 +76,13 @@ class OffloadingOutputStream extends OutputStream\n         {\n             throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n         }\n+        this.prefix = prefix;\n+        this.suffix = suffix;\n+        this.directory = directory;\n+\n+        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n+        currentOutputStream = memoryOutputStream;\n+        this.outputFile = null;\n     }\n \n     /**\n@@ -89,15 +96,14 @@ class OffloadingOutputStream extends OutputStream\n      */\n     private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n     {\n-        super();\n-        this.threshold = threshold;\n+        this(threshold, prefix, suffix, directory);\n         this.outputFile = outputFile;\n-\n-        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n-        currentOutputStream = memoryOutputStream;\n-        this.prefix = prefix;\n-        this.suffix = suffix;\n-        this.directory = directory;\n+        \n+        if (outputFile != null) {\n+            try {\n+                currentOutputStream = Files.newOutputStream(outputFile.toPath());\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Failed to create output stream for file: \" + outputFile, e);\n+            }\n+        }\n     }\n--- a/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@ -296,7 +296,7 @@ public class JarToolModularJarArchiver\n             // Test the output code validating the --date option.\n             String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n \n-            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n+            PrintStream nullPrintStream = new PrintStream(new OutputStream() { public void write(int b) {} });\n             Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n \n             return result != null && result.intValue() == 0;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends OutputStream\n{\n    private final int threshold;\n    private long written;\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        super();\n        this.threshold = threshold;\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.outputFile = null;\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        this(threshold, prefix, suffix, directory);\n        this.outputFile = outputFile;\n\n        if (outputFile != null) {\n            try {\n                currentOutputStream = Files.newOutputStream(outputFile.toPath());\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to create output stream for file: \" + outputFile, e);\n            }\n        }\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        getStream().write(b);\n        written++;\n        if (written > threshold) {\n            thresholdReached();\n        }\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    public void close() throws IOException\n    {\n        getStream().close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\n",
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = new PrintStream(new OutputStream() { public void write(int b) {} });\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "299": {
                            "lines": [
                                {
                                    "line_no": 298,
                                    "content": ""
                                },
                                {
                                    "line_no": 299,
                                    "content": "            PrintStream nullPrintStream = new PrintStream(new OutputStream() { public void write(int b) {} });"
                                },
                                {
                                    "line_no": 300,
                                    "content": "            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );"
                                }
                            ],
                            "error_texts": [
                                "[299,63] cannot find symbol\n",
                                "[299,63] cannot find symbol\nsymbol: class OutputStream\nlocation: class org.codehaus.plexus.archiver.jar.JarToolModularJarArchiver\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 1934780724565518677
        },
        {
            "input": "```diff\n--- a/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ b/src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@ -20,6 +20,7 @@ import javax.inject.Named;\n import java.io.File;\n import java.io.IOException;\n import java.io.PrintStream;\n+import java.io.OutputStream;\n import java.lang.reflect.Method;\n import java.nio.file.Files;\n import java.nio.file.Path;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = new PrintStream(new OutputStream() { public void write(int b) {} });\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java": {
                        "14": {
                            "lines": [
                                {
                                    "line_no": 13,
                                    "content": "import java.util.Set;"
                                },
                                {
                                    "line_no": 14,
                                    "content": "import org.apache.commons.io.IOUtils;"
                                },
                                {
                                    "line_no": 15,
                                    "content": "import org.codehaus.plexus.archiver.TestSupport;"
                                }
                            ],
                            "error_texts": [
                                "[14,29] cannot find symbol\nsymbol: class IOUtils\nlocation: package org.apache.commons.io\n",
                                "[14,29] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 4159089674962240529
        },
        {
            "input": "```diff\n--- a/src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java\n+++ b/src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java\n@@ -11,7 +11,7 @@ import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Set;\n-import org.apache.commons.io.IOUtils;\n+import org.codehaus.plexus.util.IOUtil;\n import org.codehaus.plexus.archiver.TestSupport;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n import org.junit.Test;\n@@ -70,7 +70,7 @@ public class PlexusIoZipFileResourceCollectionTest\n             final InputStream stream = resource.getContents();\n             assertNotNull( stream );\n             try {\n-                final byte[] b = IOUtils.toByteArray( stream );\n+                final byte[] b = IOUtil.toByteArray( stream );\n                 assertTrue( b.length > 0 );\n             } finally {\n                 stream.close();\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java!\nMake extra sure the indentation is correct.\nsrc/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java does not contain these 7 exact lines in a row:\n```\nfinal InputStream stream = resource.getContents();\nassertNotNull( stream );\ntry {\nfinal byte[] b = IOUtils.toByteArray( stream );\nassertTrue( b.length > 0 );\n} finally {\nstream.close();\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java!\nMake extra sure the indentation is correct.\nsrc/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java does not contain these 7 exact lines in a row:\n```\nfinal InputStream stream = resource.getContents();\nassertNotNull( stream );\ntry {\nfinal byte[] b = IOUtils.toByteArray( stream );\nassertTrue( b.length > 0 );\n} finally {\nstream.close();\n```",
            "span_id": 12734502361189020795
        },
        {
            "input": "```diff\n--- a/src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java\n+++ b/src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java\n@@ -11,7 +11,7 @@ import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n-import org.apache.commons.io.IOUtils;\n+import org.codehaus.plexus.util.IOUtil;\n import org.codehaus.plexus.archiver.TestSupport;\n import org.codehaus.plexus.components.io.functions.SymlinkDestinationSupplier;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n@@ -85,7 +85,7 @@ public class PlexusIoZipFileResourceCollectionTest\n             if ( next.getName().endsWith( \"MANIFEST.MF\" ) )\n             {\n                 final InputStream contents1 = next.getContents();\n-                final String manifest = IOUtils.toString( contents1, \"UTF-8\" );\n+                final String manifest = IOUtil.toString( contents1, \"UTF-8\" );\n                 assertTrue( manifest.contains( \"bogs=fus\" ) );\n                 contents1.close();\n             }\n```",
            "output": {
                "compilation_has_succeeded": true,
                "test_has_succeeded": false,
                "error_text": "[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR] JarToolModularJarArchiverTest.testInvalidModularJar:158 Unexpected exception type thrown, expected: <org.codehaus.plexus.archiver.ArchiverException> but was: <java.lang.NoClassDefFoundError>\n[ERROR] Errors:\n[ERROR] DotDirectiveArchiveFinalizerTest.testDefaultDotDirectiveBehaviour:59 \u00bb NoClassDefFound\n[ERROR] DotDirectiveArchiveFinalizerTest.testDotDirectiveArchiveFinalizer:32 \u00bb NoClassDefFound\n[ERROR] DuplicateFilesTest.testDirArchiver:66->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] DuplicateFilesTest.testTarArchiver:79->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] DuplicateFilesTest.testZipArchiver:41->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] EmptyDirectoryTest.testTarArchiver:61->testEmptyDirectory:89 \u00bb NoClassDefFound\n[ERROR] EmptyDirectoryTest.testZipArchiver:44->testEmptyDirectory:89 \u00bb NoClassDefFound\n[ERROR] SymlinkTest.testSymlinkDirArchiver:110 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] SymlinkTest.testSymlinkTar:66 \u00bb NoClassDefFound org/apache/commons/io/output/D...\n[ERROR] SymlinkTest.testSymlinkZip:86 \u00bb NoClassDefFound org/apache/commons/io/output/D...\n[ERROR] BZip2ArchiverTest.testBz2IsForcedBehaviour:127->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] BZip2ArchiverTest.testCreateArchive:60 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] BZip2ArchiverTest.testCreateResourceCollection:94 \u00bb NoClassDefFound org/apache...\n[ERROR] GZipArchiverTest.testCreateArchive:60 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] GZipArchiverTest.testCreateResourceCollection:94 \u00bb NoClassDefFound org/apache/...\n[ERROR] GZipArchiverTest.testTarGzIsForcedBehaviour:124->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] DirectoryArchiverUnpackJarTest.test_dependency_sets_depSet_unpacked_rdonly:61 \u00bb NoClassDefFound\n[ERROR] IndexTest.testCreateArchiveWithIndexedJars:41 \u00bb NoClassDefFound org/apache/com...\n[ERROR] IndexTest.testCreateArchiveWithIndexedJarsAndMetaInf:85 \u00bb NoClassDefFound org/...\n[ERROR] JarArchiverTest>BaseJarArchiverTest.testCreateJar:56 \u00bb NoClassDefFound org/apa...\n[ERROR] JarArchiverTest.testNonCompressed:56 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] JarArchiverTest.testReproducibleBuild:100->createReproducibleBuild:129 \u00bb NoClassDefFound\n[ERROR] JarArchiverTest.testVeryLargeJar:86 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] JarToolModularJarArchiverTest.testCompression:220 \u00bb NoClassDefFound org/apache...\n[ERROR] JarToolModularJarArchiverTest>BaseJarArchiverTest.testCreateJar:56 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJar:139 \u00bb NoClassDefFound org/apache/...\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithMainClassAndVersion:74 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithManifestAndModuleMainClass:98 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithManifestMainClassAttribute:122 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularMultiReleaseJar:251 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testNoCompression:194 \u00bb NoClassDefFound org/apac...\n[ERROR] RarArchiverTest.testArchive:63 \u00bb NoClassDefFound org/apache/commons/io/output/...\n[ERROR] RarArchiverTest.testRarIsForcedBehaviour:107->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] SnappyArchiverTest.testCreateArchive:59 \u00bb NoClassDefFound org/apache/commons/i...\n[ERROR] SnappyArchiverTest.testCreateResourceCollection:93 \u00bb NoClassDefFound org/apach...\n[ERROR] SnappyArchiverTest.testsnappyIsForcedBehaviour:126->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testBzip2CompressedResourceCollection:531->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testCreateArchive:283->createArchive:311 \u00bb NoClassDefFound org...\n[ERROR] TarArchiverTest.testCreateArchiveWithDetectedModes:167 \u00bb NoClassDefFound org/a...\n[ERROR] TarArchiverTest.testGzipCompressedResourceCollection:509->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testGzipFIleHandleLeak:517 \u00bb NoClassDefFound org/apache/common...\n[ERROR] TarArchiverTest.testSymlinkArchivedFileSet:569 \u00bb NoClassDefFound org/apache/co...\n[ERROR] TarArchiverTest.testTarFileNotClosingInputStream:540 \u00bb NoClassDefFound org/apa...\n[ERROR] TarArchiverTest.testUncompressedResourceCollection:502->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testUnicode:257 \u00bb NoClassDefFound org/apache/commons/io/output...\n[ERROR] TarBZip2UnArchiverTest.testExtract:59 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] TarFileAttributesTest.testOverrideDetectedFileAttributes:218 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testOverrideDetectedFileAttributesUsingFileMode:272 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testUseAttributesFromTarArchiveInputInTarArchiverOutput:106 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testUseDetectedFileAttributes:172 \u00bb NoClassDefFound org/...\n[ERROR] TarFileTest.testBZip2TarFile:82->testTarFile:105 \u00bb NoClassDefFound org/apache/...\n[ERROR] TarFileTest.testGZipTarFile:62->testTarFile:105 \u00bb NoClassDefFound org/apache/c...\n[ERROR] TarFileTest.testTarFile:42->testTarFile:105 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] TarGZipUnArchiverTest.testExtract:57 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] TarSnappyUnArchiverTest.testExtract:57 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] TarXzUnArchiverTest.testExtract:62 \u00bb NoClassDefFound org/apache/commons/io/out...\n[ERROR] TarZstdUnArchiverTest.testExtract:58 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] WarArchiverTest.testInfiniteRecursion:57 \u00bb NoClassDefFound org/apache/commons/...\n[ERROR] WarArchiverTest.testReAddingPlatformSpecificEncoding:34->count:83 \u00bb NoClassDefFound\n[ERROR] XzArchiverTest.testCreateArchive:52 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] XzArchiverTest.testCreateResourceCollection:96 \u00bb NoClassDefFound org/apache/co...\n[ERROR] XzArchiverTest.testXzIsForcedBehaviour:129->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] ZipArchiverTest.testAddArchivedFileSet:445 \u00bb NoClassDefFound org/apache/common...\n[ERROR] ZipArchiverTest.testCreateArchive:367->newArchiver:503 \u00bb NoClassDefFound org/a...\n[ERROR] ZipArchiverTest.testCreateArchiveWithDetectedModes:244 \u00bb NoClassDefFound org/a...\n[ERROR] ZipArchiverTest.testCreateArchiveWithStreamTransformer:493 \u00bb NoClassDefFound o...\n[ERROR] ZipArchiverTest.testCreateResourceCollection:790 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZipArchiverTest.testDefaultUTF8:843 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] ZipArchiverTest.testDefaultUTF8withUTF8:853 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testFixedEntryModificationTime:929 \u00bb NoClassDefFound org/apach...\n[ERROR] ZipArchiverTest.testForced:677->newArchiver:503 \u00bb NoClassDefFound org/apache/c...\n[ERROR] ZipArchiverTest.testForcedFileModes:867 \u00bb NoClassDefFound org/apache/commons/i...\n[ERROR] ZipArchiverTest.testImplicitPermissions:109 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testLastModifiedTimeRounding:655 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZipArchiverTest.testOveriddenPermissions:141 \u00bb NoClassDefFound org/apache/comm...\n[ERROR] ZipArchiverTest.testRecompressAddedZips:381 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testSymlinkArchivedFileSet:630 \u00bb NoClassDefFound org/apache/co...\n[ERROR] ZipArchiverTest.testSymlinkFileSet:611 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] ZipArchiverTest.testSymlinkZip:588 \u00bb NoClassDefFound org/apache/commons/io/out...\n[ERROR] ZipArchiverTest.testZipNonConcurrentResourceCollection:816 \u00bb NoClassDefFound o...\n[ERROR] ZipUnArchiverTest.testUnarchiveUtf8:96 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] ZstdArchiverTest.testCreateArchive:47 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] ZstdArchiverTest.testCreateResourceCollection:91 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZstdArchiverTest.testZstIsForcedBehaviour:124->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[INFO]\n[ERROR] Tests run: 185, Failures: 1, Errors: 84, Skipped: 3\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 21.140 s\n[INFO] Finished at: 2024-08-05T16:31:49Z\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.2:test (default-test) on project plexus-archiver: There are test failures.\n[ERROR]\n[ERROR] Please refer to /mnt/repo/target/surefire-reports for the individual test results.\n[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException",
                "updated_files": {
                    "src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java": "package org.codehaus.plexus.archiver.zip;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.archiver.TestSupport;\nimport org.codehaus.plexus.components.io.functions.SymlinkDestinationSupplier;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.components.io.resources.PlexusIoURLResource;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class PlexusIoZipFileResourceCollectionTest\n        extends TestSupport\n{\n\n    @Test\n    public void testNamelessRootFolder()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection resourceCollection = new PlexusIoZipFileResourceCollection();\n        resourceCollection.setFile( getTestFile( \"src/test/jars/namelessrootfolder.jar\" ) );\n        Iterator iterator = resourceCollection.getResources();\n        PlexusIoURLResource entry = (PlexusIoURLResource) iterator.next();\n        assertEquals( \"/dummy.txt\", entry.getName() );\n        final URL url = entry.getURL();\n        BufferedReader d = new BufferedReader( new InputStreamReader( entry.getContents() ) );\n        assertEquals( \"dummy content\", d.readLine() );\n    }\n\n    @Test\n    public void testDescriptionForError()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection resourceCollection = new PlexusIoZipFileResourceCollection();\n        resourceCollection.setFile( getTestFile( \"src/test/jars/namelessrootfolder.jar\" ) );\n        Iterator<PlexusIoResource> iterator = resourceCollection.getResources();\n        PlexusIoURLResource entry = (PlexusIoURLResource) iterator.next();\n        final URL url = entry.getURL();\n        String descriptionForError = entry.getDescriptionForError( url );\n        assertTrue( descriptionForError.endsWith( \"namelessrootfolder.jar!//dummy.txt\" ) );\n    }\n\n    @Test\n    public void testFilesWithIllegalHtmlChars()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/bogusManifest.zip\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            if ( next.getName().endsWith( \"MANIFEST.MF\" ) )\n            {\n                final InputStream contents1 = next.getContents();\n                final String manifest = IOUtil.toString( contents1, \"UTF-8\" );\n                assertTrue( manifest.contains( \"bogs=fus\" ) );\n                contents1.close();\n            }\n\n        }\n    }\n\n    @Test\n    public void testFilesThatAreNotThere()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/archiveWithIllegalHtmlFileName.zip\" );\n        Set<String> seen = new HashSet<>();\n        seen.add( \"AFileThatNeedsHtmlEsc%3F&gt\" );\n        seen.add( \"Afile&lt;Yo&gt;.txt\" );\n        seen.add( \"File With Space.txt\" );\n        seen.add( \"FileWith%.txt\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            assertTrue( seen.remove( next.getName() ), next.getName() + \"was not present\" );\n            final URL url = next.getURL();\n            final InputStream contents = next.getContents();\n            contents.close();\n        }\n    }\n\n    @Test\n    public void testSymlinkEntries()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/symlinks/symlinks.zip\" );\n        Map<String, String> symLinks = new HashMap<>();\n        symLinks.put( \"symDir\", \"targetDir/\" );\n        symLinks.put( \"symLinkToDirOnTheOutside\", \"../dirOnTheOutside/\" );\n        symLinks.put( \"symLinkToTheOutside\", \"../onTheOutside.txt\" );\n        symLinks.put( \"symR\", \"fileR.txt\" );\n        symLinks.put( \"symW\", \"fileW.txt\" );\n        symLinks.put( \"symX\", \"fileX.txt\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            String symLinkTarget = symLinks.remove( next.getName() );\n            if ( symLinkTarget != null )\n            {\n                assertTrue( next.isSymbolicLink(), next.getName() + \" must be symlink\" );\n                assertTrue( next instanceof SymlinkDestinationSupplier );\n                assertEquals( symLinkTarget,\n                              ( (SymlinkDestinationSupplier) next ).getSymlinkDestination() );\n            }\n            else\n            {\n                assertFalse( next.isSymbolicLink(), next.getName() + \" must not be symlink\" );\n            }\n        }\n\n        assertTrue( symLinks.isEmpty() );\n    }\n\n    @Test\n    public void testUnarchiveUnicodePathExtra()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( getTestFile( \"src/test/resources/unicodePathExtra/efsclear.zip\" ) );\n        Set<String> names = new HashSet<>();\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            names.add(next.getName());\n        }\n        // a Unicode Path extra field should only be used when its CRC matches the header file name\n        assertEquals( new HashSet<>( Arrays.asList( \"nameonly-name\", \"goodextra-extra\", \"badextra-name\" ) ), names,\n                      \"should use good extra fields but not bad ones\" );\n    }\n\n}\n"
                },
                "compile_error_details": {}
            },
            "error": "[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR] JarToolModularJarArchiverTest.testInvalidModularJar:158 Unexpected exception type thrown, expected: <org.codehaus.plexus.archiver.ArchiverException> but was: <java.lang.NoClassDefFoundError>\n[ERROR] Errors:\n[ERROR] DotDirectiveArchiveFinalizerTest.testDefaultDotDirectiveBehaviour:59 \u00bb NoClassDefFound\n[ERROR] DotDirectiveArchiveFinalizerTest.testDotDirectiveArchiveFinalizer:32 \u00bb NoClassDefFound\n[ERROR] DuplicateFilesTest.testDirArchiver:66->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] DuplicateFilesTest.testTarArchiver:79->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] DuplicateFilesTest.testZipArchiver:41->createArchive:96 \u00bb NoClassDefFound org/...\n[ERROR] EmptyDirectoryTest.testTarArchiver:61->testEmptyDirectory:89 \u00bb NoClassDefFound\n[ERROR] EmptyDirectoryTest.testZipArchiver:44->testEmptyDirectory:89 \u00bb NoClassDefFound\n[ERROR] SymlinkTest.testSymlinkDirArchiver:110 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] SymlinkTest.testSymlinkTar:66 \u00bb NoClassDefFound org/apache/commons/io/output/D...\n[ERROR] SymlinkTest.testSymlinkZip:86 \u00bb NoClassDefFound org/apache/commons/io/output/D...\n[ERROR] BZip2ArchiverTest.testBz2IsForcedBehaviour:127->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] BZip2ArchiverTest.testCreateArchive:60 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] BZip2ArchiverTest.testCreateResourceCollection:94 \u00bb NoClassDefFound org/apache...\n[ERROR] GZipArchiverTest.testCreateArchive:60 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] GZipArchiverTest.testCreateResourceCollection:94 \u00bb NoClassDefFound org/apache/...\n[ERROR] GZipArchiverTest.testTarGzIsForcedBehaviour:124->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] DirectoryArchiverUnpackJarTest.test_dependency_sets_depSet_unpacked_rdonly:61 \u00bb NoClassDefFound\n[ERROR] IndexTest.testCreateArchiveWithIndexedJars:41 \u00bb NoClassDefFound org/apache/com...\n[ERROR] IndexTest.testCreateArchiveWithIndexedJarsAndMetaInf:85 \u00bb NoClassDefFound org/...\n[ERROR] JarArchiverTest>BaseJarArchiverTest.testCreateJar:56 \u00bb NoClassDefFound org/apa...\n[ERROR] JarArchiverTest.testNonCompressed:56 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] JarArchiverTest.testReproducibleBuild:100->createReproducibleBuild:129 \u00bb NoClassDefFound\n[ERROR] JarArchiverTest.testVeryLargeJar:86 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] JarToolModularJarArchiverTest.testCompression:220 \u00bb NoClassDefFound org/apache...\n[ERROR] JarToolModularJarArchiverTest>BaseJarArchiverTest.testCreateJar:56 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJar:139 \u00bb NoClassDefFound org/apache/...\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithMainClassAndVersion:74 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithManifestAndModuleMainClass:98 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularJarWithManifestMainClassAttribute:122 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testModularMultiReleaseJar:251 \u00bb NoClassDefFound\n[ERROR] JarToolModularJarArchiverTest.testNoCompression:194 \u00bb NoClassDefFound org/apac...\n[ERROR] RarArchiverTest.testArchive:63 \u00bb NoClassDefFound org/apache/commons/io/output/...\n[ERROR] RarArchiverTest.testRarIsForcedBehaviour:107->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] SnappyArchiverTest.testCreateArchive:59 \u00bb NoClassDefFound org/apache/commons/i...\n[ERROR] SnappyArchiverTest.testCreateResourceCollection:93 \u00bb NoClassDefFound org/apach...\n[ERROR] SnappyArchiverTest.testsnappyIsForcedBehaviour:126->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testBzip2CompressedResourceCollection:531->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testCreateArchive:283->createArchive:311 \u00bb NoClassDefFound org...\n[ERROR] TarArchiverTest.testCreateArchiveWithDetectedModes:167 \u00bb NoClassDefFound org/a...\n[ERROR] TarArchiverTest.testGzipCompressedResourceCollection:509->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testGzipFIleHandleLeak:517 \u00bb NoClassDefFound org/apache/common...\n[ERROR] TarArchiverTest.testSymlinkArchivedFileSet:569 \u00bb NoClassDefFound org/apache/co...\n[ERROR] TarArchiverTest.testTarFileNotClosingInputStream:540 \u00bb NoClassDefFound org/apa...\n[ERROR] TarArchiverTest.testUncompressedResourceCollection:502->testCreateResourceCollection:549 \u00bb NoClassDefFound\n[ERROR] TarArchiverTest.testUnicode:257 \u00bb NoClassDefFound org/apache/commons/io/output...\n[ERROR] TarBZip2UnArchiverTest.testExtract:59 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] TarFileAttributesTest.testOverrideDetectedFileAttributes:218 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testOverrideDetectedFileAttributesUsingFileMode:272 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testUseAttributesFromTarArchiveInputInTarArchiverOutput:106 \u00bb NoClassDefFound\n[ERROR] TarFileAttributesTest.testUseDetectedFileAttributes:172 \u00bb NoClassDefFound org/...\n[ERROR] TarFileTest.testBZip2TarFile:82->testTarFile:105 \u00bb NoClassDefFound org/apache/...\n[ERROR] TarFileTest.testGZipTarFile:62->testTarFile:105 \u00bb NoClassDefFound org/apache/c...\n[ERROR] TarFileTest.testTarFile:42->testTarFile:105 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] TarGZipUnArchiverTest.testExtract:57 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] TarSnappyUnArchiverTest.testExtract:57 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] TarXzUnArchiverTest.testExtract:62 \u00bb NoClassDefFound org/apache/commons/io/out...\n[ERROR] TarZstdUnArchiverTest.testExtract:58 \u00bb NoClassDefFound org/apache/commons/io/o...\n[ERROR] WarArchiverTest.testInfiniteRecursion:57 \u00bb NoClassDefFound org/apache/commons/...\n[ERROR] WarArchiverTest.testReAddingPlatformSpecificEncoding:34->count:83 \u00bb NoClassDefFound\n[ERROR] XzArchiverTest.testCreateArchive:52 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] XzArchiverTest.testCreateResourceCollection:96 \u00bb NoClassDefFound org/apache/co...\n[ERROR] XzArchiverTest.testXzIsForcedBehaviour:129->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[ERROR] ZipArchiverTest.testAddArchivedFileSet:445 \u00bb NoClassDefFound org/apache/common...\n[ERROR] ZipArchiverTest.testCreateArchive:367->newArchiver:503 \u00bb NoClassDefFound org/a...\n[ERROR] ZipArchiverTest.testCreateArchiveWithDetectedModes:244 \u00bb NoClassDefFound org/a...\n[ERROR] ZipArchiverTest.testCreateArchiveWithStreamTransformer:493 \u00bb NoClassDefFound o...\n[ERROR] ZipArchiverTest.testCreateResourceCollection:790 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZipArchiverTest.testDefaultUTF8:843 \u00bb NoClassDefFound org/apache/commons/io/ou...\n[ERROR] ZipArchiverTest.testDefaultUTF8withUTF8:853 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testFixedEntryModificationTime:929 \u00bb NoClassDefFound org/apach...\n[ERROR] ZipArchiverTest.testForced:677->newArchiver:503 \u00bb NoClassDefFound org/apache/c...\n[ERROR] ZipArchiverTest.testForcedFileModes:867 \u00bb NoClassDefFound org/apache/commons/i...\n[ERROR] ZipArchiverTest.testImplicitPermissions:109 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testLastModifiedTimeRounding:655 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZipArchiverTest.testOveriddenPermissions:141 \u00bb NoClassDefFound org/apache/comm...\n[ERROR] ZipArchiverTest.testRecompressAddedZips:381 \u00bb NoClassDefFound org/apache/commo...\n[ERROR] ZipArchiverTest.testSymlinkArchivedFileSet:630 \u00bb NoClassDefFound org/apache/co...\n[ERROR] ZipArchiverTest.testSymlinkFileSet:611 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] ZipArchiverTest.testSymlinkZip:588 \u00bb NoClassDefFound org/apache/commons/io/out...\n[ERROR] ZipArchiverTest.testZipNonConcurrentResourceCollection:816 \u00bb NoClassDefFound o...\n[ERROR] ZipUnArchiverTest.testUnarchiveUtf8:96 \u00bb NoClassDefFound org/apache/commons/io...\n[ERROR] ZstdArchiverTest.testCreateArchive:47 \u00bb NoClassDefFound org/apache/commons/io/...\n[ERROR] ZstdArchiverTest.testCreateResourceCollection:91 \u00bb NoClassDefFound org/apache/...\n[ERROR] ZstdArchiverTest.testZstIsForcedBehaviour:124->BasePlexusArchiverTest.createArchiver:108 \u00bb NoClassDefFound\n[INFO]\n[ERROR] Tests run: 185, Failures: 1, Errors: 84, Skipped: 3\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 21.140 s\n[INFO] Finished at: 2024-08-05T16:31:49Z\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.2:test (default-test) on project plexus-archiver: There are test failures.\n[ERROR]\n[ERROR] Please refer to /mnt/repo/target/surefire-reports for the individual test results.\n[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException",
            "span_id": 687529506925144580
        },
        {
            "input": "```diff\n--- a/pom.xml\n+++ b/pom.xml\n@@ -63,11 +63,6 @@\n       <artifactId>plexus-io</artifactId>\n       <version>3.4.1</version>\n     </dependency>\n-    <!-- Apache Commons dependencies -->\n-    <dependency>\n-      <groupId>commons-io</groupId>\n-      <artifactId>commons-io</artifactId>\n-      <version>20030203.000550</version>\n-    </dependency>\n     <dependency>\n       <groupId>org.apache.commons</groupId>\n       <artifactId>commons-compress</artifactId>\n```",
            "output": {
                "compilation_has_succeeded": true,
                "test_has_succeeded": true,
                "error_text": "",
                "updated_files": {
                    "pom.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.codehaus.plexus</groupId>\n    <artifactId>plexus</artifactId>\n    <version>10</version>\n  </parent>\n\n  <artifactId>plexus-archiver</artifactId>\n  <version>4.6.3-SNAPSHOT</version>\n  <name>Plexus Archiver Component</name>\n\n  <scm>\n    <connection>scm:git:https://github.com/codehaus-plexus/plexus-archiver.git</connection>\n    <developerConnection>scm:git:https://github.com/codehaus-plexus/plexus-archiver.git</developerConnection>\n    <url>http://github.com/codehaus-plexus/plexus-archiver/tree/${project.scm.tag}/</url>\n    <tag>plexus-archiver-4.6.1</tag>\n  </scm>\n  <issueManagement>\n    <system>jira</system>\n    <url>https://github.com/codehaus-plexus/plexus-archiver/issues</url>\n  </issueManagement>\n  <distributionManagement>\n    <site>\n      <id>github:gh-pages</id>\n      <url>${project.scm.developerConnection}</url>\n    </site>\n  </distributionManagement>\n\n  <properties>\n    <javaVersion>8</javaVersion>\n    <sisuVersion>0.3.5</sisuVersion>\n    <slf4jVersion>1.7.36</slf4jVersion>\n    <junitVersion>5.9.2</junitVersion>\n    <project.build.outputTimestamp>2023-03-01T06:25:43Z</project.build.outputTimestamp>\n  </properties>\n\n  <contributors>\n    <contributor>\n      <name>Dan Tran</name>\n    </contributor>\n    <contributor>\n      <name>Richard van der Hoff</name>\n    </contributor>\n    <contributor>\n      <name>Tomasz 'Trog' Welman</name>\n      <email>trog@swmud.pl</email>\n    </contributor>\n  </contributors>\n\n  <dependencies>\n    <!-- JSR330 -->\n    <dependency>\n      <groupId>javax.inject</groupId>\n      <artifactId>javax.inject</artifactId>\n      <version>1</version>\n    </dependency>\n    <!-- Plexus dependencies -->\n    <dependency>\n      <groupId>org.codehaus.plexus</groupId>\n      <artifactId>plexus-utils</artifactId>\n      <version>3.5.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.codehaus.plexus</groupId>\n      <artifactId>plexus-io</artifactId>\n      <version>3.4.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-compress</artifactId>\n      <version>1.22</version>\n    </dependency>\n    <!-- Other dependencies -->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>${slf4jVersion}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.iq80.snappy</groupId>\n      <artifactId>snappy</artifactId>\n      <version>0.4</version>\n    </dependency>\n    <dependency>\n      <groupId>org.tukaani</groupId>\n      <artifactId>xz</artifactId>\n      <version>1.9</version>\n      <scope>runtime</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.github.luben</groupId>\n      <artifactId>zstd-jni</artifactId>\n      <version>1.5.4-2</version>\n      <scope>runtime</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.google.code.findbugs</groupId>\n      <artifactId>jsr305</artifactId>\n      <version>3.0.2</version>\n      <scope>provided</scope>\n    </dependency>\n    <!-- Test dependencies -->\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-api</artifactId>\n      <version>${junitVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-engine</artifactId>\n      <version>${junitVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-simple</artifactId>\n      <version>${slf4jVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- Plexus container dependencies -->\n    <dependency>\n      <groupId>org.eclipse.sisu</groupId>\n      <artifactId>org.eclipse.sisu.inject</artifactId>\n      <version>${sisuVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.google.inject</groupId>\n      <artifactId>guice</artifactId>\n      <version>5.1.0</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.assertj</groupId>\n      <artifactId>assertj-core</artifactId>\n      <version>3.24.2</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-release-plugin</artifactId>\n        <configuration>\n          <!-- olamy: exclude files with strange names as failed here on osx -->\n          <checkModificationExcludes>\n            <checkModificationExclude>**/src/test/resources/utf8/**</checkModificationExclude>\n          </checkModificationExcludes>\n        </configuration>\n      </plugin>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-resources-plugin</artifactId>\n        <!--\n        maven totally change his way to copy symlink\n        this mean the symlink is copied as a symlink and not anymore as a new file\n        https://issues.apache.org/jira/browse/MRESOURCES-237\n        -->\n        <version>2.7</version>\n      </plugin>\n      <plugin>\n        <groupId>org.eclipse.sisu</groupId>\n        <artifactId>sisu-maven-plugin</artifactId>\n        <version>${sisuVersion}</version>\n        <executions>\n          <execution>\n            <id>index-project</id>\n            <goals>\n              <goal>main-index</goal>\n              <goal>test-index</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-scm-publish-plugin</artifactId>\n        <configuration>\n          <content>${project.reporting.outputDirectory}</content><!-- mono-module doesn't require site:stage -->\n        </configuration>\n        <executions>\n          <execution>\n            <id>scm-publish</id>\n            <phase>site-deploy</phase><!-- deploy site with maven-scm-publish-plugin -->\n            <goals>\n              <goal>publish-scm</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n"
                },
                "compile_error_details": {}
            },
            "error": "[INFO]\n[INFO] Results:\n[INFO]\n[WARNING] Tests run: 185, Failures: 0, Errors: 0, Skipped: 3\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 33.874 s\n[INFO] Finished at: 2024-08-05T16:32:45Z\n[INFO] ------------------------------------------------------------------------",
            "span_id": 1418676675893230102
        }
    ],
    "read_file": [
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ClosedInputStream();\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
            "error": "",
            "span_id": 11013470283663253503
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
            "output": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport javax.annotation.Nonnull;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.BoundedInputStream;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n */\npublic abstract class AbstractZipUnArchiver\n    extends AbstractUnArchiver\n{\n\n    private static final String NATIVE_ENCODING = \"native-encoding\";\n\n    private String encoding = \"UTF8\";\n\n    private long maxOutputSize = Long.MAX_VALUE;\n\n    public AbstractZipUnArchiver()\n    {\n    }\n\n    public AbstractZipUnArchiver( final File sourceFile )\n    {\n        super( sourceFile );\n    }\n\n    /**\n     * Sets the encoding to assume for file names and comments.\n     * <p>\n     * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n     * </p>\n     */\n    public void setEncoding( String encoding )\n    {\n        if ( NATIVE_ENCODING.equals( encoding ) )\n        {\n            encoding = null;\n        }\n        this.encoding = encoding;\n    }\n\n    /**\n     * Set maximum allowed size of the produced output.\n     *\n     * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n     *\n     * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n     * @throws IllegalArgumentException if specified output size is less or equal to 0\n     */\n    public void setMaxOutputSize( long maxOutputSize ) {\n        if ( maxOutputSize <= 0 ) {\n            throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n        }\n        this.maxOutputSize = maxOutputSize;\n    }\n\n    private static class ZipEntryFileInfo\n        implements PlexusIoResource\n    {\n\n        private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n\n        private final ZipArchiveEntry zipEntry;\n\n        ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                          final ZipArchiveEntry zipEntry )\n        {\n            this.zipFile = zipFile;\n            this.zipEntry = zipEntry;\n        }\n\n        public String getName()\n        {\n            return zipEntry.getName();\n        }\n\n        @Override\n        public boolean isDirectory()\n        {\n            return zipEntry.isDirectory();\n        }\n\n        @Override\n        public boolean isFile()\n        {\n            return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n        }\n\n        @Override\n        public boolean isSymbolicLink()\n        {\n            return zipEntry.isUnixSymlink();\n        }\n\n        @Nonnull\n        @Override\n        public InputStream getContents()\n            throws IOException\n        {\n            return zipFile.getInputStream( zipEntry );\n        }\n\n        @Override\n        public long getLastModified()\n        {\n            final long l = zipEntry.getTime();\n            return l == 0 ? PlexusIoResource.UNKNOWN_MODIFICATION_DATE : l;\n        }\n\n        @Override\n        public long getSize()\n        {\n            final long l = zipEntry.getSize();\n            return l == -1 ? PlexusIoResource.UNKNOWN_RESOURCE_SIZE : l;\n        }\n\n        @Override\n        public URL getURL()\n            throws IOException\n        {\n            return null;\n        }\n\n        @Override\n        public boolean isExisting()\n        {\n            return true;\n        }\n\n    }\n\n    @Override\n    protected void execute()\n        throws ArchiverException\n    {\n        execute( \"\", getDestDirectory() );\n    }\n\n    private String resolveSymlink( ZipFile zf, ZipArchiveEntry ze )\n        throws IOException\n    {\n        if ( ze.isUnixSymlink() )\n        {\n            return zf.getUnixSymlink( ze );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    protected void execute( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        getLogger().debug( \"Expanding: \" + getSourceFile() + \" into \" + outputDirectory );\n        try ( ZipFile zipFile = new ZipFile( getSourceFile(), encoding, true ) )\n        {\n            long remainingSpace = maxOutputSize;\n            final Enumeration<ZipArchiveEntry> e = zipFile.getEntriesInPhysicalOrder();\n\n            while ( e.hasMoreElements() )\n            {\n                final ZipArchiveEntry ze = e.nextElement();\n                final ZipEntryFileInfo fileInfo = new ZipEntryFileInfo( zipFile, ze );\n                if ( !isSelected( ze.getName(), fileInfo ) )\n                {\n                    continue;\n                }\n\n                if ( ze.getName().startsWith( path ) )\n                {\n                    try ( InputStream in = zipFile.getInputStream( ze ) )\n                    {\n                        BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n                        CountingInputStream cis = new CountingInputStream( bis );\n                        extractFile( getSourceFile(), outputDirectory, cis,\n                                     ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                     ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                     resolveSymlink( zipFile, ze ), getFileMappers() );\n\n                        remainingSpace -= cis.getByteCount();\n                        if ( remainingSpace < 0 )\n                        {\n                            throw new ArchiverException( \"Maximum output size limit reached\" );\n                        }\n                    }\n                }\n            }\n            getLogger().debug( \"expand complete\" );\n        }\n        catch ( final IOException ioe )\n        {\n            throw new ArchiverException( \"Error while expanding \" + getSourceFile().getAbsolutePath(), ioe );\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 2749722898203917782
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java",
            "output": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.apache.commons.io.output.NullPrintStream;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 14161861672009296710
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java",
            "output": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\nimport org.apache.commons.io.output.ThresholdingOutputStream;\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends ThresholdingOutputStream\n{\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        this( threshold, null, prefix, suffix, directory );\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        super( threshold );\n        this.outputFile = outputFile;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\n",
            "error": "",
            "span_id": 6435469936692894124
        },
        {
            "input": "src/test/java/org/codehaus/plexus/archiver/zip/PlexusIoZipFileResourceCollectionTest.java",
            "output": "package org.codehaus.plexus.archiver.zip;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.io.IOUtils;\nimport org.codehaus.plexus.archiver.TestSupport;\nimport org.codehaus.plexus.components.io.functions.SymlinkDestinationSupplier;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.components.io.resources.PlexusIoURLResource;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class PlexusIoZipFileResourceCollectionTest\n        extends TestSupport\n{\n\n    @Test\n    public void testNamelessRootFolder()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection resourceCollection = new PlexusIoZipFileResourceCollection();\n        resourceCollection.setFile( getTestFile( \"src/test/jars/namelessrootfolder.jar\" ) );\n        Iterator iterator = resourceCollection.getResources();\n        PlexusIoURLResource entry = (PlexusIoURLResource) iterator.next();\n        assertEquals( \"/dummy.txt\", entry.getName() );\n        final URL url = entry.getURL();\n        BufferedReader d = new BufferedReader( new InputStreamReader( entry.getContents() ) );\n        assertEquals( \"dummy content\", d.readLine() );\n    }\n\n    @Test\n    public void testDescriptionForError()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection resourceCollection = new PlexusIoZipFileResourceCollection();\n        resourceCollection.setFile( getTestFile( \"src/test/jars/namelessrootfolder.jar\" ) );\n        Iterator<PlexusIoResource> iterator = resourceCollection.getResources();\n        PlexusIoURLResource entry = (PlexusIoURLResource) iterator.next();\n        final URL url = entry.getURL();\n        String descriptionForError = entry.getDescriptionForError( url );\n        assertTrue( descriptionForError.endsWith( \"namelessrootfolder.jar!//dummy.txt\" ) );\n    }\n\n    @Test\n    public void testFilesWithIllegalHtmlChars()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/bogusManifest.zip\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            if ( next.getName().endsWith( \"MANIFEST.MF\" ) )\n            {\n                final InputStream contents1 = next.getContents();\n                final String manifest = IOUtils.toString( contents1, \"UTF-8\" );\n                assertTrue( manifest.contains( \"bogs=fus\" ) );\n                contents1.close();\n            }\n\n        }\n    }\n\n    @Test\n    public void testFilesThatAreNotThere()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/archiveWithIllegalHtmlFileName.zip\" );\n        Set<String> seen = new HashSet<>();\n        seen.add( \"AFileThatNeedsHtmlEsc%3F&gt\" );\n        seen.add( \"Afile&lt;Yo&gt;.txt\" );\n        seen.add( \"File With Space.txt\" );\n        seen.add( \"FileWith%.txt\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            assertTrue( seen.remove( next.getName() ), next.getName() + \"was not present\" );\n            final URL url = next.getURL();\n            final InputStream contents = next.getContents();\n            contents.close();\n        }\n    }\n\n    @Test\n    public void testSymlinkEntries()\n        throws Exception\n    {\n        File testZip = new File( getBasedir(), \"src/test/resources/symlinks/symlinks.zip\" );\n        Map<String, String> symLinks = new HashMap<>();\n        symLinks.put( \"symDir\", \"targetDir/\" );\n        symLinks.put( \"symLinkToDirOnTheOutside\", \"../dirOnTheOutside/\" );\n        symLinks.put( \"symLinkToTheOutside\", \"../onTheOutside.txt\" );\n        symLinks.put( \"symR\", \"fileR.txt\" );\n        symLinks.put( \"symW\", \"fileW.txt\" );\n        symLinks.put( \"symX\", \"fileX.txt\" );\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( testZip );\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            String symLinkTarget = symLinks.remove( next.getName() );\n            if ( symLinkTarget != null )\n            {\n                assertTrue( next.isSymbolicLink(), next.getName() + \" must be symlink\" );\n                assertTrue( next instanceof SymlinkDestinationSupplier );\n                assertEquals( symLinkTarget,\n                              ( (SymlinkDestinationSupplier) next ).getSymlinkDestination() );\n            }\n            else\n            {\n                assertFalse( next.isSymbolicLink(), next.getName() + \" must not be symlink\" );\n            }\n        }\n\n        assertTrue( symLinks.isEmpty() );\n    }\n\n    @Test\n    public void testUnarchiveUnicodePathExtra()\n        throws Exception\n    {\n        PlexusIoZipFileResourceCollection prc = new PlexusIoZipFileResourceCollection();\n        prc.setFile( getTestFile( \"src/test/resources/unicodePathExtra/efsclear.zip\" ) );\n        Set<String> names = new HashSet<>();\n        final Iterator<PlexusIoResource> entries = prc.getEntries();\n        while ( entries.hasNext() )\n        {\n            final PlexusIoResource next = entries.next();\n            names.add(next.getName());\n        }\n        // a Unicode Path extra field should only be used when its CRC matches the header file name\n        assertEquals( new HashSet<>( Arrays.asList( \"nameonly-name\", \"goodextra-extra\", \"badextra-name\" ) ), names,\n                      \"should use good extra fields but not bad ones\" );\n    }\n\n}\n",
            "error": "",
            "span_id": 14238182433368934452
        },
        {
            "input": "pom.xml",
            "output": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.codehaus.plexus</groupId>\n    <artifactId>plexus</artifactId>\n    <version>10</version>\n  </parent>\n\n  <artifactId>plexus-archiver</artifactId>\n  <version>4.6.3-SNAPSHOT</version>\n  <name>Plexus Archiver Component</name>\n\n  <scm>\n    <connection>scm:git:https://github.com/codehaus-plexus/plexus-archiver.git</connection>\n    <developerConnection>scm:git:https://github.com/codehaus-plexus/plexus-archiver.git</developerConnection>\n    <url>http://github.com/codehaus-plexus/plexus-archiver/tree/${project.scm.tag}/</url>\n    <tag>plexus-archiver-4.6.1</tag>\n  </scm>\n  <issueManagement>\n    <system>jira</system>\n    <url>https://github.com/codehaus-plexus/plexus-archiver/issues</url>\n  </issueManagement>\n  <distributionManagement>\n    <site>\n      <id>github:gh-pages</id>\n      <url>${project.scm.developerConnection}</url>\n    </site>\n  </distributionManagement>\n\n  <properties>\n    <javaVersion>8</javaVersion>\n    <sisuVersion>0.3.5</sisuVersion>\n    <slf4jVersion>1.7.36</slf4jVersion>\n    <junitVersion>5.9.2</junitVersion>\n    <project.build.outputTimestamp>2023-03-01T06:25:43Z</project.build.outputTimestamp>\n  </properties>\n\n  <contributors>\n    <contributor>\n      <name>Dan Tran</name>\n    </contributor>\n    <contributor>\n      <name>Richard van der Hoff</name>\n    </contributor>\n    <contributor>\n      <name>Tomasz 'Trog' Welman</name>\n      <email>trog@swmud.pl</email>\n    </contributor>\n  </contributors>\n\n  <dependencies>\n    <!-- JSR330 -->\n    <dependency>\n      <groupId>javax.inject</groupId>\n      <artifactId>javax.inject</artifactId>\n      <version>1</version>\n    </dependency>\n    <!-- Plexus dependencies -->\n    <dependency>\n      <groupId>org.codehaus.plexus</groupId>\n      <artifactId>plexus-utils</artifactId>\n      <version>3.5.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.codehaus.plexus</groupId>\n      <artifactId>plexus-io</artifactId>\n      <version>3.4.1</version>\n    </dependency>\n    <!-- Apache Commons dependencies -->\n    <dependency>\n      <groupId>commons-io</groupId>\n      <artifactId>commons-io</artifactId>\n      <version>20030203.000550</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-compress</artifactId>\n      <version>1.22</version>\n    </dependency>\n    <!-- Other dependencies -->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>${slf4jVersion}</version>\n    </dependency>\n    <dependency>\n      <groupId>org.iq80.snappy</groupId>\n      <artifactId>snappy</artifactId>\n      <version>0.4</version>\n    </dependency>\n    <dependency>\n      <groupId>org.tukaani</groupId>\n      <artifactId>xz</artifactId>\n      <version>1.9</version>\n      <scope>runtime</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.github.luben</groupId>\n      <artifactId>zstd-jni</artifactId>\n      <version>1.5.4-2</version>\n      <scope>runtime</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.google.code.findbugs</groupId>\n      <artifactId>jsr305</artifactId>\n      <version>3.0.2</version>\n      <scope>provided</scope>\n    </dependency>\n    <!-- Test dependencies -->\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-api</artifactId>\n      <version>${junitVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter-engine</artifactId>\n      <version>${junitVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-simple</artifactId>\n      <version>${slf4jVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- Plexus container dependencies -->\n    <dependency>\n      <groupId>org.eclipse.sisu</groupId>\n      <artifactId>org.eclipse.sisu.inject</artifactId>\n      <version>${sisuVersion}</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>com.google.inject</groupId>\n      <artifactId>guice</artifactId>\n      <version>5.1.0</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.assertj</groupId>\n      <artifactId>assertj-core</artifactId>\n      <version>3.24.2</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-release-plugin</artifactId>\n        <configuration>\n          <!-- olamy: exclude files with strange names as failed here on osx -->\n          <checkModificationExcludes>\n            <checkModificationExclude>**/src/test/resources/utf8/**</checkModificationExclude>\n          </checkModificationExcludes>\n        </configuration>\n      </plugin>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-resources-plugin</artifactId>\n        <!--\n        maven totally change his way to copy symlink\n        this mean the symlink is copied as a symlink and not anymore as a new file\n        https://issues.apache.org/jira/browse/MRESOURCES-237\n        -->\n        <version>2.7</version>\n      </plugin>\n      <plugin>\n        <groupId>org.eclipse.sisu</groupId>\n        <artifactId>sisu-maven-plugin</artifactId>\n        <version>${sisuVersion}</version>\n        <executions>\n          <execution>\n            <id>index-project</id>\n            <goals>\n              <goal>main-index</goal>\n              <goal>test-index</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-scm-publish-plugin</artifactId>\n        <configuration>\n          <content>${project.reporting.outputDirectory}</content><!-- mono-module doesn't require site:stage -->\n        </configuration>\n        <executions>\n          <execution>\n            <id>scm-publish</id>\n            <phase>site-deploy</phase><!-- deploy site with maven-scm-publish-plugin -->\n            <goals>\n              <goal>publish-scm</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n",
            "error": "",
            "span_id": 7044393235519202139
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}