{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n-import org.apache.commons.io.input.ClosedInputStream;\n+import java.io.InputStream;\n+import java.io.SequenceInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.io.UnsupportedEncodingException;\n@@\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n-import org.apache.commons.io.input.BoundedInputStream;\n@@\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipFile;\n+import org.apache.commons.io.input.CountingInputStream;\n+import org.codehaus.plexus.archiver.AbstractUnArchiver;\n+import org.codehaus.plexus.archiver.ArchiverException;\n+import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n@@\n-                        BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n--- src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@\n-import org.apache.commons.io.output.NullPrintStream;\n@@\n+import java.io.PrintStream;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+import org.codehaus.plexus.archiver.ArchiverException;\n+import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\n+import org.codehaus.plexus.util.IOUtil;\n@@\n-            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n+            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n+                @Override\n+                public void write(int b) throws IOException {\n+                    // no-op\n+                }\n+            });\n--- src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n@@\n-import org.apache.commons.io.output.ThresholdingOutputStream;\n@@\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.file.Files;\n+import org.apache.commons.io.output.ThresholdingOutputStream;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.io.UnsupportedEncodingException;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport javax.annotation.Nonnull;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n */\npublic abstract class AbstractZipUnArchiver\n    extends AbstractUnArchiver\n{\n\n    private static final String NATIVE_ENCODING = \"native-encoding\";\n\n    private String encoding = \"UTF8\";\n\n    private long maxOutputSize = Long.MAX_VALUE;\n\n    public AbstractZipUnArchiver()\n    {\n    }\n\n    public AbstractZipUnArchiver( final File sourceFile )\n    {\n        super( sourceFile );\n    }\n\n    /**\n     * Sets the encoding to assume for file names and comments.\n     * <p>\n     * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n     * </p>\n     */\n    public void setEncoding( String encoding )\n    {\n        if ( NATIVE_ENCODING.equals( encoding ) )\n        {\n            encoding = null;\n        }\n        this.encoding = encoding;\n    }\n\n    /**\n     * Set maximum allowed size of the produced output.\n     *\n     * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n     *\n     * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n     * @throws IllegalArgumentException if specified output size is less or equal to 0\n     */\n    public void setMaxOutputSize( long maxOutputSize ) {\n        if ( maxOutputSize <= 0 ) {\n            throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n        }\n        this.maxOutputSize = maxOutputSize;\n    }\n\n    private static class ZipEntryFileInfo\n        implements PlexusIoResource\n    {\n\n        private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n\n        private final ZipArchiveEntry zipEntry;\n\n        ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                          final ZipArchiveEntry zipEntry )\n        {\n            this.zipFile = zipFile;\n            this.zipEntry = zipEntry;\n        }\n\n        public String getName()\n        {\n            return zipEntry.getName();\n        }\n\n        @Override\n        public boolean isDirectory()\n        {\n            return zipEntry.isDirectory();\n        }\n\n        @Override\n        public boolean isFile()\n        {\n            return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n        }\n\n        @Override\n        public boolean isSymbolicLink()\n        {\n            return zipEntry.isUnixSymlink();\n        }\n\n        @Nonnull\n        @Override\n        public InputStream getContents()\n            throws IOException\n        {\n            return zipFile.getInputStream( zipEntry );\n        }\n\n        @Override\n        public long getLastModified()\n        {\n            final long l = zipEntry.getTime();\n            return l == 0 ? PlexusIoResource.UNKNOWN_MODIFICATION_DATE : l;\n        }\n\n        @Override\n        public long getSize()\n        {\n            final long l = zipEntry.getSize();\n            return l == -1 ? PlexusIoResource.UNKNOWN_RESOURCE_SIZE : l;\n        }\n\n        @Override\n        public URL getURL()\n            throws IOException\n        {\n            return null;\n        }\n\n        @Override\n        public boolean isExisting()\n        {\n            return true;\n        }\n\n    }\n\n    @Override\n    protected void execute()\n        throws ArchiverException\n    {\n        execute( \"\", getDestDirectory() );\n    }\n\n    private String resolveSymlink( ZipFile zf, ZipArchiveEntry ze )\n        throws IOException\n    {\n        if ( ze.isUnixSymlink() )\n        {\n            return zf.getUnixSymlink( ze );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    protected void execute( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        getLogger().debug( \"Expanding: \" + getSourceFile() + \" into \" + outputDirectory );\n        try ( ZipFile zipFile = new ZipFile( getSourceFile(), encoding, true ) )\n        {\n            long remainingSpace = maxOutputSize;\n            final Enumeration<ZipArchiveEntry> e = zipFile.getEntriesInPhysicalOrder();\n\n            while ( e.hasMoreElements() )\n            {\n                final ZipArchiveEntry ze = e.nextElement();\n                final ZipEntryFileInfo fileInfo = new ZipEntryFileInfo( zipFile, ze );\n                if ( !isSelected( ze.getName(), fileInfo ) )\n                {\n                    continue;\n                }\n\n                if ( ze.getName().startsWith( path ) )\n                {\n                    try ( InputStream in = zipFile.getInputStream( ze ) )\n                    {\n                        CountingInputStream cis = new CountingInputStream( bis );\n                        extractFile( getSourceFile(), outputDirectory, cis,\n                                     ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                     ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                     resolveSymlink( zipFile, ze ), getFileMappers() );\n\n                        remainingSpace -= cis.getByteCount();\n                        if ( remainingSpace < 0 )\n                        {\n                            throw new ArchiverException( \"Maximum output size limit reached\" );\n                        }\n                    }\n                }\n            }\n            getLogger().debug( \"expand complete\" );\n        }\n        catch ( final IOException ioe )\n        {\n            throw new ArchiverException( \"Error while expanding \" + getSourceFile().getAbsolutePath(), ioe );\n        }\n    }\n\n}\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n",
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    // no-op\n                }\n            });\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n",
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends ThresholdingOutputStream\n{\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        this( threshold, null, prefix, suffix, directory );\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        super( threshold );\n        this.outputFile = outputFile;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\nimport org.apache.commons.io.output.ThresholdingOutputStream;\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "316": {
                            "lines": [
                                {
                                    "line_no": 315,
                                    "content": "}"
                                },
                                {
                                    "line_no": 316,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 317,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[316,1] class, interface, or enum expected\n"
                            ]
                        },
                        "317": {
                            "lines": [
                                {
                                    "line_no": 316,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 317,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 318,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[317,1] class, interface, or enum expected\n"
                            ]
                        },
                        "318": {
                            "lines": [
                                {
                                    "line_no": 317,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 318,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 319,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[318,1] class, interface, or enum expected\n"
                            ]
                        },
                        "319": {
                            "lines": [
                                {
                                    "line_no": 318,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 319,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 320,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[319,1] class, interface, or enum expected\n"
                            ]
                        },
                        "320": {
                            "lines": [
                                {
                                    "line_no": 319,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 320,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 321,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[320,1] class, interface, or enum expected\n"
                            ]
                        },
                        "321": {
                            "lines": [
                                {
                                    "line_no": 320,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 321,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[321,1] class, interface, or enum expected\n"
                            ]
                        },
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 335,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "226": {
                            "lines": [
                                {
                                    "line_no": 225,
                                    "content": "}"
                                },
                                {
                                    "line_no": 226,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[226,1] class, interface, or enum expected\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 235,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 980458369799956726
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n-import org.apache.commons.io.input.ClosedInputStream;\n+import java.io.InputStream;\n+import java.io.SequenceInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.io.UnsupportedEncodingException;\n@@\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n-import org.apache.commons.io.input.BoundedInputStream;\n@@\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipFile;\n+import org.apache.commons.io.input.CountingInputStream;\n+import org.codehaus.plexus.archiver.AbstractUnArchiver;\n+import org.codehaus.plexus.archiver.ArchiverException;\n+import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n@@\n-                        BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n--- src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@\n-import org.apache.commons.io.output.NullPrintStream;\n@@\n+import java.io.PrintStream;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+import org.codehaus.plexus.archiver.ArchiverException;\n+import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\n+import org.codehaus.plexus.util.IOUtil;\n@@\n-            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n+            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n+                @Override\n+                public void write(int b) throws IOException {\n+                    // no-op\n+                }\n+            });\n--- src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n@@\n-import org.apache.commons.io.output.ThresholdingOutputStream;\n@@\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.file.Files;\n+import org.apache.commons.io.output.ThresholdingOutputStream;\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.input.ClosedInputStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain these 1 exact lines in a row:\n```\nreturn new ClosedInputStream();\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.input.BoundedInputStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain these 1 exact lines in a row:\n```\nBoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.output.NullPrintStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain these 1 exact lines in a row:\n```\nPrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.input.ClosedInputStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java does not contain these 1 exact lines in a row:\n```\nreturn new ClosedInputStream();\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.input.BoundedInputStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java does not contain these 1 exact lines in a row:\n```\nBoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain these 1 exact lines in a row:\n```\nimport org.apache.commons.io.output.NullPrintStream;\n```\nUnifiedDiffNoMatch: hunk failed to apply!\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java!\nMake extra sure the indentation is correct.\nsrc/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java does not contain these 1 exact lines in a row:\n```\nPrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n```",
            "span_id": 81517126431898758
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n@@\n             return new ClosedInputStream();\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n-        return new SequenceInputStream( Collections.enumeration( list ) );\n+        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n-import org.apache.commons.io.input.BoundedInputStream;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n@@\n                         if ( ze.getName().startsWith( path ) )\n                         {\n                             try ( InputStream in = zipFile.getInputStream( ze ) )\n                             {\n-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n                                 CountingInputStream cis = new CountingInputStream( bis );\n                                 extractFile( getSourceFile(), outputDirectory, cis,\n                                              ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                              ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                              resolveSymlink( zipFile, ze ), getFileMappers() );\n \n                                 remainingSpace -= cis.getByteCount();\n                                 if ( remainingSpace < 0 )\n                                 {\n                                     throw new ArchiverException( \"Maximum output size limit reached\" );\n                                 }\n                             }\n--- src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java\n@@\n import javax.inject.Named;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintStream;\n import java.lang.reflect.Method;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.FileTime;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Enumeration;\n import java.util.List;\n import java.util.Locale;\n import java.util.TimeZone;\n import java.util.regex.Pattern;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipFile;\n import java.util.zip.ZipOutputStream;\n \n-import org.apache.commons.io.output.NullPrintStream;\n import org.apache.commons.compress.parallel.InputStreamSupplier;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\n import org.codehaus.plexus.util.IOUtil;\n \n /**\n  * A {@link ModularJarArchiver} implementation that uses\n  * the {@code jar} tool provided by\n  * {@code java.util.spi.ToolProvider} to create\n  * modular JAR files.\n@@\n             getLogger().debug( \"Using the jar tool to \" +\n                 \"update the archive to modular JAR.\" );\n \n             final Method jarRun = jarTool.getClass()\n                 .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n \n             if ( getLastModifiedTime() != null )\n             {\n                 hasJarDateOption = isJarDateOptionSupported( jarRun );\n                 getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n             }\n \n-            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n+            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n+                @Override\n+                public void write(int b) throws IOException {\n+                    // no-op\n+                }\n+            });\n+            Integer result = (Integer) jarRun.invoke( jarTool, nullPrintStream, nullPrintStream, getJarToolArguments() );\n \n             if ( result != null && result != 0 )\n             {\n                 throw new ArchiverException( \"Could not create modular JAR file. \" +\n                     \"The JDK jar tool exited with \" + result );\n             }\n \n             if ( !hasJarDateOption && getLastModifiedTime() != null )\n             {\n                 getLogger().debug( \"Fix last modified time zip entries.\" );\n--- src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.nio.file.Files;\n \n-import org.apache.commons.io.output.ThresholdingOutputStream;\n \n /**\n  * Offloads to disk when a given memory consumption has been reacehd\n  */\n class OffloadingOutputStream extends ThresholdingOutputStream\n {\n \n     // ----------------------------------------------------------- Data members\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport javax.annotation.Nonnull;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n */\npublic abstract class AbstractZipUnArchiver\n    extends AbstractUnArchiver\n{\n\n    private static final String NATIVE_ENCODING = \"native-encoding\";\n\n    private String encoding = \"UTF8\";\n\n    private long maxOutputSize = Long.MAX_VALUE;\n\n    public AbstractZipUnArchiver()\n    {\n    }\n\n    public AbstractZipUnArchiver( final File sourceFile )\n    {\n        super( sourceFile );\n    }\n\n    /**\n     * Sets the encoding to assume for file names and comments.\n     * <p>\n     * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n     * </p>\n     */\n    public void setEncoding( String encoding )\n    {\n        if ( NATIVE_ENCODING.equals( encoding ) )\n        {\n            encoding = null;\n        }\n        this.encoding = encoding;\n    }\n\n    /**\n     * Set maximum allowed size of the produced output.\n     *\n     * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n     *\n     * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n     * @throws IllegalArgumentException if specified output size is less or equal to 0\n     */\n    public void setMaxOutputSize( long maxOutputSize ) {\n        if ( maxOutputSize <= 0 ) {\n            throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n        }\n        this.maxOutputSize = maxOutputSize;\n    }\n\n    private static class ZipEntryFileInfo\n        implements PlexusIoResource\n    {\n\n        private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n\n        private final ZipArchiveEntry zipEntry;\n\n        ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                          final ZipArchiveEntry zipEntry )\n        {\n            this.zipFile = zipFile;\n            this.zipEntry = zipEntry;\n        }\n\n        public String getName()\n        {\n            return zipEntry.getName();\n        }\n\n        @Override\n        public boolean isDirectory()\n        {\n            return zipEntry.isDirectory();\n        }\n\n        @Override\n        public boolean isFile()\n        {\n            return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n        }\n\n        @Override\n        public boolean isSymbolicLink()\n        {\n            return zipEntry.isUnixSymlink();\n        }\n\n        @Nonnull\n        @Override\n        public InputStream getContents()\n            throws IOException\n        {\n            return zipFile.getInputStream( zipEntry );\n        }\n\n        @Override\n        public long getLastModified()\n        {\n            final long l = zipEntry.getTime();\n            return l == 0 ? PlexusIoResource.UNKNOWN_MODIFICATION_DATE : l;\n        }\n\n        @Override\n        public long getSize()\n        {\n            final long l = zipEntry.getSize();\n            return l == -1 ? PlexusIoResource.UNKNOWN_RESOURCE_SIZE : l;\n        }\n\n        @Override\n        public URL getURL()\n            throws IOException\n        {\n            return null;\n        }\n\n        @Override\n        public boolean isExisting()\n        {\n            return true;\n        }\n\n    }\n\n    @Override\n    protected void execute()\n        throws ArchiverException\n    {\n        execute( \"\", getDestDirectory() );\n    }\n\n    private String resolveSymlink( ZipFile zf, ZipArchiveEntry ze )\n        throws IOException\n    {\n        if ( ze.isUnixSymlink() )\n        {\n            return zf.getUnixSymlink( ze );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    protected void execute( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        getLogger().debug( \"Expanding: \" + getSourceFile() + \" into \" + outputDirectory );\n        try ( ZipFile zipFile = new ZipFile( getSourceFile(), encoding, true ) )\n        {\n            long remainingSpace = maxOutputSize;\n            final Enumeration<ZipArchiveEntry> e = zipFile.getEntriesInPhysicalOrder();\n\n            while ( e.hasMoreElements() )\n            {\n                final ZipArchiveEntry ze = e.nextElement();\n                final ZipEntryFileInfo fileInfo = new ZipEntryFileInfo( zipFile, ze );\n                if ( !isSelected( ze.getName(), fileInfo ) )\n                {\n                    continue;\n                }\n\n                if ( ze.getName().startsWith( path ) )\n                {\n                    try ( InputStream in = zipFile.getInputStream( ze ) )\n                    {\n-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n                        CountingInputStream cis = new CountingInputStream( bis );\n                        extractFile( getSourceFile(), outputDirectory, cis,\n                                     ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                     ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                     resolveSymlink( zipFile, ze ), getFileMappers() );\n\n                        remainingSpace -= cis.getByteCount();\n                        if ( remainingSpace < 0 )\n                        {\n                            throw new ArchiverException( \"Maximum output size limit reached\" );\n                        }\n                    }\n                }\n            }\n            getLogger().debug( \"expand complete\" );\n        }\n        catch ( final IOException ioe )\n        {\n            throw new ArchiverException( \"Error while expanding \" + getSourceFile().getAbsolutePath(), ioe );\n        }\n    }\n\n}\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n",
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    // no-op\n                }\n            });\n            Integer result = (Integer) jarRun.invoke( jarTool, nullPrintStream, nullPrintStream, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = new PrintStream(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    // no-op\n                }\n            });\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n",
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends ThresholdingOutputStream\n{\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        this( threshold, null, prefix, suffix, directory );\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        super( threshold );\n        this.outputFile = outputFile;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\nimport org.apache.commons.io.output.ThresholdingOutputStream;\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 16063286119553536003
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n  * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n  * class. The original implementation only allocates 32 bytes at the beginning.\n  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n  * to the original it doesn't reallocate the whole memory block but allocates\n  * additional buffers. This way no buffers need to be garbage collected and\n  * the contents don't have to be copied to the new buffer. This class is\n  * designed to behave exactly like the original. The only exception is the\n  * deprecated toString(int) method that has been ignored.\n  */\n public class ByteArrayOutputStream extends OutputStream\n {\n \n     /**\n      * A singleton empty byte array.\n      */\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n \n     /**\n      * The list of buffers, which grows and never reduces.\n      */\n     private final List<byte[]> buffers = new ArrayList<byte[]>();\n \n     /**\n      * The index of the current buffer.\n      */\n     private int currentBufferIndex;\n \n     /**\n      * The total count of bytes in all the filled buffers.\n      */\n     private int filledBufferSum;\n \n     /**\n      * The current buffer.\n      */\n     private byte[] currentBuffer;\n \n     /**\n      * The total count of bytes written.\n      */\n     private int count;\n \n     /**\n      * Flag to indicate if the buffers can be reused after reset\n      */\n     private boolean reuseBuffers = true;\n \n     /**\n      * Creates a new byte array output stream. The buffer capacity is\n      * initially 1024 bytes, though its size increases if necessary.\n      */\n     public ByteArrayOutputStream()\n     {\n         this( 1024 );\n     }\n \n     /**\n      * Creates a new byte array output stream, with a buffer capacity of\n      * the specified size, in bytes.\n      *\n      * @param size the initial size\n      *\n      * @throws IllegalArgumentException if size is negative\n      */\n     public ByteArrayOutputStream( final int size )\n     {\n         if ( size < 0 )\n         {\n             throw new IllegalArgumentException( \"Negative initial size: \" + size );\n         }\n         synchronized ( this )\n         {\n             needNewBuffer( size );\n         }\n     }\n \n     /**\n      * Makes a new buffer available either by allocating\n      * a new one or re-cycling an existing one.\n      *\n      * @param newcount the size of the buffer if one is created\n      */\n     private void needNewBuffer( final int newcount )\n     {\n         if ( currentBufferIndex < buffers.size() - 1 )\n         {\n             //Recycling old buffer\n             filledBufferSum += currentBuffer.length;\n \n             currentBufferIndex++;\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Creating new buffer\n             int newBufferSize;\n             if ( currentBuffer == null )\n             {\n                 newBufferSize = newcount;\n                 filledBufferSum = 0;\n             }\n             else\n             {\n                 newBufferSize = Math.max(\n                     currentBuffer.length << 1,\n                     newcount - filledBufferSum );\n                 filledBufferSum += currentBuffer.length;\n             }\n \n             currentBufferIndex++;\n             currentBuffer = new byte[ newBufferSize ];\n             buffers.add( currentBuffer );\n         }\n     }\n \n     /**\n      * Write the bytes to byte array.\n      *\n      * @param b the bytes to write\n      * @param off The start offset\n      * @param len The number of bytes to write\n      */\n     @Override\n     public void write( final byte[] b, final int off, final int len )\n     {\n         if ( ( off < 0 )\n                  || ( off > b.length )\n                  || ( len < 0 )\n                  || ( ( off + len ) > b.length )\n                  || ( ( off + len ) < 0 ) )\n         {\n             throw new IndexOutOfBoundsException();\n         }\n         else if ( len == 0 )\n         {\n             return;\n         }\n         synchronized ( this )\n         {\n             final int newcount = count + len;\n             int remaining = len;\n             int inBufferPos = count - filledBufferSum;\n             while ( remaining > 0 )\n             {\n                 final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                 System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                 remaining -= part;\n                 if ( remaining > 0 )\n                 {\n                     needNewBuffer( newcount );\n                     inBufferPos = 0;\n                 }\n             }\n             count = newcount;\n         }\n     }\n \n     /**\n      * Write a byte to byte array.\n      *\n      * @param b the byte to write\n      */\n     @Override\n     public synchronized void write( final int b )\n     {\n         int inBufferPos = count - filledBufferSum;\n         if ( inBufferPos == currentBuffer.length )\n         {\n             needNewBuffer( count + 1 );\n             inBufferPos = 0;\n         }\n         currentBuffer[inBufferPos] = (byte) b;\n         count++;\n     }\n \n     /**\n      * Writes the entire contents of the specified input stream to this\n      * byte stream. Bytes from the input stream are read directly into the\n      * internal buffers of this streams.\n      *\n      * @param in the input stream to read from\n      *\n      * @return total number of bytes read from the input stream\n      * (and written to this stream)\n      *\n      * @throws java.io.IOException if an I/O error occurs while reading the input stream\n      * @since 1.4\n      */\n     public synchronized int write( final InputStream in ) throws IOException\n     {\n         int readCount = 0;\n         int inBufferPos = count - filledBufferSum;\n         int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         while ( n != -1 )\n         {\n             readCount += n;\n             inBufferPos += n;\n             count += n;\n             if ( inBufferPos == currentBuffer.length )\n             {\n                 needNewBuffer( currentBuffer.length );\n                 inBufferPos = 0;\n             }\n             n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         }\n         return readCount;\n     }\n \n     /**\n      * Return the current size of the byte array.\n      *\n      * @return the current size of the byte array\n      */\n     public synchronized int size()\n     {\n         return count;\n     }\n \n     /**\n      * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n      * this class can be called after the stream has been closed without\n      * generating an {@code IOException}.\n      *\n      * @throws java.io.IOException never (this method should not declare this exception\n      * but it has to now due to backwards compatibility)\n      */\n     @Override\n     public void close() throws IOException\n     {\n         //nop\n     }\n \n     /**\n      * @see java.io.ByteArrayOutputStream#reset()\n      */\n     public synchronized void reset()\n     {\n         count = 0;\n         filledBufferSum = 0;\n         currentBufferIndex = 0;\n         if ( reuseBuffers )\n         {\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Throw away old buffers\n             currentBuffer = null;\n             int size = buffers.get( 0 ).length;\n             buffers.clear();\n             needNewBuffer( size );\n             reuseBuffers = true;\n         }\n     }\n \n     /**\n      * Writes the entire contents of this byte stream to the\n      * specified output stream.\n      *\n      * @param out the output stream to write to\n      *\n      * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n      * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n      */\n     public synchronized void writeTo( final OutputStream out ) throws IOException\n     {\n         int remaining = count;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             out.write( buf, 0, c );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.0\n      */\n     public static InputStream toBufferedInputStream( final InputStream input )\n         throws IOException\n     {\n         return toBufferedInputStream( input, 1024 );\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      * @param size the initial buffer size\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.5\n      */\n     public static InputStream toBufferedInputStream( final InputStream input, int size )\n         throws IOException\n     {\n         // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n         @SuppressWarnings( \"resource\" )\n         final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n         output.write( input );\n         return output.toInputStream();\n     }\n \n     /**\n      * Gets the current contents of this byte stream as a Input Stream. The\n      * returned stream is backed by buffers of <code>this</code> stream,\n      * avoiding memory allocation and copy, thus saving space and time.<br>\n      *\n      * @return the current contents of this output stream.\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      * @see #reset()\n      * @since 2.5\n      */\n     public synchronized InputStream toInputStream()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n         return new SequenceInputStream( Collections.enumeration( list ) );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n     public synchronized byte[] toByteArray()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte newbuf[] = new byte[ remaining ];\n         int pos = 0;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             System.arraycopy( buf, 0, newbuf, pos, c );\n             pos += c;\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         return newbuf;\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the platform default charset.\n      *\n      * @return the contents of the byte array as a String\n      *\n      * @see java.io.ByteArrayOutputStream#toString()\n      * @deprecated 2.5 use {@link #toString(String)} instead\n      */\n     @Override\n     @Deprecated\n     public String toString()\n     {\n         // make explicit the use of the default charset\n         return new String( toByteArray(), Charset.defaultCharset() );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param enc the name of the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      */\n     public String toString( final String enc ) throws UnsupportedEncodingException\n     {\n         return new String( toByteArray(), enc );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param charset the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      * @since 2.5\n      */\n     public String toString( final Charset charset )\n     {\n         return new String( toByteArray(), charset );\n     }\n \n }\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n     extends AbstractUnArchiver\n {\n \n     private static final String NATIVE_ENCODING = \"native-encoding\";\n \n     private String encoding = \"UTF8\";\n \n     private long maxOutputSize = Long.MAX_VALUE;\n \n     public AbstractZipUnArchiver()\n     {\n     }\n \n     public AbstractZipUnArchiver( final File sourceFile )\n     {\n         super( sourceFile );\n     }\n \n     /**\n      * Sets the encoding to assume for file names and comments.\n      * <p>\n      * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n      * </p>\n      */\n     public void setEncoding( String encoding )\n     {\n         if ( NATIVE_ENCODING.equals( encoding ) )\n         {\n             encoding = null;\n         }\n         this.encoding = encoding;\n     }\n \n     /**\n      * Set maximum allowed size of the produced output.\n      *\n      * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n      *\n      * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n      * @throws IllegalArgumentException if specified output size is less or equal to 0\n      */\n     public void setMaxOutputSize( long maxOutputSize ) {\n         if ( maxOutputSize <= 0 ) {\n             throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n         }\n         this.maxOutputSize = maxOutputSize;\n     }\n \n     private static class ZipEntryFileInfo\n         implements PlexusIoResource\n     {\n \n         private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n \n         private final ZipArchiveEntry zipEntry;\n \n         ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                           final ZipArchiveEntry zipEntry )\n         {\n             this.zipFile = zipFile;\n             this.zipEntry = zipEntry;\n         }\n \n         public String getName()\n         {\n             return zipEntry.getName();\n         }\n \n         @Override\n         public boolean isDirectory()\n         {\n             return zipEntry.isDirectory();\n         }\n \n         @Override\n         public boolean isFile()\n         {\n             return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n         }\n \n         @Override\n         public boolean isSymbolicLink()\n        ",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 13910775617783758361
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n  * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n  * class. The original implementation only allocates 32 bytes at the beginning.\n  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n  * to the original it doesn't reallocate the whole memory block but allocates\n  * additional buffers. This way no buffers need to be garbage collected and\n  * the contents don't have to be copied to the new buffer. This class is\n  * designed to behave exactly like the original. The only exception is the\n  * deprecated toString(int) method that has been ignored.\n  */\n public class ByteArrayOutputStream extends OutputStream\n {\n \n     /**\n      * A singleton empty byte array.\n      */\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n \n     /**\n      * The list of buffers, which grows and never reduces.\n      */\n     private final List<byte[]> buffers = new ArrayList<byte[]>();\n \n     /**\n      * The index of the current buffer.\n      */\n     private int currentBufferIndex;\n \n     /**\n      * The total count of bytes in all the filled buffers.\n      */\n     private int filledBufferSum;\n \n     /**\n      * The current buffer.\n      */\n     private byte[] currentBuffer;\n \n     /**\n      * The total count of bytes written.\n      */\n     private int count;\n \n     /**\n      * Flag to indicate if the buffers can be reused after reset\n      */\n     private boolean reuseBuffers = true;\n \n     /**\n      * Creates a new byte array output stream. The buffer capacity is\n      * initially 1024 bytes, though its size increases if necessary.\n      */\n     public ByteArrayOutputStream()\n     {\n         this( 1024 );\n     }\n \n     /**\n      * Creates a new byte array output stream, with a buffer capacity of\n      * the specified size, in bytes.\n      *\n      * @param size the initial size\n      *\n      * @throws IllegalArgumentException if size is negative\n      */\n     public ByteArrayOutputStream( final int size )\n     {\n         if ( size < 0 )\n         {\n             throw new IllegalArgumentException( \"Negative initial size: \" + size );\n         }\n         synchronized ( this )\n         {\n             needNewBuffer( size );\n         }\n     }\n \n     /**\n      * Makes a new buffer available either by allocating\n      * a new one or re-cycling an existing one.\n      *\n      * @param newcount the size of the buffer if one is created\n      */\n     private void needNewBuffer( final int newcount )\n     {\n         if ( currentBufferIndex < buffers.size() - 1 )\n         {\n             //Recycling old buffer\n             filledBufferSum += currentBuffer.length;\n \n             currentBufferIndex++;\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Creating new buffer\n             int newBufferSize;\n             if ( currentBuffer == null )\n             {\n                 newBufferSize = newcount;\n                 filledBufferSum = 0;\n             }\n             else\n             {\n                 newBufferSize = Math.max(\n                     currentBuffer.length << 1,\n                     newcount - filledBufferSum );\n                 filledBufferSum += currentBuffer.length;\n             }\n \n             currentBufferIndex++;\n             currentBuffer = new byte[ newBufferSize ];\n             buffers.add( currentBuffer );\n         }\n     }\n \n     /**\n      * Write the bytes to byte array.\n      *\n      * @param b the bytes to write\n      * @param off The start offset\n      * @param len The number of bytes to write\n      */\n     @Override\n     public void write( final byte[] b, final int off, final int len )\n     {\n         if ( ( off < 0 )\n                  || ( off > b.length )\n                  || ( len < 0 )\n                  || ( ( off + len ) > b.length )\n                  || ( ( off + len ) < 0 ) )\n         {\n             throw new IndexOutOfBoundsException();\n         }\n         else if ( len == 0 )\n         {\n             return;\n         }\n         synchronized ( this )\n         {\n             final int newcount = count + len;\n             int remaining = len;\n             int inBufferPos = count - filledBufferSum;\n             while ( remaining > 0 )\n             {\n                 final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                 System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                 remaining -= part;\n                 if ( remaining > 0 )\n                 {\n                     needNewBuffer( newcount );\n                     inBufferPos = 0;\n                 }\n             }\n             count = newcount;\n         }\n     }\n \n     /**\n      * Write a byte to byte array.\n      *\n      * @param b the byte to write\n      */\n     @Override\n     public synchronized void write( final int b )\n     {\n         int inBufferPos = count - filledBufferSum;\n         if ( inBufferPos == currentBuffer.length )\n         {\n             needNewBuffer( count + 1 );\n             inBufferPos = 0;\n         }\n         currentBuffer[inBufferPos] = (byte) b;\n         count++;\n     }\n \n     /**\n      * Writes the entire contents of the specified input stream to this\n      * byte stream. Bytes from the input stream are read directly into the\n      * internal buffers of this streams.\n      *\n      * @param in the input stream to read from\n      *\n      * @return total number of bytes read from the input stream\n      * (and written to this stream)\n      *\n      * @throws java.io.IOException if an I/O error occurs while reading the input stream\n      * @since 1.4\n      */\n     public synchronized int write( final InputStream in ) throws IOException\n     {\n         int readCount = 0;\n         int inBufferPos = count - filledBufferSum;\n         int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         while ( n != -1 )\n         {\n             readCount += n;\n             inBufferPos += n;\n             count += n;\n             if ( inBufferPos == currentBuffer.length )\n             {\n                 needNewBuffer( currentBuffer.length );\n                 inBufferPos = 0;\n             }\n             n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         }\n         return readCount;\n     }\n \n     /**\n      * Return the current size of the byte array.\n      *\n      * @return the current size of the byte array\n      */\n     public synchronized int size()\n     {\n         return count;\n     }\n \n     /**\n      * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n      * this class can be called after the stream has been closed without\n      * generating an {@code IOException}.\n      *\n      * @throws java.io.IOException never (this method should not declare this exception\n      * but it has to now due to backwards compatibility)\n      */\n     @Override\n     public void close() throws IOException\n     {\n         //nop\n     }\n \n     /**\n      * @see java.io.ByteArrayOutputStream#reset()\n      */\n     public synchronized void reset()\n     {\n         count = 0;\n         filledBufferSum = 0;\n         currentBufferIndex = 0;\n         if ( reuseBuffers )\n         {\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Throw away old buffers\n             currentBuffer = null;\n             int size = buffers.get( 0 ).length;\n             buffers.clear();\n             needNewBuffer( size );\n             reuseBuffers = true;\n         }\n     }\n \n     /**\n      * Writes the entire contents of this byte stream to the\n      * specified output stream.\n      *\n      * @param out the output stream to write to\n      *\n      * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n      * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n      */\n     public synchronized void writeTo( final OutputStream out ) throws IOException\n     {\n         int remaining = count;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             out.write( buf, 0, c );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.0\n      */\n     public static InputStream toBufferedInputStream( final InputStream input )\n         throws IOException\n     {\n         return toBufferedInputStream( input, 1024 );\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      * @param size the initial buffer size\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.5\n      */\n     public static InputStream toBufferedInputStream( final InputStream input, int size )\n         throws IOException\n     {\n         // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n         @SuppressWarnings( \"resource\" )\n         final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n         output.write( input );\n         return output.toInputStream();\n     }\n \n     /**\n      * Gets the current contents of this byte stream as a Input Stream. The\n      * returned stream is backed by buffers of <code>this</code> stream,\n      * avoiding memory allocation and copy, thus saving space and time.<br>\n      *\n      * @return the current contents of this output stream.\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      * @see #reset()\n      * @since 2.5\n      */\n     public synchronized InputStream toInputStream()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n         return new SequenceInputStream( Collections.enumeration( list ) );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n     public synchronized byte[] toByteArray()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte newbuf[] = new byte[ remaining ];\n         int pos = 0;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             System.arraycopy( buf, 0, newbuf, pos, c );\n             pos += c;\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         return newbuf;\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the platform default charset.\n      *\n      * @return the contents of the byte array as a String\n      *\n      * @see java.io.ByteArrayOutputStream#toString()\n      * @deprecated 2.5 use {@link #toString(String)} instead\n      */\n     @Override\n     @Deprecated\n     public String toString()\n     {\n         // make explicit the use of the default charset\n         return new String( toByteArray(), Charset.defaultCharset() );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param enc the name of the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      */\n     public String toString( final String enc ) throws UnsupportedEncodingException\n     {\n         return new String( toByteArray(), enc );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param charset the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      * @since 2.5\n      */\n     public String toString( final Charset charset )\n     {\n         return new String( toByteArray(), charset );\n     }\n \n }\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n     extends AbstractUnArchiver\n {\n \n     private static final String NATIVE_ENCODING = \"native-encoding\";\n \n     private String encoding = \"UTF8\";\n \n     private long maxOutputSize = Long.MAX_VALUE;\n \n     public AbstractZipUnArchiver()\n     {\n     }\n \n     public AbstractZipUnArchiver( final File sourceFile )\n     {\n         super( sourceFile );\n     }\n \n     /**\n      * Sets the encoding to assume for file names and comments.\n      * <p>\n      * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n      * </p>\n      */\n     public void setEncoding( String encoding )\n     {\n         if ( NATIVE_ENCODING.equals( encoding ) )\n         {\n             encoding = null;\n         }\n         this.encoding = encoding;\n     }\n \n     /**\n      * Set maximum allowed size of the produced output.\n      *\n      * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n      *\n      * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n      * @throws IllegalArgumentException if specified output size is less or equal to 0\n      */\n     public void setMaxOutputSize( long maxOutputSize ) {\n         if ( maxOutputSize <= 0 ) {\n             throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n         }\n         this.maxOutputSize = maxOutputSize;\n     }\n \n     private static class ZipEntryFileInfo\n         implements PlexusIoResource\n     {\n \n         private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n \n         private final ZipArchiveEntry zipEntry;\n \n         ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                           final ZipArchiveEntry zipEntry )\n         {\n             this.zipFile = zipFile;\n             this.zipEntry = zipEntry;\n         }\n \n         public String getName()\n         {\n             return zipEntry.getName();\n         }\n \n         @Override\n         public boolean isDirectory()\n         {\n             return zipEntry.isDirectory();\n         }\n \n         @Override\n         public boolean isFile()\n         {\n             return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n         }\n \n         @Override\n         public boolean isSymbolicLink()\n        ",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 12435240871461474392
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n  * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n  * class. The original implementation only allocates 32 bytes at the beginning.\n  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n  * to the original it doesn't reallocate the whole memory block but allocates\n  * additional buffers. This way no buffers need to be garbage collected and\n  * the contents don't have to be copied to the new buffer. This class is\n  * designed to behave exactly like the original. The only exception is the\n  * deprecated toString(int) method that has been ignored.\n  */\n public class ByteArrayOutputStream extends OutputStream\n {\n \n     /**\n      * A singleton empty byte array.\n      */\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n \n     /**\n      * The list of buffers, which grows and never reduces.\n      */\n     private final List<byte[]> buffers = new ArrayList<byte[]>();\n \n     /**\n      * The index of the current buffer.\n      */\n     private int currentBufferIndex;\n \n     /**\n      * The total count of bytes in all the filled buffers.\n      */\n     private int filledBufferSum;\n \n     /**\n      * The current buffer.\n      */\n     private byte[] currentBuffer;\n \n     /**\n      * The total count of bytes written.\n      */\n     private int count;\n \n     /**\n      * Flag to indicate if the buffers can be reused after reset\n      */\n     private boolean reuseBuffers = true;\n \n     /**\n      * Creates a new byte array output stream. The buffer capacity is\n      * initially 1024 bytes, though its size increases if necessary.\n      */\n     public ByteArrayOutputStream()\n     {\n         this( 1024 );\n     }\n \n     /**\n      * Creates a new byte array output stream, with a buffer capacity of\n      * the specified size, in bytes.\n      *\n      * @param size the initial size\n      *\n      * @throws IllegalArgumentException if size is negative\n      */\n     public ByteArrayOutputStream( final int size )\n     {\n         if ( size < 0 )\n         {\n             throw new IllegalArgumentException( \"Negative initial size: \" + size );\n         }\n         synchronized ( this )\n         {\n             needNewBuffer( size );\n         }\n     }\n \n     /**\n      * Makes a new buffer available either by allocating\n      * a new one or re-cycling an existing one.\n      *\n      * @param newcount the size of the buffer if one is created\n      */\n     private void needNewBuffer( final int newcount )\n     {\n         if ( currentBufferIndex < buffers.size() - 1 )\n         {\n             //Recycling old buffer\n             filledBufferSum += currentBuffer.length;\n \n             currentBufferIndex++;\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Creating new buffer\n             int newBufferSize;\n             if ( currentBuffer == null )\n             {\n                 newBufferSize = newcount;\n                 filledBufferSum = 0;\n             }\n             else\n             {\n                 newBufferSize = Math.max(\n                     currentBuffer.length << 1,\n                     newcount - filledBufferSum );\n                 filledBufferSum += currentBuffer.length;\n             }\n \n             currentBufferIndex++;\n             currentBuffer = new byte[ newBufferSize ];\n             buffers.add( currentBuffer );\n         }\n     }\n \n     /**\n      * Write the bytes to byte array.\n      *\n      * @param b the bytes to write\n      * @param off The start offset\n      * @param len The number of bytes to write\n      */\n     @Override\n     public void write( final byte[] b, final int off, final int len )\n     {\n         if ( ( off < 0 )\n                  || ( off > b.length )\n                  || ( len < 0 )\n                  || ( ( off + len ) > b.length )\n                  || ( ( off + len ) < 0 ) )\n         {\n             throw new IndexOutOfBoundsException();\n         }\n         else if ( len == 0 )\n         {\n             return;\n         }\n         synchronized ( this )\n         {\n             final int newcount = count + len;\n             int remaining = len;\n             int inBufferPos = count - filledBufferSum;\n             while ( remaining > 0 )\n             {\n                 final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                 System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                 remaining -= part;\n                 if ( remaining > 0 )\n                 {\n                     needNewBuffer( newcount );\n                     inBufferPos = 0;\n                 }\n             }\n             count = newcount;\n         }\n     }\n \n     /**\n      * Write a byte to byte array.\n      *\n      * @param b the byte to write\n      */\n     @Override\n     public synchronized void write( final int b )\n     {\n         int inBufferPos = count - filledBufferSum;\n         if ( inBufferPos == currentBuffer.length )\n         {\n             needNewBuffer( count + 1 );\n             inBufferPos = 0;\n         }\n         currentBuffer[inBufferPos] = (byte) b;\n         count++;\n     }\n \n     /**\n      * Writes the entire contents of the specified input stream to this\n      * byte stream. Bytes from the input stream are read directly into the\n      * internal buffers of this streams.\n      *\n      * @param in the input stream to read from\n      *\n      * @return total number of bytes read from the input stream\n      * (and written to this stream)\n      *\n      * @throws java.io.IOException if an I/O error occurs while reading the input stream\n      * @since 1.4\n      */\n     public synchronized int write( final InputStream in ) throws IOException\n     {\n         int readCount = 0;\n         int inBufferPos = count - filledBufferSum;\n         int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         while ( n != -1 )\n         {\n             readCount += n;\n             inBufferPos += n;\n             count += n;\n             if ( inBufferPos == currentBuffer.length )\n             {\n                 needNewBuffer( currentBuffer.length );\n                 inBufferPos = 0;\n             }\n             n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         }\n         return readCount;\n     }\n \n     /**\n      * Return the current size of the byte array.\n      *\n      * @return the current size of the byte array\n      */\n     public synchronized int size()\n     {\n         return count;\n     }\n \n     /**\n      * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n      * this class can be called after the stream has been closed without\n      * generating an {@code IOException}.\n      *\n      * @throws java.io.IOException never (this method should not declare this exception\n      * but it has to now due to backwards compatibility)\n      */\n     @Override\n     public void close() throws IOException\n     {\n         //nop\n     }\n \n     /**\n      * @see java.io.ByteArrayOutputStream#reset()\n      */\n     public synchronized void reset()\n     {\n         count = 0;\n         filledBufferSum = 0;\n         currentBufferIndex = 0;\n         if ( reuseBuffers )\n         {\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Throw away old buffers\n             currentBuffer = null;\n             int size = buffers.get( 0 ).length;\n             buffers.clear();\n             needNewBuffer( size );\n             reuseBuffers = true;\n         }\n     }\n \n     /**\n      * Writes the entire contents of this byte stream to the\n      * specified output stream.\n      *\n      * @param out the output stream to write to\n      *\n      * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n      * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n      */\n     public synchronized void writeTo( final OutputStream out ) throws IOException\n     {\n         int remaining = count;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             out.write( buf, 0, c );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.0\n      */\n     public static InputStream toBufferedInputStream( final InputStream input )\n         throws IOException\n     {\n         return toBufferedInputStream( input, 1024 );\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      * @param size the initial buffer size\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.5\n      */\n     public static InputStream toBufferedInputStream( final InputStream input, int size )\n         throws IOException\n     {\n         // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n         @SuppressWarnings( \"resource\" )\n         final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n         output.write( input );\n         return output.toInputStream();\n     }\n \n     /**\n      * Gets the current contents of this byte stream as a Input Stream. The\n      * returned stream is backed by buffers of <code>this</code> stream,\n      * avoiding memory allocation and copy, thus saving space and time.<br>\n      *\n      * @return the current contents of this output stream.\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      * @see #reset()\n      * @since 2.5\n      */\n     public synchronized InputStream toInputStream()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n         return new SequenceInputStream( Collections.enumeration( list ) );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n     public synchronized byte[] toByteArray()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte newbuf[] = new byte[ remaining ];\n         int pos = 0;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             System.arraycopy( buf, 0, newbuf, pos, c );\n             pos += c;\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         return newbuf;\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the platform default charset.\n      *\n      * @return the contents of the byte array as a String\n      *\n      * @see java.io.ByteArrayOutputStream#toString()\n      * @deprecated 2.5 use {@link #toString(String)} instead\n      */\n     @Override\n     @Deprecated\n     public String toString()\n     {\n         // make explicit the use of the default charset\n         return new String( toByteArray(), Charset.defaultCharset() );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param enc the name of the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      */\n     public String toString( final String enc ) throws UnsupportedEncodingException\n     {\n         return new String( toByteArray(), enc );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param charset the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      * @since 2.5\n      */\n     public String toString( final Charset charset )\n     {\n         return new String( toByteArray(), charset );\n     }\n \n }\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n     extends AbstractUnArchiver\n {\n \n     private static final String NATIVE_ENCODING = \"native-encoding\";\n \n     private String encoding = \"UTF8\";\n \n     private long maxOutputSize = Long.MAX_VALUE;\n \n     public AbstractZipUnArchiver()\n     {\n     }\n \n     public AbstractZipUnArchiver( final File sourceFile )\n     {\n         super( sourceFile );\n     }\n \n     /**\n      * Sets the encoding to assume for file names and comments.\n      * <p>\n      * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n      * </p>\n      */\n     public void setEncoding( String encoding )\n     {\n         if ( NATIVE_ENCODING.equals( encoding ) )\n         {\n             encoding = null;\n         }\n         this.encoding = encoding;\n     }\n \n     /**\n      * Set maximum allowed size of the produced output.\n      *\n      * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n      *\n      * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n      * @throws IllegalArgumentException if specified output size is less or equal to 0\n      */\n     public void setMaxOutputSize( long maxOutputSize ) {\n         if ( maxOutputSize <= 0 ) {\n             throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n         }\n         this.maxOutputSize = maxOutputSize;\n     }\n \n     private static class ZipEntryFileInfo\n         implements PlexusIoResource\n     {\n \n         private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n \n         private final ZipArchiveEntry zipEntry;\n \n         ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                           final ZipArchiveEntry zipEntry )\n         {\n             this.zipFile = zipFile;\n             this.zipEntry = zipEntry;\n         }\n \n         public String getName()\n         {\n             return zipEntry.getName();\n         }\n \n         @Override\n         public boolean isDirectory()\n         {\n             return zipEntry.isDirectory();\n         }\n \n         @Override\n         public boolean isFile()\n         {\n             return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n         }\n \n         @Override\n         public boolean isSymbolicLink()\n        ",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 6012360942175111936
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n  * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n  * class. The original implementation only allocates 32 bytes at the beginning.\n  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n  * to the original it doesn't reallocate the whole memory block but allocates\n  * additional buffers. This way no buffers need to be garbage collected and\n  * the contents don't have to be copied to the new buffer. This class is\n  * designed to behave exactly like the original. The only exception is the\n  * deprecated toString(int) method that has been ignored.\n  */\n public class ByteArrayOutputStream extends OutputStream\n {\n \n     /**\n      * A singleton empty byte array.\n      */\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n \n     /**\n      * The list of buffers, which grows and never reduces.\n      */\n     private final List<byte[]> buffers = new ArrayList<byte[]>();\n \n     /**\n      * The index of the current buffer.\n      */\n     private int currentBufferIndex;\n \n     /**\n      * The total count of bytes in all the filled buffers.\n      */\n     private int filledBufferSum;\n \n     /**\n      * The current buffer.\n      */\n     private byte[] currentBuffer;\n \n     /**\n      * The total count of bytes written.\n      */\n     private int count;\n \n     /**\n      * Flag to indicate if the buffers can be reused after reset\n      */\n     private boolean reuseBuffers = true;\n \n     /**\n      * Creates a new byte array output stream. The buffer capacity is\n      * initially 1024 bytes, though its size increases if necessary.\n      */\n     public ByteArrayOutputStream()\n     {\n         this( 1024 );\n     }\n \n     /**\n      * Creates a new byte array output stream, with a buffer capacity of\n      * the specified size, in bytes.\n      *\n      * @param size the initial size\n      *\n      * @throws IllegalArgumentException if size is negative\n      */\n     public ByteArrayOutputStream( final int size )\n     {\n         if ( size < 0 )\n         {\n             throw new IllegalArgumentException( \"Negative initial size: \" + size );\n         }\n         synchronized ( this )\n         {\n             needNewBuffer( size );\n         }\n     }\n \n     /**\n      * Makes a new buffer available either by allocating\n      * a new one or re-cycling an existing one.\n      *\n      * @param newcount the size of the buffer if one is created\n      */\n     private void needNewBuffer( final int newcount )\n     {\n         if ( currentBufferIndex < buffers.size() - 1 )\n         {\n             //Recycling old buffer\n             filledBufferSum += currentBuffer.length;\n \n             currentBufferIndex++;\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Creating new buffer\n             int newBufferSize;\n             if ( currentBuffer == null )\n             {\n                 newBufferSize = newcount;\n                 filledBufferSum = 0;\n             }\n             else\n             {\n                 newBufferSize = Math.max(\n                     currentBuffer.length << 1,\n                     newcount - filledBufferSum );\n                 filledBufferSum += currentBuffer.length;\n             }\n \n             currentBufferIndex++;\n             currentBuffer = new byte[ newBufferSize ];\n             buffers.add( currentBuffer );\n         }\n     }\n \n     /**\n      * Write the bytes to byte array.\n      *\n      * @param b the bytes to write\n      * @param off The start offset\n      * @param len The number of bytes to write\n      */\n     @Override\n     public void write( final byte[] b, final int off, final int len )\n     {\n         if ( ( off < 0 )\n                  || ( off > b.length )\n                  || ( len < 0 )\n                  || ( ( off + len ) > b.length )\n                  || ( ( off + len ) < 0 ) )\n         {\n             throw new IndexOutOfBoundsException();\n         }\n         else if ( len == 0 )\n         {\n             return;\n         }\n         synchronized ( this )\n         {\n             final int newcount = count + len;\n             int remaining = len;\n             int inBufferPos = count - filledBufferSum;\n             while ( remaining > 0 )\n             {\n                 final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                 System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                 remaining -= part;\n                 if ( remaining > 0 )\n                 {\n                     needNewBuffer( newcount );\n                     inBufferPos = 0;\n                 }\n             }\n             count = newcount;\n         }\n     }\n \n     /**\n      * Write a byte to byte array.\n      *\n      * @param b the byte to write\n      */\n     @Override\n     public synchronized void write( final int b )\n     {\n         int inBufferPos = count - filledBufferSum;\n         if ( inBufferPos == currentBuffer.length )\n         {\n             needNewBuffer( count + 1 );\n             inBufferPos = 0;\n         }\n         currentBuffer[inBufferPos] = (byte) b;\n         count++;\n     }\n \n     /**\n      * Writes the entire contents of the specified input stream to this\n      * byte stream. Bytes from the input stream are read directly into the\n      * internal buffers of this streams.\n      *\n      * @param in the input stream to read from\n      *\n      * @return total number of bytes read from the input stream\n      * (and written to this stream)\n      *\n      * @throws java.io.IOException if an I/O error occurs while reading the input stream\n      * @since 1.4\n      */\n     public synchronized int write( final InputStream in ) throws IOException\n     {\n         int readCount = 0;\n         int inBufferPos = count - filledBufferSum;\n         int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         while ( n != -1 )\n         {\n             readCount += n;\n             inBufferPos += n;\n             count += n;\n             if ( inBufferPos == currentBuffer.length )\n             {\n                 needNewBuffer( currentBuffer.length );\n                 inBufferPos = 0;\n             }\n             n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         }\n         return readCount;\n     }\n \n     /**\n      * Return the current size of the byte array.\n      *\n      * @return the current size of the byte array\n      */\n     public synchronized int size()\n     {\n         return count;\n     }\n \n     /**\n      * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n      * this class can be called after the stream has been closed without\n      * generating an {@code IOException}.\n      *\n      * @throws java.io.IOException never (this method should not declare this exception\n      * but it has to now due to backwards compatibility)\n      */\n     @Override\n     public void close() throws IOException\n     {\n         //nop\n     }\n \n     /**\n      * @see java.io.ByteArrayOutputStream#reset()\n      */\n     public synchronized void reset()\n     {\n         count = 0;\n         filledBufferSum = 0;\n         currentBufferIndex = 0;\n         if ( reuseBuffers )\n         {\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Throw away old buffers\n             currentBuffer = null;\n             int size = buffers.get( 0 ).length;\n             buffers.clear();\n             needNewBuffer( size );\n             reuseBuffers = true;\n         }\n     }\n \n     /**\n      * Writes the entire contents of this byte stream to the\n      * specified output stream.\n      *\n      * @param out the output stream to write to\n      *\n      * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n      * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n      */\n     public synchronized void writeTo( final OutputStream out ) throws IOException\n     {\n         int remaining = count;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             out.write( buf, 0, c );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.0\n      */\n     public static InputStream toBufferedInputStream( final InputStream input )\n         throws IOException\n     {\n         return toBufferedInputStream( input, 1024 );\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      * @param size the initial buffer size\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.5\n      */\n     public static InputStream toBufferedInputStream( final InputStream input, int size )\n         throws IOException\n     {\n         // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n         @SuppressWarnings( \"resource\" )\n         final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n         output.write( input );\n         return output.toInputStream();\n     }\n \n     /**\n      * Gets the current contents of this byte stream as a Input Stream. The\n      * returned stream is backed by buffers of <code>this</code> stream,\n      * avoiding memory allocation and copy, thus saving space and time.<br>\n      *\n      * @return the current contents of this output stream.\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      * @see #reset()\n      * @since 2.5\n      */\n     public synchronized InputStream toInputStream()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n         return new SequenceInputStream( Collections.enumeration( list ) );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n     public synchronized byte[] toByteArray()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte newbuf[] = new byte[ remaining ];\n         int pos = 0;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             System.arraycopy( buf, 0, newbuf, pos, c );\n             pos += c;\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         return newbuf;\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the platform default charset.\n      *\n      * @return the contents of the byte array as a String\n      *\n      * @see java.io.ByteArrayOutputStream#toString()\n      * @deprecated 2.5 use {@link #toString(String)} instead\n      */\n     @Override\n     @Deprecated\n     public String toString()\n     {\n         // make explicit the use of the default charset\n         return new String( toByteArray(), Charset.defaultCharset() );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param enc the name of the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      */\n     public String toString( final String enc ) throws UnsupportedEncodingException\n     {\n         return new String( toByteArray(), enc );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param charset the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      * @since 2.5\n      */\n     public String toString( final Charset charset )\n     {\n         return new String( toByteArray(), charset );\n     }\n \n }\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n     extends AbstractUnArchiver\n {\n \n     private static final String NATIVE_ENCODING = \"native-encoding\";\n \n     private String encoding = \"UTF8\";\n \n     private long maxOutputSize = Long.MAX_VALUE;\n \n     public AbstractZipUnArchiver()\n     {\n     }\n \n     public AbstractZipUnArchiver( final File sourceFile )\n     {\n         super( sourceFile );\n     }\n \n     /**\n      * Sets the encoding to assume for file names and comments.\n      * <p>\n      * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n      * </p>\n      */\n     public void setEncoding( String encoding )\n     {\n         if ( NATIVE_ENCODING.equals( encoding ) )\n         {\n             encoding = null;\n         }\n         this.encoding = encoding;\n     }\n \n     /**\n      * Set maximum allowed size of the produced output.\n      *\n      * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n      *\n      * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n      * @throws IllegalArgumentException if specified output size is less or equal to 0\n      */\n     public void setMaxOutputSize( long maxOutputSize ) {\n         if ( maxOutputSize <= 0 ) {\n             throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n         }\n         this.maxOutputSize = maxOutputSize;\n     }\n \n     private static class ZipEntryFileInfo\n         implements PlexusIoResource\n     {\n \n         private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n \n         private final ZipArchiveEntry zipEntry;\n \n         ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                           final ZipArchiveEntry zipEntry )\n         {\n             this.zipFile = zipFile;\n             this.zipEntry = zipEntry;\n         }\n \n         public String getName()\n         {\n             return zipEntry.getName();\n         }\n \n         @Override\n         public boolean isDirectory()\n         {\n             return zipEntry.isDirectory();\n         }\n \n         @Override\n         public boolean isFile()\n         {\n             return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n         }\n \n         @Override\n         public boolean isSymbolicLink()\n        ",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 6520087963683741692
        },
        {
            "input": "```diff\n--- src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java\n@@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n /**\n  * This class implements an output stream in which the data is\n  * written into a byte array. The buffer automatically grows as data\n  * is written to it.\n  * <p>\n  * The data can be retrieved using <code>toByteArray()</code> and\n  * <code>toString()</code>.\n  * <p>\n  * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n  * this class can be called after the stream has been closed without\n  * generating an {@code IOException}.\n  * <p>\n  * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n  * class. The original implementation only allocates 32 bytes at the beginning.\n  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n  * to the original it doesn't reallocate the whole memory block but allocates\n  * additional buffers. This way no buffers need to be garbage collected and\n  * the contents don't have to be copied to the new buffer. This class is\n  * designed to behave exactly like the original. The only exception is the\n  * deprecated toString(int) method that has been ignored.\n  */\n public class ByteArrayOutputStream extends OutputStream\n {\n \n     /**\n      * A singleton empty byte array.\n      */\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n \n     /**\n      * The list of buffers, which grows and never reduces.\n      */\n     private final List<byte[]> buffers = new ArrayList<byte[]>();\n \n     /**\n      * The index of the current buffer.\n      */\n     private int currentBufferIndex;\n \n     /**\n      * The total count of bytes in all the filled buffers.\n      */\n     private int filledBufferSum;\n \n     /**\n      * The current buffer.\n      */\n     private byte[] currentBuffer;\n \n     /**\n      * The total count of bytes written.\n      */\n     private int count;\n \n     /**\n      * Flag to indicate if the buffers can be reused after reset\n      */\n     private boolean reuseBuffers = true;\n \n     /**\n      * Creates a new byte array output stream. The buffer capacity is\n      * initially 1024 bytes, though its size increases if necessary.\n      */\n     public ByteArrayOutputStream()\n     {\n         this( 1024 );\n     }\n \n     /**\n      * Creates a new byte array output stream, with a buffer capacity of\n      * the specified size, in bytes.\n      *\n      * @param size the initial size\n      *\n      * @throws IllegalArgumentException if size is negative\n      */\n     public ByteArrayOutputStream( final int size )\n     {\n         if ( size < 0 )\n         {\n             throw new IllegalArgumentException( \"Negative initial size: \" + size );\n         }\n         synchronized ( this )\n         {\n             needNewBuffer( size );\n         }\n     }\n \n     /**\n      * Makes a new buffer available either by allocating\n      * a new one or re-cycling an existing one.\n      *\n      * @param newcount the size of the buffer if one is created\n      */\n     private void needNewBuffer( final int newcount )\n     {\n         if ( currentBufferIndex < buffers.size() - 1 )\n         {\n             //Recycling old buffer\n             filledBufferSum += currentBuffer.length;\n \n             currentBufferIndex++;\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Creating new buffer\n             int newBufferSize;\n             if ( currentBuffer == null )\n             {\n                 newBufferSize = newcount;\n                 filledBufferSum = 0;\n             }\n             else\n             {\n                 newBufferSize = Math.max(\n                     currentBuffer.length << 1,\n                     newcount - filledBufferSum );\n                 filledBufferSum += currentBuffer.length;\n             }\n \n             currentBufferIndex++;\n             currentBuffer = new byte[ newBufferSize ];\n             buffers.add( currentBuffer );\n         }\n     }\n \n     /**\n      * Write the bytes to byte array.\n      *\n      * @param b the bytes to write\n      * @param off The start offset\n      * @param len The number of bytes to write\n      */\n     @Override\n     public void write( final byte[] b, final int off, final int len )\n     {\n         if ( ( off < 0 )\n                  || ( off > b.length )\n                  || ( len < 0 )\n                  || ( ( off + len ) > b.length )\n                  || ( ( off + len ) < 0 ) )\n         {\n             throw new IndexOutOfBoundsException();\n         }\n         else if ( len == 0 )\n         {\n             return;\n         }\n         synchronized ( this )\n         {\n             final int newcount = count + len;\n             int remaining = len;\n             int inBufferPos = count - filledBufferSum;\n             while ( remaining > 0 )\n             {\n                 final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                 System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                 remaining -= part;\n                 if ( remaining > 0 )\n                 {\n                     needNewBuffer( newcount );\n                     inBufferPos = 0;\n                 }\n             }\n             count = newcount;\n         }\n     }\n \n     /**\n      * Write a byte to byte array.\n      *\n      * @param b the byte to write\n      */\n     @Override\n     public synchronized void write( final int b )\n     {\n         int inBufferPos = count - filledBufferSum;\n         if ( inBufferPos == currentBuffer.length )\n         {\n             needNewBuffer( count + 1 );\n             inBufferPos = 0;\n         }\n         currentBuffer[inBufferPos] = (byte) b;\n         count++;\n     }\n \n     /**\n      * Writes the entire contents of the specified input stream to this\n      * byte stream. Bytes from the input stream are read directly into the\n      * internal buffers of this streams.\n      *\n      * @param in the input stream to read from\n      *\n      * @return total number of bytes read from the input stream\n      * (and written to this stream)\n      *\n      * @throws java.io.IOException if an I/O error occurs while reading the input stream\n      * @since 1.4\n      */\n     public synchronized int write( final InputStream in ) throws IOException\n     {\n         int readCount = 0;\n         int inBufferPos = count - filledBufferSum;\n         int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         while ( n != -1 )\n         {\n             readCount += n;\n             inBufferPos += n;\n             count += n;\n             if ( inBufferPos == currentBuffer.length )\n             {\n                 needNewBuffer( currentBuffer.length );\n                 inBufferPos = 0;\n             }\n             n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n         }\n         return readCount;\n     }\n \n     /**\n      * Return the current size of the byte array.\n      *\n      * @return the current size of the byte array\n      */\n     public synchronized int size()\n     {\n         return count;\n     }\n \n     /**\n      * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n      * this class can be called after the stream has been closed without\n      * generating an {@code IOException}.\n      *\n      * @throws java.io.IOException never (this method should not declare this exception\n      * but it has to now due to backwards compatibility)\n      */\n     @Override\n     public void close() throws IOException\n     {\n         //nop\n     }\n \n     /**\n      * @see java.io.ByteArrayOutputStream#reset()\n      */\n     public synchronized void reset()\n     {\n         count = 0;\n         filledBufferSum = 0;\n         currentBufferIndex = 0;\n         if ( reuseBuffers )\n         {\n             currentBuffer = buffers.get( currentBufferIndex );\n         }\n         else\n         {\n             //Throw away old buffers\n             currentBuffer = null;\n             int size = buffers.get( 0 ).length;\n             buffers.clear();\n             needNewBuffer( size );\n             reuseBuffers = true;\n         }\n     }\n \n     /**\n      * Writes the entire contents of this byte stream to the\n      * specified output stream.\n      *\n      * @param out the output stream to write to\n      *\n      * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n      * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n      */\n     public synchronized void writeTo( final OutputStream out ) throws IOException\n     {\n         int remaining = count;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             out.write( buf, 0, c );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.0\n      */\n     public static InputStream toBufferedInputStream( final InputStream input )\n         throws IOException\n     {\n         return toBufferedInputStream( input, 1024 );\n     }\n \n     /**\n      * Fetches entire contents of an <code>InputStream</code> and represent\n      * same data as result InputStream.\n      * <p>\n      * This method is useful where,\n      * <ul>\n      * <li>Source InputStream is slow.</li>\n      * <li>It has network resources associated, so we cannot keep it open for\n      * long time.</li>\n      * <li>It has network timeout associated.</li>\n      * </ul>\n      * It can be used in favor of {@link #toByteArray()}, since it\n      * avoids unnecessary allocation and copy of byte[].<br>\n      * This method buffers the input internally, so there is no need to use a\n      * <code>BufferedInputStream</code>.\n      *\n      * @param input Stream to be fully buffered.\n      * @param size the initial buffer size\n      *\n      * @return A fully buffered stream.\n      *\n      * @throws java.io.IOException if an I/O error occurs\n      * @since 2.5\n      */\n     public static InputStream toBufferedInputStream( final InputStream input, int size )\n         throws IOException\n     {\n         // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n         @SuppressWarnings( \"resource\" )\n         final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n         output.write( input );\n         return output.toInputStream();\n     }\n \n     /**\n      * Gets the current contents of this byte stream as a Input Stream. The\n      * returned stream is backed by buffers of <code>this</code> stream,\n      * avoiding memory allocation and copy, thus saving space and time.<br>\n      *\n      * @return the current contents of this output stream.\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      * @see #reset()\n      * @since 2.5\n      */\n     public synchronized InputStream toInputStream()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n-            return new ClosedInputStream();\n+            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n         }\n         final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             list.add( new ByteArrayInputStream( buf, 0, c ) );\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         reuseBuffers = false;\n         return new SequenceInputStream( Collections.enumeration( list ) );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a byte array.\n      * The result is independent of this stream.\n      *\n      * @return the current contents of this output stream, as a byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toByteArray()\n      */\n     public synchronized byte[] toByteArray()\n     {\n         int remaining = count;\n         if ( remaining == 0 )\n         {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte newbuf[] = new byte[ remaining ];\n         int pos = 0;\n         for ( final byte[] buf : buffers )\n         {\n             final int c = Math.min( buf.length, remaining );\n             System.arraycopy( buf, 0, newbuf, pos, c );\n             pos += c;\n             remaining -= c;\n             if ( remaining == 0 )\n             {\n                 break;\n             }\n         }\n         return newbuf;\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the platform default charset.\n      *\n      * @return the contents of the byte array as a String\n      *\n      * @see java.io.ByteArrayOutputStream#toString()\n      * @deprecated 2.5 use {@link #toString(String)} instead\n      */\n     @Override\n     @Deprecated\n     public String toString()\n     {\n         // make explicit the use of the default charset\n         return new String( toByteArray(), Charset.defaultCharset() );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param enc the name of the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      */\n     public String toString( final String enc ) throws UnsupportedEncodingException\n     {\n         return new String( toByteArray(), enc );\n     }\n \n     /**\n      * Gets the curent contents of this byte stream as a string\n      * using the specified encoding.\n      *\n      * @param charset the character encoding\n      *\n      * @return the string converted from the byte array\n      *\n      * @see java.io.ByteArrayOutputStream#toString(String)\n      * @since 2.5\n      */\n     public String toString( final Charset charset )\n     {\n         return new String( toByteArray(), charset );\n     }\n \n }\n--- src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n+++ src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java\n@@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Date;\n import java.util.Enumeration;\n import javax.annotation.Nonnull;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.io.input.CountingInputStream;\n import org.codehaus.plexus.archiver.AbstractUnArchiver;\n import org.codehaus.plexus.archiver.ArchiverException;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n \n /**\n  * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n  */\n public abstract class AbstractZipUnArchiver\n     extends AbstractUnArchiver\n {\n \n     private static final String NATIVE_ENCODING = \"native-encoding\";\n \n     private String encoding = \"UTF8\";\n \n     private long maxOutputSize = Long.MAX_VALUE;\n \n     public AbstractZipUnArchiver()\n     {\n     }\n \n     public AbstractZipUnArchiver( final File sourceFile )\n     {\n         super( sourceFile );\n     }\n \n     /**\n      * Sets the encoding to assume for file names and comments.\n      * <p>\n      * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n      * </p>\n      */\n     public void setEncoding( String encoding )\n     {\n         if ( NATIVE_ENCODING.equals( encoding ) )\n         {\n             encoding = null;\n         }\n         this.encoding = encoding;\n     }\n \n     /**\n      * Set maximum allowed size of the produced output.\n      *\n      * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n      *\n      * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n      * @throws IllegalArgumentException if specified output size is less or equal to 0\n      */\n     public void setMaxOutputSize( long maxOutputSize ) {\n         if ( maxOutputSize <= 0 ) {\n             throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n         }\n         this.maxOutputSize = maxOutputSize;\n     }\n \n     private static class ZipEntryFileInfo\n         implements PlexusIoResource\n     {\n \n         private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n \n         private final ZipArchiveEntry zipEntry;\n \n         ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                           final ZipArchiveEntry zipEntry )\n         {\n             this.zipFile = zipFile;\n             this.zipEntry = zipEntry;\n         }\n \n         public String getName()\n         {\n             return zipEntry.getName();\n         }\n \n         @Override\n         public boolean isDirectory()\n         {\n             return zipEntry.isDirectory();\n         }\n \n         @Override\n         public boolean isFile()\n         {\n             return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n         }\n \n         @Override\n         public boolean isSymbolicLink()\n        ",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "class, interface, or enum expected\n",
                "updated_files": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n-import org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n            return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n"
                },
                "compile_error_details": {
                    "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java": {
                        "215": {
                            "lines": [
                                {
                                    "line_no": 214,
                                    "content": "}"
                                },
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[215,1] class, interface, or enum expected\n"
                            ]
                        },
                        "216": {
                            "lines": [
                                {
                                    "line_no": 215,
                                    "content": "import java.io.File;"
                                },
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                }
                            ],
                            "error_texts": [
                                "[216,1] class, interface, or enum expected\n"
                            ]
                        },
                        "217": {
                            "lines": [
                                {
                                    "line_no": 216,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[217,1] class, interface, or enum expected\n"
                            ]
                        },
                        "218": {
                            "lines": [
                                {
                                    "line_no": 217,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[218,1] class, interface, or enum expected\n"
                            ]
                        },
                        "219": {
                            "lines": [
                                {
                                    "line_no": 218,
                                    "content": "import java.io.OutputStream;"
                                },
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[219,1] class, interface, or enum expected\n"
                            ]
                        },
                        "220": {
                            "lines": [
                                {
                                    "line_no": 219,
                                    "content": "import java.io.SequenceInputStream;"
                                },
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[220,1] class, interface, or enum expected\n"
                            ]
                        },
                        "221": {
                            "lines": [
                                {
                                    "line_no": 220,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 221,
                                    "content": "import org.apache.commons.io.output.ThresholdingOutputStream;"
                                },
                                {
                                    "line_no": 222,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[221,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java": {
                        "322": {
                            "lines": [
                                {
                                    "line_no": 321,
                                    "content": "}"
                                },
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                }
                            ],
                            "error_texts": [
                                "[322,1] class, interface, or enum expected\n"
                            ]
                        },
                        "323": {
                            "lines": [
                                {
                                    "line_no": 322,
                                    "content": "import java.io.PrintStream;"
                                },
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                }
                            ],
                            "error_texts": [
                                "[323,1] class, interface, or enum expected\n"
                            ]
                        },
                        "324": {
                            "lines": [
                                {
                                    "line_no": 323,
                                    "content": "import java.lang.reflect.Method;"
                                },
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                }
                            ],
                            "error_texts": [
                                "[324,1] class, interface, or enum expected\n"
                            ]
                        },
                        "325": {
                            "lines": [
                                {
                                    "line_no": 324,
                                    "content": "import java.nio.file.Files;"
                                },
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                }
                            ],
                            "error_texts": [
                                "[325,1] class, interface, or enum expected\n"
                            ]
                        },
                        "326": {
                            "lines": [
                                {
                                    "line_no": 325,
                                    "content": "import java.nio.file.Path;"
                                },
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                }
                            ],
                            "error_texts": [
                                "[326,1] class, interface, or enum expected\n"
                            ]
                        },
                        "327": {
                            "lines": [
                                {
                                    "line_no": 326,
                                    "content": "import java.nio.file.StandardCopyOption;"
                                },
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                }
                            ],
                            "error_texts": [
                                "[327,1] class, interface, or enum expected\n"
                            ]
                        },
                        "328": {
                            "lines": [
                                {
                                    "line_no": 327,
                                    "content": "import java.nio.file.attribute.FileTime;"
                                },
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                }
                            ],
                            "error_texts": [
                                "[328,1] class, interface, or enum expected\n"
                            ]
                        },
                        "329": {
                            "lines": [
                                {
                                    "line_no": 328,
                                    "content": "import java.util.ArrayList;"
                                },
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[329,1] class, interface, or enum expected\n"
                            ]
                        },
                        "330": {
                            "lines": [
                                {
                                    "line_no": 329,
                                    "content": "import java.util.Calendar;"
                                },
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                }
                            ],
                            "error_texts": [
                                "[330,1] class, interface, or enum expected\n"
                            ]
                        },
                        "331": {
                            "lines": [
                                {
                                    "line_no": 330,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                }
                            ],
                            "error_texts": [
                                "[331,1] class, interface, or enum expected\n"
                            ]
                        },
                        "332": {
                            "lines": [
                                {
                                    "line_no": 331,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                }
                            ],
                            "error_texts": [
                                "[332,1] class, interface, or enum expected\n"
                            ]
                        },
                        "333": {
                            "lines": [
                                {
                                    "line_no": 332,
                                    "content": "import java.util.Locale;"
                                },
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                }
                            ],
                            "error_texts": [
                                "[333,1] class, interface, or enum expected\n"
                            ]
                        },
                        "334": {
                            "lines": [
                                {
                                    "line_no": 333,
                                    "content": "import java.util.TimeZone;"
                                },
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                }
                            ],
                            "error_texts": [
                                "[334,1] class, interface, or enum expected\n"
                            ]
                        },
                        "335": {
                            "lines": [
                                {
                                    "line_no": 334,
                                    "content": "import java.util.regex.Pattern;"
                                },
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[335,1] class, interface, or enum expected\n"
                            ]
                        },
                        "336": {
                            "lines": [
                                {
                                    "line_no": 335,
                                    "content": "import java.util.zip.ZipEntry;"
                                },
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                }
                            ],
                            "error_texts": [
                                "[336,1] class, interface, or enum expected\n"
                            ]
                        },
                        "337": {
                            "lines": [
                                {
                                    "line_no": 336,
                                    "content": "import java.util.zip.ZipFile;"
                                },
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[337,1] class, interface, or enum expected\n"
                            ]
                        },
                        "338": {
                            "lines": [
                                {
                                    "line_no": 337,
                                    "content": "import java.util.zip.ZipOutputStream;"
                                },
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                }
                            ],
                            "error_texts": [
                                "[338,1] class, interface, or enum expected\n"
                            ]
                        },
                        "339": {
                            "lines": [
                                {
                                    "line_no": 338,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                }
                            ],
                            "error_texts": [
                                "[339,1] class, interface, or enum expected\n"
                            ]
                        },
                        "340": {
                            "lines": [
                                {
                                    "line_no": 339,
                                    "content": "import org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;"
                                },
                                {
                                    "line_no": 340,
                                    "content": "import org.codehaus.plexus.util.IOUtil;"
                                },
                                {
                                    "line_no": 341,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[340,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java": {
                        "203": {
                            "lines": [
                                {
                                    "line_no": 202,
                                    "content": "                    {"
                                },
                                {
                                    "line_no": 203,
                                    "content": "-                                BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );"
                                },
                                {
                                    "line_no": 204,
                                    "content": "                        CountingInputStream cis = new CountingInputStream( bis );"
                                }
                            ],
                            "error_texts": [
                                "[203,52] ';' expected\n",
                                "[203,1] not a statement\n"
                            ]
                        },
                        "227": {
                            "lines": [
                                {
                                    "line_no": 226,
                                    "content": "}"
                                },
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                }
                            ],
                            "error_texts": [
                                "[227,1] class, interface, or enum expected\n"
                            ]
                        },
                        "228": {
                            "lines": [
                                {
                                    "line_no": 227,
                                    "content": "import java.io.InputStream;"
                                },
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                }
                            ],
                            "error_texts": [
                                "[228,1] class, interface, or enum expected\n"
                            ]
                        },
                        "229": {
                            "lines": [
                                {
                                    "line_no": 228,
                                    "content": "import java.io.IOException;"
                                },
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                }
                            ],
                            "error_texts": [
                                "[229,1] class, interface, or enum expected\n"
                            ]
                        },
                        "230": {
                            "lines": [
                                {
                                    "line_no": 229,
                                    "content": "import java.util.Enumeration;"
                                },
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                }
                            ],
                            "error_texts": [
                                "[230,1] class, interface, or enum expected\n"
                            ]
                        },
                        "231": {
                            "lines": [
                                {
                                    "line_no": 230,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;"
                                },
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                }
                            ],
                            "error_texts": [
                                "[231,1] class, interface, or enum expected\n"
                            ]
                        },
                        "232": {
                            "lines": [
                                {
                                    "line_no": 231,
                                    "content": "import org.apache.commons.compress.archivers.zip.ZipFile;"
                                },
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                }
                            ],
                            "error_texts": [
                                "[232,1] class, interface, or enum expected\n"
                            ]
                        },
                        "233": {
                            "lines": [
                                {
                                    "line_no": 232,
                                    "content": "import org.apache.commons.io.input.CountingInputStream;"
                                },
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                }
                            ],
                            "error_texts": [
                                "[233,1] class, interface, or enum expected\n"
                            ]
                        },
                        "234": {
                            "lines": [
                                {
                                    "line_no": 233,
                                    "content": "import org.codehaus.plexus.archiver.AbstractUnArchiver;"
                                },
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                }
                            ],
                            "error_texts": [
                                "[234,1] class, interface, or enum expected\n"
                            ]
                        },
                        "235": {
                            "lines": [
                                {
                                    "line_no": 234,
                                    "content": "import org.codehaus.plexus.archiver.ArchiverException;"
                                },
                                {
                                    "line_no": 235,
                                    "content": "import org.codehaus.plexus.components.io.resources.PlexusIoResource;"
                                },
                                {
                                    "line_no": 236,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[235,1] class, interface, or enum expected\n"
                            ]
                        }
                    },
                    "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java": {
                        "29": {
                            "lines": [
                                {
                                    "line_no": 28,
                                    "content": "import java.util.List;"
                                },
                                {
                                    "line_no": 29,
                                    "content": "-import org.apache.commons.io.input.ClosedInputStream;"
                                },
                                {
                                    "line_no": 30,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[29,1] class, interface, or enum expected\n"
                            ]
                        }
                    }
                }
            },
            "error": "class, interface, or enum expected\n",
            "span_id": 375098590432604660
        }
    ],
    "read_file": [
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java",
            "output": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ClosedInputStream();\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
            "error": "",
            "span_id": 15037639241384813178
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/jar/JarToolModularJarArchiver.java",
            "output": "/**\n *\n * Copyright 2018 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.jar;\n\nimport javax.inject.Named;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.FileTime;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.compress.parallel.InputStreamSupplier;\nimport org.apache.commons.io.output.NullPrintStream;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.archiver.zip.ConcurrentJarCreator;\nimport org.codehaus.plexus.util.IOUtil;\n\n/**\n * A {@link ModularJarArchiver} implementation that uses\n * the {@code jar} tool provided by\n * {@code java.util.spi.ToolProvider} to create\n * modular JAR files.\n *\n * <p>\n * The basic JAR archive is created by {@link JarArchiver}\n * and the {@code jar} tool is used to upgrade it to modular JAR.\n *\n * <p>\n * If the JAR file does not contain module descriptor\n * or the JDK does not provide the {@code jar} tool\n * (for example JDK prior to Java 9), then the\n * archive created by {@link JarArchiver}\n * is left unchanged.\n */\n@Named( \"mjar\" )\npublic class JarToolModularJarArchiver\n    extends ModularJarArchiver\n{\n    private static final String MODULE_DESCRIPTOR_FILE_NAME\n        = \"module-info.class\";\n\n    private static final Pattern MRJAR_VERSION_AREA\n        = Pattern.compile( \"META-INF/versions/\\\\d+/\" );\n\n    private Object jarTool;\n\n    private boolean moduleDescriptorFound;\n\n    private boolean hasJarDateOption;\n\n    public JarToolModularJarArchiver()\n    {\n        try\n        {\n            Class<?> toolProviderClass =\n                Class.forName( \"java.util.spi.ToolProvider\" );\n            Object jarToolOptional = toolProviderClass\n                .getMethod( \"findFirst\", String.class )\n                .invoke( null, \"jar\" );\n\n            jarTool = jarToolOptional.getClass().getMethod( \"get\" )\n                .invoke( jarToolOptional );\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            // Ignore. It is expected that the jar tool\n            // may not be available.\n        }\n    }\n\n    @Override\n    protected void zipFile( InputStreamSupplier is, ConcurrentJarCreator zOut,\n                            String vPath, long lastModified, File fromArchive,\n                            int mode, String symlinkDestination,\n                            boolean addInParallel )\n        throws IOException, ArchiverException\n    {\n        if ( jarTool != null && isModuleDescriptor( vPath ) )\n        {\n            getLogger().debug( \"Module descriptor found: \" + vPath );\n\n            moduleDescriptorFound = true;\n        }\n\n        super.zipFile( is, zOut, vPath, lastModified,\n            fromArchive, mode, symlinkDestination, addInParallel );\n    }\n\n    @Override\n    protected void postCreateArchive()\n        throws ArchiverException\n    {\n        if ( !moduleDescriptorFound )\n        {\n            // no need to update the JAR archive\n            return;\n        }\n\n        try\n        {\n            getLogger().debug( \"Using the jar tool to \" +\n                \"update the archive to modular JAR.\" );\n\n            final Method jarRun = jarTool.getClass()\n                .getMethod( \"run\", PrintStream.class, PrintStream.class, String[].class );\n\n            if ( getLastModifiedTime() != null )\n            {\n                hasJarDateOption = isJarDateOptionSupported( jarRun );\n                getLogger().debug( \"jar tool --date option is supported: \" + hasJarDateOption );\n            }\n\n            Integer result = (Integer) jarRun.invoke( jarTool, System.out, System.err, getJarToolArguments() );\n\n            if ( result != null && result != 0 )\n            {\n                throw new ArchiverException( \"Could not create modular JAR file. \" +\n                    \"The JDK jar tool exited with \" + result );\n            }\n\n            if ( !hasJarDateOption && getLastModifiedTime() != null )\n            {\n                getLogger().debug( \"Fix last modified time zip entries.\" );\n                // --date option not supported, fallback to rewrite the JAR file\n                // https://github.com/codehaus-plexus/plexus-archiver/issues/164\n                fixLastModifiedTimeZipEntries();\n            }\n        }\n        catch ( IOException | ReflectiveOperationException | SecurityException e )\n        {\n            throw new ArchiverException( \"Exception occurred \" +\n                \"while creating modular JAR file\", e );\n        }\n    }\n\n    /**\n     * Fallback to rewrite the JAR file with the correct timestamp if the {@code --date} option is not available.\n     */\n    private void fixLastModifiedTimeZipEntries()\n        throws IOException\n    {\n        long timeMillis = getLastModifiedTime().toMillis();\n        Path destFile = getDestFile().toPath();\n        Path tmpZip = Files.createTempFile( destFile.getParent(), null, null );\n        try ( ZipFile zipFile = new ZipFile( getDestFile() );\n              ZipOutputStream out = new ZipOutputStream( Files.newOutputStream( tmpZip ) ) )\n        {\n            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n            while ( entries.hasMoreElements() )\n            {\n                ZipEntry entry = entries.nextElement();\n                // Not using setLastModifiedTime(FileTime) as it sets the extended timestamp\n                // which is not compatible with the jar tool output.\n                entry.setTime( timeMillis );\n                out.putNextEntry( entry );\n                if ( !entry.isDirectory() )\n                {\n                    IOUtil.copy( zipFile.getInputStream( entry ), out );\n                }\n                out.closeEntry();\n            }\n        }\n        Files.move( tmpZip, destFile, StandardCopyOption.REPLACE_EXISTING );\n    }\n\n    /**\n     * Returns {@code true} if {@code path}\n     * is a module descriptor.\n     */\n    private boolean isModuleDescriptor( String path )\n    {\n        if ( path.endsWith( MODULE_DESCRIPTOR_FILE_NAME ) )\n        {\n            String prefix = path.substring( 0,\n                path.lastIndexOf( MODULE_DESCRIPTOR_FILE_NAME ) );\n\n            // the path is a module descriptor if it located\n            // into the root of the archive or into the\n            // version area of a multi-release JAR file\n            return prefix.isEmpty() ||\n                MRJAR_VERSION_AREA.matcher( prefix ).matches();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Prepares the arguments for the jar tool.\n     * It takes into account the module version,\n     * main class, etc.\n     */\n    private String[] getJarToolArguments()\n        throws IOException\n    {\n        // We add empty temporary directory to the JAR file.\n        // It may look strange at first, but to update a JAR file\n        // you need to add new files[1]. If we add empty directory\n        // it will be ignored (not added to the archive), but\n        // the module descriptor will be updated and validated.\n        //\n        // [1] There are some exceptions (such as when the main class\n        // is updated) but we need at least empty directory\n        // to ensure it will work in all cases.\n        File tempEmptyDir = Files.createTempDirectory( null ).toFile();\n        tempEmptyDir.deleteOnExit();\n\n        List<String> args = new ArrayList<>();\n\n        args.add( \"--update\" );\n        args.add( \"--file\" );\n        args.add( getDestFile().getAbsolutePath() );\n\n        String mainClass = getModuleMainClass() != null\n                           ? getModuleMainClass()\n                           : getManifestMainClass();\n\n        if ( mainClass != null )\n        {\n            args.add( \"--main-class\" );\n            args.add( mainClass );\n        }\n\n        if ( getModuleVersion() != null )\n        {\n            args.add( \"--module-version\" );\n            args.add( getModuleVersion() );\n        }\n\n        if ( !isCompress() )\n        {\n            args.add( \"--no-compress\" );\n        }\n\n        if ( hasJarDateOption )\n        {\n            // The --date option already normalize the time, so revert to the local time\n            FileTime localTime = revertToLocalTime( getLastModifiedTime() );\n            args.add( \"--date\" );\n            args.add( localTime.toString() );\n        }\n\n        args.add( \"-C\" );\n        args.add( tempEmptyDir.getAbsolutePath() );\n        args.add( \".\" );\n\n        return args.toArray( new String[0] );\n    }\n\n    private static FileTime revertToLocalTime( FileTime time )\n    {\n        long restoreToLocalTime = time.toMillis();\n        Calendar cal = Calendar.getInstance( TimeZone.getDefault(), Locale.ROOT );\n        cal.setTimeInMillis( restoreToLocalTime );\n        restoreToLocalTime = restoreToLocalTime + ( cal.get( Calendar.ZONE_OFFSET ) + cal.get( Calendar.DST_OFFSET ) );\n        return FileTime.fromMillis( restoreToLocalTime );\n    }\n\n    /**\n     * Check support for {@code --date} option introduced since Java 17.0.3 (JDK-8279925).\n     *\n     * @return true if the JAR tool supports the {@code --date} option\n     */\n    private boolean isJarDateOptionSupported( Method runMethod )\n    {\n        try\n        {\n            // Test the output code validating the --date option.\n            String[] args = { \"--date\", \"2099-12-31T23:59:59Z\", \"--version\" };\n\n            PrintStream nullPrintStream = NullPrintStream.NULL_PRINT_STREAM;\n            Integer result = (Integer) runMethod.invoke( jarTool, nullPrintStream, nullPrintStream, args );\n\n            return result != null && result.intValue() == 0;\n        }\n        catch ( ReflectiveOperationException | SecurityException e )\n        {\n            return false;\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 11544243562199732289
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/OffloadingOutputStream.java",
            "output": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.file.Files;\n\nimport org.apache.commons.io.output.ThresholdingOutputStream;\n\n/**\n * Offloads to disk when a given memory consumption has been reacehd\n */\nclass OffloadingOutputStream extends ThresholdingOutputStream\n{\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The output stream to which data will be written prior to the theshold\n     * being reached.\n     */\n    private ByteArrayOutputStream memoryOutputStream;\n\n    /**\n     * The output stream to which data will be written at any given time. This\n     * will always be one of <code>memoryOutputStream</code> or\n     * <code>diskOutputStream</code>.\n     */\n    private OutputStream currentOutputStream;\n\n    /**\n     * The file to which output will be directed if the threshold is exceeded.\n     */\n    private File outputFile = null;\n\n    /**\n     * The temporary file prefix.\n     */\n    private final String prefix;\n\n    /**\n     * The temporary file suffix.\n     */\n    private final String suffix;\n\n    /**\n     * The directory to use for temporary files.\n     */\n    private final File directory;\n\n    /**\n     * True when close() has been called successfully.\n     */\n    private boolean closed = false;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data to a temporary file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     *\n     * @since 1.4\n     */\n    public OffloadingOutputStream( int threshold, String prefix, String suffix, File directory )\n    {\n        this( threshold, null, prefix, suffix, directory );\n        if ( prefix == null )\n        {\n            throw new IllegalArgumentException( \"Temporary file prefix is missing\" );\n        }\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold, and save data either to a file beyond that point.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param outputFile The file to which data is saved beyond the threshold.\n     * @param prefix Prefix to use for the temporary file.\n     * @param suffix Suffix to use for the temporary file.\n     * @param directory Temporary file directory.\n     */\n    private OffloadingOutputStream( int threshold, File outputFile, String prefix, String suffix, File directory )\n    {\n        super( threshold );\n        this.outputFile = outputFile;\n\n        memoryOutputStream = new ByteArrayOutputStream( threshold / 10 );\n        currentOutputStream = memoryOutputStream;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.directory = directory;\n    }\n\n    // --------------------------------------- ThresholdingOutputStream methods\n\n    /**\n     * Returns the current output stream. This may be memory based or disk\n     * based, depending on the current state with respect to the threshold.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected OutputStream getStream() throws IOException\n    {\n        return currentOutputStream;\n    }\n\n    /**\n     * Switches the underlying output stream from a memory based stream to one\n     * that is backed by disk. This is the point at which we realise that too\n     * much data is being written to keep in memory, so we elect to switch to\n     * disk-based storage.\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    protected void thresholdReached() throws IOException\n    {\n        if ( prefix != null )\n        {\n            outputFile = File.createTempFile( prefix, suffix, directory );\n        }\n        currentOutputStream = Files.newOutputStream( outputFile.toPath() );\n    }\n\n    public InputStream getInputStream() throws IOException\n    {\n\n        InputStream memoryAsInput = memoryOutputStream.toInputStream();\n        if ( outputFile == null )\n        {\n            return memoryAsInput;\n        }\n        return new SequenceInputStream( memoryAsInput, Files.newInputStream( outputFile.toPath() ) );\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the data for this output stream as an array of bytes, assuming\n     * that the data has been retained in memory. If the data was written to\n     * disk, this method returns <code>null</code>.\n     *\n     * @return The data for this output stream, or <code>null</code> if no such\n     * data is available.\n     */\n    public byte[] getData()\n    {\n        if ( memoryOutputStream != null )\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }\n\n    /**\n     * Returns either the output file specified in the constructor or\n     * the temporary file created or null.\n     * <p>\n     * If the constructor specifying the file is used then it returns that\n     * same output file, even when threshold has not been reached.\n     * <p>\n     * If constructor specifying a temporary file prefix/suffix is used\n     * then the temporary file created once the threshold is reached is returned\n     * If the threshold was not reached then <code>null</code> is returned.\n     *\n     * @return The file for this output stream, or <code>null</code> if no such\n     * file exists.\n     */\n    public File getFile()\n    {\n        return outputFile;\n    }\n\n    /**\n     * Closes underlying output stream, and mark this as closed\n     *\n     * @exception java.io.IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        closed = true;\n        currentOutputStream.close();\n    }\n\n}\n",
            "error": "",
            "span_id": 4164734819229168505
        },
        {
            "input": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
            "output": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport javax.annotation.Nonnull;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.BoundedInputStream;\nimport org.apache.commons.io.input.CountingInputStream;\nimport org.codehaus.plexus.archiver.AbstractUnArchiver;\nimport org.codehaus.plexus.archiver.ArchiverException;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n */\npublic abstract class AbstractZipUnArchiver\n    extends AbstractUnArchiver\n{\n\n    private static final String NATIVE_ENCODING = \"native-encoding\";\n\n    private String encoding = \"UTF8\";\n\n    private long maxOutputSize = Long.MAX_VALUE;\n\n    public AbstractZipUnArchiver()\n    {\n    }\n\n    public AbstractZipUnArchiver( final File sourceFile )\n    {\n        super( sourceFile );\n    }\n\n    /**\n     * Sets the encoding to assume for file names and comments.\n     * <p>\n     * Set to <code>native-encoding</code> if you want your platform's native encoding, defaults to UTF8.\n     * </p>\n     */\n    public void setEncoding( String encoding )\n    {\n        if ( NATIVE_ENCODING.equals( encoding ) )\n        {\n            encoding = null;\n        }\n        this.encoding = encoding;\n    }\n\n    /**\n     * Set maximum allowed size of the produced output.\n     *\n     * It may be used as a protection against <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">zip bombs</a>.\n     *\n     * @param maxOutputSize max size of the produced output, in bytes. Must be greater than 0\n     * @throws IllegalArgumentException if specified output size is less or equal to 0\n     */\n    public void setMaxOutputSize( long maxOutputSize ) {\n        if ( maxOutputSize <= 0 ) {\n            throw new IllegalArgumentException( \"Invalid max output size specified: \" + maxOutputSize );\n        }\n        this.maxOutputSize = maxOutputSize;\n    }\n\n    private static class ZipEntryFileInfo\n        implements PlexusIoResource\n    {\n\n        private final org.apache.commons.compress.archivers.zip.ZipFile zipFile;\n\n        private final ZipArchiveEntry zipEntry;\n\n        ZipEntryFileInfo( final org.apache.commons.compress.archivers.zip.ZipFile zipFile,\n                          final ZipArchiveEntry zipEntry )\n        {\n            this.zipFile = zipFile;\n            this.zipEntry = zipEntry;\n        }\n\n        public String getName()\n        {\n            return zipEntry.getName();\n        }\n\n        @Override\n        public boolean isDirectory()\n        {\n            return zipEntry.isDirectory();\n        }\n\n        @Override\n        public boolean isFile()\n        {\n            return !zipEntry.isDirectory() && !zipEntry.isUnixSymlink();\n        }\n\n        @Override\n        public boolean isSymbolicLink()\n        {\n            return zipEntry.isUnixSymlink();\n        }\n\n        @Nonnull\n        @Override\n        public InputStream getContents()\n            throws IOException\n        {\n            return zipFile.getInputStream( zipEntry );\n        }\n\n        @Override\n        public long getLastModified()\n        {\n            final long l = zipEntry.getTime();\n            return l == 0 ? PlexusIoResource.UNKNOWN_MODIFICATION_DATE : l;\n        }\n\n        @Override\n        public long getSize()\n        {\n            final long l = zipEntry.getSize();\n            return l == -1 ? PlexusIoResource.UNKNOWN_RESOURCE_SIZE : l;\n        }\n\n        @Override\n        public URL getURL()\n            throws IOException\n        {\n            return null;\n        }\n\n        @Override\n        public boolean isExisting()\n        {\n            return true;\n        }\n\n    }\n\n    @Override\n    protected void execute()\n        throws ArchiverException\n    {\n        execute( \"\", getDestDirectory() );\n    }\n\n    private String resolveSymlink( ZipFile zf, ZipArchiveEntry ze )\n        throws IOException\n    {\n        if ( ze.isUnixSymlink() )\n        {\n            return zf.getUnixSymlink( ze );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    protected void execute( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        getLogger().debug( \"Expanding: \" + getSourceFile() + \" into \" + outputDirectory );\n        try ( ZipFile zipFile = new ZipFile( getSourceFile(), encoding, true ) )\n        {\n            long remainingSpace = maxOutputSize;\n            final Enumeration<ZipArchiveEntry> e = zipFile.getEntriesInPhysicalOrder();\n\n            while ( e.hasMoreElements() )\n            {\n                final ZipArchiveEntry ze = e.nextElement();\n                final ZipEntryFileInfo fileInfo = new ZipEntryFileInfo( zipFile, ze );\n                if ( !isSelected( ze.getName(), fileInfo ) )\n                {\n                    continue;\n                }\n\n                if ( ze.getName().startsWith( path ) )\n                {\n                    try ( InputStream in = zipFile.getInputStream( ze ) )\n                    {\n                        BoundedInputStream bis = new BoundedInputStream( in, remainingSpace + 1 );\n                        CountingInputStream cis = new CountingInputStream( bis );\n                        extractFile( getSourceFile(), outputDirectory, cis,\n                                     ze.getName(), new Date( ze.getTime() ), ze.isDirectory(),\n                                     ze.getUnixMode() != 0 ? ze.getUnixMode() : null,\n                                     resolveSymlink( zipFile, ze ), getFileMappers() );\n\n                        remainingSpace -= cis.getByteCount();\n                        if ( remainingSpace < 0 )\n                        {\n                            throw new ArchiverException( \"Maximum output size limit reached\" );\n                        }\n                    }\n                }\n            }\n            getLogger().debug( \"expand complete\" );\n        }\n        catch ( final IOException ioe )\n        {\n            throw new ArchiverException( \"Error while expanding \" + getSourceFile().getAbsolutePath(), ioe );\n        }\n    }\n\n}\n",
            "error": "",
            "span_id": 5387817121336193150
        }
    ],
    "get_directory_tree": [
        {
            "input": "src/main/java/org/codehaus/plexus/archiver",
            "output": "[\n    {\n        \"name\": \"ArchiveFinalizer.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"swc\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"PlexusIoSwcFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"SwcUnArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"AbstractArchiver.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"UnixStat.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"resources\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"PlexusIoVirtualSymlinkResource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoVirtualFileResource.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"ResourceIterator.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ArchiveFilterException.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"filters\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"JarSecurityFileFilter.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"JarSecurityFileSelector.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"zstd\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"ZstdUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZstdCompressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoZstdResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZstdArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"xz\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"XZUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoXZResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"XZCompressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"XZArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"FileSet.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"sar\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"PlexusIoSarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"SarUnArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"war\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"WarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoWarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"WarArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"BaseFileSet.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ear\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"PlexusIoEarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"EarArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"EarUnArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"manager\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"DefaultArchiverManager.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ArchiverManager.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"NoSuchArchiverException.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"ArchiverException.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"car\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"CarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoCarFileResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"esb\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"EsbUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoEsbFileResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"snappy\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"SnappyArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"SnappyCompressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"SnappyUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoSnappyResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"rar\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"RarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoRarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"RarArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"gzip\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"GZipArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoGzipResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoGzResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"GZipCompressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"GZipUnArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"nar\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"NarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoNarFileResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"ArchiveFileFilter.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"DotDirectiveArchiveFinalizer.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"par\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"ParUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoJarFileResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"diags\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"DryRunArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"NoOpArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DelgatingArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TrackingArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"AbstractUnArchiver.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"dir\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"DirectoryArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"ArchiveFile.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"exceptions\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"EmptyArchiveException.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"FinalizerEnabled.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ArchiveEntry.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"jar\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"JdkManifestFactory.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ModularJarArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ManifestConstants.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"JarToolModularJarArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"JarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"JarArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Manifest.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoJarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ManifestException.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"UnArchiver.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"util\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"FilePermission.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ArchiveEntryUtils.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Streams.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DefaultArchivedFileSet.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ResourceUtils.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AbstractFileSet.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"FilePermissionUtils.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"FilterSupport.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"Compressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DefaultFileSet.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"Archiver.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"ArchivedFileSet.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"tar\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"PlexusIoTBZ2FileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarBZip2FileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarGZipFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarZstdFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTXZFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TBZ2UnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarGZipUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarLongFileMode.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"XZTarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarXZUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZstdTarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarSnappyFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"SnappyTarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarXZFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarSnappyUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"GZipTarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarBZip2UnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarSymlinkResource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTGZFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarZstdUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TarResource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoTarFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TGZUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"BZip2TarFile.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"TXZUnArchiver.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"AbstractArchiveFinalizer.java\",\n        \"type\": \"file\"\n    },\n    {\n        \"name\": \"zip\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"ByteArrayOutputStream.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AddedDirs.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AbstractZipUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZipResource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"DeferredScatterOutputStream.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZipUnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ConcurrentJarCreator.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"OffloadingOutputStream.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AbstractZipArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZipArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoZipFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"AnonymousResource.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusArchiverZipFileResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"ZipSymlinkResource.java\",\n                \"type\": \"file\"\n            }\n        ]\n    },\n    {\n        \"name\": \"bzip2\",\n        \"type\": \"directory\",\n        \"contents\": [\n            {\n                \"name\": \"BZip2Archiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"BZip2Compressor.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoBzip2ResourceCollection.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"BZip2UnArchiver.java\",\n                \"type\": \"file\"\n            },\n            {\n                \"name\": \"PlexusIoBz2ResourceCollection.java\",\n                \"type\": \"file\"\n            }\n        ]\n    }\n]",
            "error": "",
            "span_id": 14546366882615529868
        }
    ],
    "get_language_server_suggestions": [],
    "reset_repo": []
}