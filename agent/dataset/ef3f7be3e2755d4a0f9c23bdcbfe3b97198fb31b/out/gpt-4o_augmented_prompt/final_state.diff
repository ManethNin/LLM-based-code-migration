diff --git a/src/main/java/micycle/pgs/PGS_CirclePacking.java b/src/main/java/micycle/pgs/PGS_CirclePacking.java
index a344e8f..67a677a 100644
--- a/src/main/java/micycle/pgs/PGS_CirclePacking.java
+++ b/src/main/java/micycle/pgs/PGS_CirclePacking.java
@@ -220,12 +220,12 @@ public final class PGS_CirclePacking {
 		 * "To find the circle nearest to a center (x, y), do a proximity search at (x,
 		 * y, R), where R is greater than or equal to the maximum radius of a circle."
 		 */
-		float largestR = 0; // the radius of the largest circle in the tree
-
-		for (PVector p : steinerPoints) {
-			final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
-
-			/*
+-			final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
+-			if (nn != null && nn.dist() > minRadius) {
+-				/* 
++			final CoverTree.QueryKNN<PVector> nn = tree.queryKNN(new double[] { p.x, p.y, largestR }, 1); // find nearest-neighbour circle
++			if (nn.hasNext() && nn.next().dist() > minRadius) {
++				/*
 			 * nn.dist() does not return the radius (since it's a distance metric used to
 			 * find nearest circle), so calculate maximum radius for candidate circle using
 			 * 2d euclidean distance between center points minus radius of nearest circle.
@@ -642,7 +642,8 @@ public final class PGS_CirclePacking {
 	 * @param p2 3D point representing the second circle (x2, y2, r2)
 	 * @return the distance between the two points based on the custom metric
 	 */
-	private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
+-	private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
++	private static final CoverTree.DistanceFunction circleDistanceMetric = (p1, p2) -> {
 		// from https://stackoverflow.com/a/21975136/
 		final double dx = p1[0] - p2[0];
 		final double dy = p1[1] - p2[1];
diff --git a/src/main/java/micycle/pgs/PGS_Meshing.java b/src/main/java/micycle/pgs/PGS_Meshing.java
index 918b867..4b639c7 100644
--- a/src/main/java/micycle/pgs/PGS_Meshing.java
+++ b/src/main/java/micycle/pgs/PGS_Meshing.java
@@ -168,7 +168,9 @@ public class PGS_Meshing {
 		final HashSet<IQuadEdge> nonGabrielEdges = new HashSet<>(); // base references to edges that should be removed
 		edges.forEach(edge -> {
 			final double[] midpoint = midpoint(edge);
-			final Vertex near = tree.query1NN(midpoint).value();
+			final Vertex near = tree.queryKNN(midpoint, 1).next().value();
+			final Vertex near = tree.queryKNN(midpoint, 1).next().value();
+			final Vertex near = tree.queryKNN(midpoint, 1).next().value();
 			if (near != edge.getA() && near != edge.getB()) {
 				if (!preservePerimeter || (preservePerimeter && !edge.isConstrainedRegionBorder())) {
 					nonGabrielEdges.add(edge); // base reference
diff --git a/src/main/java/micycle/pgs/PGS_PointSet.java b/src/main/java/micycle/pgs/PGS_PointSet.java
index f27ac27..e4ae049 100644
--- a/src/main/java/micycle/pgs/PGS_PointSet.java
+++ b/src/main/java/micycle/pgs/PGS_PointSet.java
@@ -67,7 +67,9 @@ public final class PGS_PointSet {
 		final List<PVector> newPoints = new ArrayList<>();
 		for (PVector p : points) {
 			final double[] coords = new double[] { p.x, p.y };
-			if (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {
+			if (tree.size() == 0 || !tree.queryKNN(coords, 1).hasNext() || tree.queryKNN(coords, 1).next().dist() > distanceTolerance) {
+			if (tree.size() == 0 || !tree.queryKNN(coords, 1).hasNext() || tree.queryKNN(coords, 1).next().dist() > distanceTolerance) {
+			if (tree.size() == 0 || !tree.queryKNN(coords, 1).hasNext() || tree.queryKNN(coords, 1).next().dist() > distanceTolerance) {
 				tree.insert(coords, p);
 				newPoints.add(p);
 			}