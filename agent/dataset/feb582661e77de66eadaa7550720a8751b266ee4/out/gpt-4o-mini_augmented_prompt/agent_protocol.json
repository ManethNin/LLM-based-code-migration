{
    "validate_diffs": [],
    "compile_maven": [
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -1,12 +1,12 @@\n package liquibase.ext.mssql.sqlgenerator;\n \n import liquibase.change.AddColumnConfig;\n import liquibase.database.Database;\n import liquibase.ext.mssql.database.MSSQLDatabase;\n import liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\n import liquibase.sql.Sql;\n import liquibase.sql.UnparsedSql;\n-import liquibase.util.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n@@ -76,7 +76,7 @@\n     if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n-    \n+\n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -1,12 +1,12 @@\n package liquibase.ext.mssql.sqlgenerator;\n \n import liquibase.database.Database;\n import liquibase.ext.mssql.database.MSSQLDatabase;\n import liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\n import liquibase.sql.Sql;\n import liquibase.sql.UnparsedSql;\n import liquibase.sqlgenerator.SqlGeneratorChain;\n import liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\n import liquibase.statement.core.AddPrimaryKeyStatement;\n import liquibase.structure.core.Index;\n-import liquibase.util.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n@@ -66,7 +66,7 @@\n     if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n       sql += \" ON \"+statement.getTablespace();\n     }\n \n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService;\n+import liquibase.executor.ExecutorService; \n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -7,7 +7,7 @@\n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n+        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "cannot find symbol\n",
                "updated_files": {
                    "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
                    "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
                    "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}"
                },
                "compile_error_details": {
                    "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java": {
                        "12": {
                            "lines": [
                                {
                                    "line_no": 11,
                                    "content": "import liquibase.structure.core.Index;"
                                },
                                {
                                    "line_no": 12,
                                    "content": "import org.apache.commons.lang3.StringUtils;"
                                },
                                {
                                    "line_no": 13,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[12,32] package org.apache.commons.lang3 does not exist\n"
                            ]
                        },
                        "67": {
                            "lines": [
                                {
                                    "line_no": 66,
                                    "content": ""
                                },
                                {
                                    "line_no": 67,
                                    "content": "    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {"
                                },
                                {
                                    "line_no": 68,
                                    "content": "      sql += \" ON \"+statement.getTablespace();"
                                }
                            ],
                            "error_texts": [
                                "[67,9] cannot find symbol\nsymbol: variable StringUtils\nlocation: class liquibase.ext.mssql.sqlgenerator.AddPrimaryKeyGeneratorMSSQL\n",
                                "[67,9] cannot find symbol\n"
                            ]
                        }
                    },
                    "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java": {
                        "12": {
                            "lines": [
                                {
                                    "line_no": 11,
                                    "content": "import liquibase.statement.core.CreateIndexStatement;"
                                },
                                {
                                    "line_no": 12,
                                    "content": "import org.apache.commons.lang3.StringUtils;"
                                },
                                {
                                    "line_no": 13,
                                    "content": ""
                                }
                            ],
                            "error_texts": [
                                "[12,32] package org.apache.commons.lang3 does not exist\n"
                            ]
                        },
                        "77": {
                            "lines": [
                                {
                                    "line_no": 76,
                                    "content": "    // This block simplified, since we know we have MSSQLDatabase"
                                },
                                {
                                    "line_no": 77,
                                    "content": "    if (StringUtils.trimToNull(statement.getTablespace()) != null) {"
                                },
                                {
                                    "line_no": 78,
                                    "content": "      builder.append(\" ON \").append(statement.getTablespace());"
                                }
                            ],
                            "error_texts": [
                                "[77,9] cannot find symbol\n",
                                "[77,9] cannot find symbol\nsymbol: variable StringUtils\nlocation: class liquibase.ext.mssql.sqlgenerator.CreateIndexGeneratorMSSQL\n"
                            ]
                        }
                    },
                    "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java": {
                        "18": {
                            "lines": [
                                {
                                    "line_no": 17,
                                    "content": "        super.dropDatabaseObjects(schemaToDrop);"
                                },
                                {
                                    "line_no": 18,
                                    "content": "ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); "
                                },
                                {
                                    "line_no": 19,
                                    "content": "    }"
                                }
                            ],
                            "error_texts": [
                                "[18,16] cannot find symbol\nsymbol: method getInstance()\nlocation: class liquibase.executor.ExecutorService\n",
                                "[18,16] cannot find symbol\n"
                            ]
                        }
                    }
                }
            },
            "error": "cannot find symbol\n",
            "span_id": 8398435952865591345
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     String sql;\n     if (statement.getConstraintName() == null) {\n       sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n     } else {\n       sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n       if (!statement.isClustered()) {\n         sql += \" NONCLUSTERED\";\n       }\n       sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n     }\n \n     // the only new feature being added is support for fillFactor\n     sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n \n     if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n       sql += \" ON \"+statement.getTablespace();\n     }\n \n     if (statement.getForIndexName() != null) {\n       sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n     }\n \n     return new Sql[] {\n         new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n     };\n   }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -18,7 +18\n import liquibase.executor.ExecutorService; \n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n     \n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 17 exact lines in a row:\n```\n18,7 +18\nimport liquibase.executor.ExecutorService;\nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 17 exact lines in a row:\n```\n18,7 +18\nimport liquibase.executor.ExecutorService;\nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 14837362727144318148
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService; \n+import liquibase.executor.ExecutorService;\n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -18,7 +18\n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 5740823834763996907
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService; \n+import liquibase.executor.ExecutorService;\n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -18,7 +18\n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 16752560595503878126
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService; \n+import liquibase.executor.ExecutorService;\n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -18,7 +18\n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 2093836604986458376
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService; \n+import liquibase.executor.ExecutorService;\n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -18,7 +18\n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 5255695217468345132
        },
        {
            "input": "```diff\n--- src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n import java.util.Arrays;\n import java.util.Iterator;\n \n public class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   @Override\n   public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof CreateIndexStatementMSSQL) {\n       return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     StringBuilder builder = new StringBuilder();\n \n     // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n     builder.append(\"CREATE \");\n     if (statement.isUnique() != null && statement.isUnique()) {\n       builder.append(\"UNIQUE \");\n     }\n     \n     if (statement.isClustered() != null) {\n         if (statement.isClustered()) {\n             builder.append(\"CLUSTERED \");\n         } else {\n             builder.append(\"NONCLUSTERED \");\n         }\n     }\n     \n     builder.append(\"INDEX \");\n \n     if (statement.getIndexName() != null) {\n       String indexSchema = statement.getTableSchemaName();\n       builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n     }\n     builder.append(\"ON \");\n     builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n     Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n     while (iterator.hasNext()) {\n       AddColumnConfig column = iterator.next();\n       builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n       if (column.getDescending() != null && column.getDescending()) {\n           builder.append(\" DESC\");\n       }\n       if (iterator.hasNext()) {\n         builder.append(\", \");\n       }\n     }\n     if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n       builder.append(\") INCLUDE (\");\n       builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n     }\n     builder.append(\")\");\n     if (statement.getFillFactor() != null) {\n       builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n     }\n     // This block simplified, since we know we have MSSQLDatabase\n-    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n+    if (org.apache.commons.lang3.StringUtils.trimToNull(statement.getTablespace()) != null) {\n       builder.append(\" ON \").append(statement.getTablespace());\n     }\n \n     return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n   }\n \n   @Override\n   public boolean supports(CreateIndexStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n }\n--- src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n+++ src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java\n@@ -12,7 +12,7 @@\n import liquibase.util.StringUtils;\n \n public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n   @Override\n   public int getPriority() {\n     return 15;\n   }\n \n   /**\n    * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n    * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n    *\n    * Otherwise, defers to default liquibase implementation.\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   @Override\n   public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n     if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n       return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n     }\n \n     return super.generateSql(statement, database, sqlGeneratorChain);\n   }\n \n   /**\n    * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n    *\n    * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n    *\n    * 2) Added support for setting fillFactor\n    *\n    * @param statement\n    * @param database\n    * @param sqlGeneratorChain\n    * @return\n    */\n   private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n \n   @Override\n   public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n     return database instanceof MSSQLDatabase;\n   }\n \n }\n--- src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n+++ src/java/liquibase/ext/mssql/database/MSSQLDatabase.java\n@@ -1,7 +1,7 @@\n package liquibase.ext.mssql.database;\n \n import liquibase.CatalogAndSchema;\n import liquibase.exception.LiquibaseException;\n-import liquibase.executor.ExecutorService; \n+import liquibase.executor.ExecutorService;\n import liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n \n public class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n@@ -18,7 +18\n     @Override\n     public int getPriority() {\n         return PRIORITY_DATABASE;\n     }\n     \n     @Override\n     public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n         super.dropDatabaseObjects(schemaToDrop);\n-        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n+        liquibase.executor.ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n     }\n }\n```",
            "output": {
                "compilation_has_succeeded": false,
                "test_has_succeeded": false,
                "error_text": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
                "updated_files": {},
                "compile_error_details": {}
            },
            "error": "Failed to prepare diffs: Diff is not valid, UnifiedDiffNoMatch: hunk failed to apply!\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain lines that match the diff you provided!\nTry again.\nDO NOT, NEVER, skip blank lines, comments, docstrings, etc!\nThe diff needs to apply cleanly to the lines in src/java/liquibase/ext/mssql/database/MSSQLDatabase.java!\nMake extra sure the indentation is correct.\nsrc/java/liquibase/ext/mssql/database/MSSQLDatabase.java does not contain these 12 exact lines in a row:\n```\n18,7 +18\n@Override\npublic int getPriority() {\nreturn PRIORITY_DATABASE;\n}\n@Override\npublic void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\nsuper.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n}\n}\n```",
            "span_id": 8520617431863714548
        }
    ],
    "read_file": [
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport liquibase.util.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 5917912520644014591
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport liquibase.util.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 12059408736508217535
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService;\nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\n        ExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName()));\n    }\n}",
            "error": "",
            "span_id": 3675896479552199457
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 3073821338122685274
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 1977990151240513263
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 13884160019437196464
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 4631525738947081437
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 17513686287017480815
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 4871041465257388231
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 17107044557455836705
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 5243637851336310517
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 833500942662296991
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 1146276740347432574
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 5418718309833964411
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 1366151738496421845
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 10678709968795040409
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 1885708505067423308
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 8535136176903194068
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 941921272292015170
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 10330878640333154341
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 1122124739985633362
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/CreateIndexGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.change.AddColumnConfig;\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.CreateIndexStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.CreateIndexGenerator;\nimport liquibase.statement.core.CreateIndexStatement;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\n\npublic class CreateIndexGeneratorMSSQL extends CreateIndexGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  @Override\n  public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof CreateIndexStatementMSSQL) {\n      return generateMSSQLSql((CreateIndexStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  private Sql[] generateMSSQLSql(CreateIndexStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    StringBuilder builder = new StringBuilder();\n\n    // Basically copied from liquibase.sqlgenerator.core.CreateIndexGenerator\n    builder.append(\"CREATE \");\n    if (statement.isUnique() != null && statement.isUnique()) {\n      builder.append(\"UNIQUE \");\n    }\n    \n    if (statement.isClustered() != null) {\n        if (statement.isClustered()) {\n            builder.append(\"CLUSTERED \");\n        } else {\n            builder.append(\"NONCLUSTERED \");\n        }\n    }\n    \n    builder.append(\"INDEX \");\n\n    if (statement.getIndexName() != null) {\n      String indexSchema = statement.getTableSchemaName();\n      builder.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema, statement.getIndexName())).append(\" \");\n    }\n    builder.append(\"ON \");\n    builder.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName())).append(\"(\");\n    Iterator<AddColumnConfig> iterator = Arrays.asList(statement.getColumns()).iterator();\n    while (iterator.hasNext()) {\n      AddColumnConfig column = iterator.next();\n      builder.append(database.escapeColumnName(statement.getTableCatalogName(), statement.getTableSchemaName(), statement.getTableName(), column.getName()));\n      if (column.getDescending() != null && column.getDescending()) {\n          builder.append(\" DESC\");\n      }\n      if (iterator.hasNext()) {\n        builder.append(\", \");\n      }\n    }\n    if (statement.getIncludedColumns() != null && ! statement.getIncludedColumns().isEmpty()) {\n      builder.append(\") INCLUDE (\");\n      builder.append(database.escapeColumnNameList(statement.getIncludedColumns()));\n    }\n    builder.append(\")\");\n    if (statement.getFillFactor() != null) {\n      builder.append(\" WITH (FILLFACTOR = \").append(statement.getFillFactor()).append(\")\");\n    }\n    // This block simplified, since we know we have MSSQLDatabase\n    if (StringUtils.trimToNull(statement.getTablespace()) != null) {\n      builder.append(\" ON \").append(statement.getTablespace());\n    }\n\n    return new Sql[]{new UnparsedSql(builder.toString(), getAffectedIndex(statement))};\n  }\n\n  @Override\n  public boolean supports(CreateIndexStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n}\n",
            "error": "",
            "span_id": 5342674314794155820
        },
        {
            "input": "src/java/liquibase/ext/mssql/database/MSSQLDatabase.java",
            "output": "package liquibase.ext.mssql.database;\n\nimport liquibase.CatalogAndSchema;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.executor.ExecutorService; \nimport liquibase.ext.mssql.statement.DropStoredProcedureStatement;\n\npublic class MSSQLDatabase extends liquibase.database.core.MSSQLDatabase {\n    \n    @Override\n    public int getPriority() {\n        return PRIORITY_DATABASE;\n    }\n    \n    @Override\n    public void dropDatabaseObjects(CatalogAndSchema schemaToDrop) throws LiquibaseException {\n        super.dropDatabaseObjects(schemaToDrop);\nExecutorService.getInstance().getExecutor(this).execute(new DropStoredProcedureStatement(this.getLiquibaseCatalogName(), this.getLiquibaseSchemaName())); \n    }\n}",
            "error": "",
            "span_id": 5842722285152608397
        },
        {
            "input": "src/java/liquibase/ext/mssql/sqlgenerator/AddPrimaryKeyGeneratorMSSQL.java",
            "output": "package liquibase.ext.mssql.sqlgenerator;\n\nimport liquibase.database.Database;\nimport liquibase.ext.mssql.database.MSSQLDatabase;\nimport liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;\nimport liquibase.sql.Sql;\nimport liquibase.sql.UnparsedSql;\nimport liquibase.sqlgenerator.SqlGeneratorChain;\nimport liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;\nimport liquibase.statement.core.AddPrimaryKeyStatement;\nimport liquibase.structure.core.Index;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {\n  @Override\n  public int getPriority() {\n    return 15;\n  }\n\n  /**\n   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the\n   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.\n   *\n   * Otherwise, defers to default liquibase implementation.\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  @Override\n  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {\n      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);\n    }\n\n    return super.generateSql(statement, database, sqlGeneratorChain);\n  }\n\n  /**\n   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:\n   *\n   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)\n   *\n   * 2) Added support for setting fillFactor\n   *\n   * @param statement\n   * @param database\n   * @param sqlGeneratorChain\n   * @return\n   */\n  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {\n    String sql;\n    if (statement.getConstraintName() == null) {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD PRIMARY KEY (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    } else {\n      sql = \"ALTER TABLE \" + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + \" ADD CONSTRAINT \" + database.escapeConstraintName(statement.getConstraintName())+\" PRIMARY KEY\";\n      if (!statement.isClustered()) {\n        sql += \" NONCLUSTERED\";\n      }\n      sql += \" (\" + database.escapeColumnNameList(statement.getColumnNames()) + \")\";\n    }\n\n    // the only new feature being added is support for fillFactor\n    sql += \" WITH (FILLFACTOR = \" + statement.getFillFactor() + \")\";\n\n    if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {\n      sql += \" ON \"+statement.getTablespace();\n    }\n\n    if (statement.getForIndexName() != null) {\n      sql += \" USING INDEX \"+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);\n    }\n\n    return new Sql[] {\n        new UnparsedSql(sql, getAffectedPrimaryKey(statement))\n    };\n  }\n\n  @Override\n  public boolean supports(AddPrimaryKeyStatement statement, Database database) {\n    return database instanceof MSSQLDatabase;\n  }\n\n}\n",
            "error": "",
            "span_id": 14453310734016840362
        }
    ],
    "get_directory_tree": [],
    "get_language_server_suggestions": [],
    "reset_repo": []
}