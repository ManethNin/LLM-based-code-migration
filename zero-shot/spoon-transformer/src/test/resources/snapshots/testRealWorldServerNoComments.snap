package com.wire.lithium;

import com.codahale.metrics.Gauge;
import com.codahale.metrics.health.HealthCheck;
import com.codahale.metrics.jmx.JmxReporter;
import com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider;
import com.wire.lithium.healthchecks.Alice2Bob;
import com.wire.lithium.healthchecks.CryptoHealthCheck;
import com.wire.lithium.healthchecks.Outbound;
import com.wire.lithium.healthchecks.StorageHealthCheck;
import com.wire.lithium.server.filters.AuthenticationFeature;
import com.wire.lithium.server.monitoring.RequestMdcFactoryFilter;
import com.wire.lithium.server.monitoring.StatusResource;
import com.wire.lithium.server.monitoring.VersionResource;
import com.wire.lithium.server.resources.BotsResource;
import com.wire.lithium.server.resources.MessageResource;
import com.wire.lithium.server.tasks.AvailablePrekeysTask;
import com.wire.lithium.server.tasks.ConversationTask;
import com.wire.xenon.Const;
import com.wire.xenon.MessageHandlerBase;
import com.wire.xenon.crypto.CryptoDatabase;
import com.wire.xenon.crypto.CryptoFile;
import com.wire.xenon.crypto.storage.JdbiStorage;
import com.wire.xenon.factories.CryptoFactory;
import com.wire.xenon.factories.StorageFactory;
import com.wire.xenon.state.FileState;
import com.wire.xenon.state.JdbiState;
import com.wire.xenon.tools.Logger;
import io.dropwizard.Application;
import io.dropwizard.client.JerseyClientBuilder;
import io.dropwizard.configuration.EnvironmentVariableSubstitutor;
import io.dropwizard.configuration.SubstitutingSourceProvider;
import io.dropwizard.servlets.tasks.Task;
import io.dropwizard.setup.Bootstrap;
import io.dropwizard.setup.Environment;
import io.federecio.dropwizard.swagger.SwaggerBundle;
import io.federecio.dropwizard.swagger.SwaggerBundleConfiguration;
import org.flywaydb.core.Flyway;
import org.glassfish.jersey.media.multipart.MultiPartFeature;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.sqlobject.SqlObjectPlugin;
import javax.annotation.Nullable;
import javax.ws.rs.client.Client;
import java.util.SortedMap;
import java.util.concurrent.TimeUnit;

public abstract class Server<Config extends Configuration> extends Application<Config> {
    protected ClientRepo repo;

    protected Environment environment;

    protected abstract MessageHandlerBase createHandler(Config config, Environment env) throws Exception;

    @SuppressWarnings("RedundantThrows") // this method can be overridden
    protected void onRun(Config config, Environment env) throws Exception {

    }

    @Override
    public void initialize(Bootstrap<Config> bootstrap) {
        bootstrap.setConfigurationSourceProvider(new SubstitutingSourceProvider(
                bootstrap.getConfigurationSourceProvider(), new EnvironmentVariableSubstitutor(false)));
        bootstrap.addBundle(new SwaggerBundle<>() {
            @Override
            protected SwaggerBundleConfiguration getSwaggerBundleConfiguration(Config configuration) {
                return configuration.swagger;
            }
        });
    }

    private Client createHttpClient(Config config, Environment env) {
        return new JerseyClientBuilder(env)
                .using(config.getJerseyClient())
                .withProvider(MultiPartFeature.class)
                .withProvider(JacksonJsonProvider.class)
                .build(getName());
    }

    private void runHealthChecks() {
        Logger.info("Running health checks...");
        final SortedMap<String, HealthCheck.Result> results = environment.healthChecks().runHealthChecks();
        for (String name : results.keySet()) {
            final HealthCheck.Result result = results.get(name);
            if (!result.isHealthy()) {
                Logger.error("%s failed with: %s", name, result.getMessage());
                throw new RuntimeException(result.getError());
            }
        }
    }

    public ClientRepo getRepo() {
        return repo;
    }

}